"format register";

System.register("npm:process@0.10.1/browser", [], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  var process = module.exports = {};
  var queue = [];
  var draining = false;
  function drainQueue() {
    if (draining) {
      return ;
    }
    draining = true;
    var currentQueue;
    var len = queue.length;
    while (len) {
      currentQueue = queue;
      queue = [];
      var i = -1;
      while (++i < len) {
        currentQueue[i]();
      }
      len = queue.length;
    }
    draining = false;
  }
  process.nextTick = function(fun) {
    queue.push(fun);
    if (!draining) {
      setTimeout(drainQueue, 0);
    }
  };
  process.title = 'browser';
  process.browser = true;
  process.env = {};
  process.argv = [];
  process.version = '';
  process.versions = {};
  function noop() {}
  process.on = noop;
  process.addListener = noop;
  process.once = noop;
  process.off = noop;
  process.removeListener = noop;
  process.removeAllListeners = noop;
  process.emit = noop;
  process.binding = function(name) {
    throw new Error('process.binding is not supported');
  };
  process.cwd = function() {
    return '/';
  };
  process.chdir = function(dir) {
    throw new Error('process.chdir is not supported');
  };
  process.umask = function() {
    return 0;
  };
  global.define = __define;
  return module.exports;
});

System.register("github:mrdoob/three.js@master/build/three", [], false, function(__require, __exports, __module) {
  System.get("@@global-helpers").prepareGlobal(__module.id, []);
  (function() {
    var THREE = this["THREE"];
    var THREE = {REVISION: '71'};
    if (typeof module === 'object') {
      module.exports = THREE;
    }
    if (Math.sign === undefined) {
      Math.sign = function(x) {
        return (x < 0) ? -1 : (x > 0) ? 1 : +x;
      };
    }
    THREE.log = function() {
      console.log.apply(console, arguments);
    };
    THREE.warn = function() {
      console.warn.apply(console, arguments);
    };
    THREE.error = function() {
      console.error.apply(console, arguments);
    };
    THREE.MOUSE = {
      LEFT: 0,
      MIDDLE: 1,
      RIGHT: 2
    };
    THREE.CullFaceNone = 0;
    THREE.CullFaceBack = 1;
    THREE.CullFaceFront = 2;
    THREE.CullFaceFrontBack = 3;
    THREE.FrontFaceDirectionCW = 0;
    THREE.FrontFaceDirectionCCW = 1;
    THREE.BasicShadowMap = 0;
    THREE.PCFShadowMap = 1;
    THREE.PCFSoftShadowMap = 2;
    THREE.FrontSide = 0;
    THREE.BackSide = 1;
    THREE.DoubleSide = 2;
    THREE.NoShading = 0;
    THREE.FlatShading = 1;
    THREE.SmoothShading = 2;
    THREE.NoColors = 0;
    THREE.FaceColors = 1;
    THREE.VertexColors = 2;
    THREE.NoBlending = 0;
    THREE.NormalBlending = 1;
    THREE.AdditiveBlending = 2;
    THREE.SubtractiveBlending = 3;
    THREE.MultiplyBlending = 4;
    THREE.CustomBlending = 5;
    THREE.AddEquation = 100;
    THREE.SubtractEquation = 101;
    THREE.ReverseSubtractEquation = 102;
    THREE.MinEquation = 103;
    THREE.MaxEquation = 104;
    THREE.ZeroFactor = 200;
    THREE.OneFactor = 201;
    THREE.SrcColorFactor = 202;
    THREE.OneMinusSrcColorFactor = 203;
    THREE.SrcAlphaFactor = 204;
    THREE.OneMinusSrcAlphaFactor = 205;
    THREE.DstAlphaFactor = 206;
    THREE.OneMinusDstAlphaFactor = 207;
    THREE.DstColorFactor = 208;
    THREE.OneMinusDstColorFactor = 209;
    THREE.SrcAlphaSaturateFactor = 210;
    THREE.MultiplyOperation = 0;
    THREE.MixOperation = 1;
    THREE.AddOperation = 2;
    THREE.UVMapping = 300;
    THREE.CubeReflectionMapping = 301;
    THREE.CubeRefractionMapping = 302;
    THREE.EquirectangularReflectionMapping = 303;
    THREE.EquirectangularRefractionMapping = 304;
    THREE.SphericalReflectionMapping = 305;
    THREE.RepeatWrapping = 1000;
    THREE.ClampToEdgeWrapping = 1001;
    THREE.MirroredRepeatWrapping = 1002;
    THREE.NearestFilter = 1003;
    THREE.NearestMipMapNearestFilter = 1004;
    THREE.NearestMipMapLinearFilter = 1005;
    THREE.LinearFilter = 1006;
    THREE.LinearMipMapNearestFilter = 1007;
    THREE.LinearMipMapLinearFilter = 1008;
    THREE.UnsignedByteType = 1009;
    THREE.ByteType = 1010;
    THREE.ShortType = 1011;
    THREE.UnsignedShortType = 1012;
    THREE.IntType = 1013;
    THREE.UnsignedIntType = 1014;
    THREE.FloatType = 1015;
    THREE.HalfFloatType = 1025;
    THREE.UnsignedShort4444Type = 1016;
    THREE.UnsignedShort5551Type = 1017;
    THREE.UnsignedShort565Type = 1018;
    THREE.AlphaFormat = 1019;
    THREE.RGBFormat = 1020;
    THREE.RGBAFormat = 1021;
    THREE.LuminanceFormat = 1022;
    THREE.LuminanceAlphaFormat = 1023;
    THREE.RGBEFormat = THREE.RGBAFormat;
    THREE.RGB_S3TC_DXT1_Format = 2001;
    THREE.RGBA_S3TC_DXT1_Format = 2002;
    THREE.RGBA_S3TC_DXT3_Format = 2003;
    THREE.RGBA_S3TC_DXT5_Format = 2004;
    THREE.RGB_PVRTC_4BPPV1_Format = 2100;
    THREE.RGB_PVRTC_2BPPV1_Format = 2101;
    THREE.RGBA_PVRTC_4BPPV1_Format = 2102;
    THREE.RGBA_PVRTC_2BPPV1_Format = 2103;
    THREE.Projector = function() {
      THREE.error('THREE.Projector has been moved to /examples/js/renderers/Projector.js.');
      this.projectVector = function(vector, camera) {
        THREE.warn('THREE.Projector: .projectVector() is now vector.project().');
        vector.project(camera);
      };
      this.unprojectVector = function(vector, camera) {
        THREE.warn('THREE.Projector: .unprojectVector() is now vector.unproject().');
        vector.unproject(camera);
      };
      this.pickingRay = function(vector, camera) {
        THREE.error('THREE.Projector: .pickingRay() is now raycaster.setFromCamera().');
      };
    };
    THREE.CanvasRenderer = function() {
      THREE.error('THREE.CanvasRenderer has been moved to /examples/js/renderers/CanvasRenderer.js');
      this.domElement = document.createElement('canvas');
      this.clear = function() {};
      this.render = function() {};
      this.setClearColor = function() {};
      this.setSize = function() {};
    };
    THREE.Color = function(color) {
      if (arguments.length === 3) {
        return this.setRGB(arguments[0], arguments[1], arguments[2]);
      }
      return this.set(color);
    };
    THREE.Color.prototype = {
      constructor: THREE.Color,
      r: 1,
      g: 1,
      b: 1,
      set: function(value) {
        if (value instanceof THREE.Color) {
          this.copy(value);
        } else if (typeof value === 'number') {
          this.setHex(value);
        } else if (typeof value === 'string') {
          this.setStyle(value);
        }
        return this;
      },
      setHex: function(hex) {
        hex = Math.floor(hex);
        this.r = (hex >> 16 & 255) / 255;
        this.g = (hex >> 8 & 255) / 255;
        this.b = (hex & 255) / 255;
        return this;
      },
      setRGB: function(r, g, b) {
        this.r = r;
        this.g = g;
        this.b = b;
        return this;
      },
      setHSL: function(h, s, l) {
        if (s === 0) {
          this.r = this.g = this.b = l;
        } else {
          var hue2rgb = function(p, q, t) {
            if (t < 0)
              t += 1;
            if (t > 1)
              t -= 1;
            if (t < 1 / 6)
              return p + (q - p) * 6 * t;
            if (t < 1 / 2)
              return q;
            if (t < 2 / 3)
              return p + (q - p) * 6 * (2 / 3 - t);
            return p;
          };
          var p = l <= 0.5 ? l * (1 + s) : l + s - (l * s);
          var q = (2 * l) - p;
          this.r = hue2rgb(q, p, h + 1 / 3);
          this.g = hue2rgb(q, p, h);
          this.b = hue2rgb(q, p, h - 1 / 3);
        }
        return this;
      },
      setStyle: function(style) {
        if (/^rgb\((\d+), ?(\d+), ?(\d+)\)$/i.test(style)) {
          var color = /^rgb\((\d+), ?(\d+), ?(\d+)\)$/i.exec(style);
          this.r = Math.min(255, parseInt(color[1], 10)) / 255;
          this.g = Math.min(255, parseInt(color[2], 10)) / 255;
          this.b = Math.min(255, parseInt(color[3], 10)) / 255;
          return this;
        }
        if (/^rgb\((\d+)\%, ?(\d+)\%, ?(\d+)\%\)$/i.test(style)) {
          var color = /^rgb\((\d+)\%, ?(\d+)\%, ?(\d+)\%\)$/i.exec(style);
          this.r = Math.min(100, parseInt(color[1], 10)) / 100;
          this.g = Math.min(100, parseInt(color[2], 10)) / 100;
          this.b = Math.min(100, parseInt(color[3], 10)) / 100;
          return this;
        }
        if (/^\#([0-9a-f]{6})$/i.test(style)) {
          var color = /^\#([0-9a-f]{6})$/i.exec(style);
          this.setHex(parseInt(color[1], 16));
          return this;
        }
        if (/^\#([0-9a-f])([0-9a-f])([0-9a-f])$/i.test(style)) {
          var color = /^\#([0-9a-f])([0-9a-f])([0-9a-f])$/i.exec(style);
          this.setHex(parseInt(color[1] + color[1] + color[2] + color[2] + color[3] + color[3], 16));
          return this;
        }
        if (/^(\w+)$/i.test(style)) {
          this.setHex(THREE.ColorKeywords[style]);
          return this;
        }
      },
      copy: function(color) {
        this.r = color.r;
        this.g = color.g;
        this.b = color.b;
        return this;
      },
      copyGammaToLinear: function(color, gammaFactor) {
        if (gammaFactor === undefined)
          gammaFactor = 2.0;
        this.r = Math.pow(color.r, gammaFactor);
        this.g = Math.pow(color.g, gammaFactor);
        this.b = Math.pow(color.b, gammaFactor);
        return this;
      },
      copyLinearToGamma: function(color, gammaFactor) {
        if (gammaFactor === undefined)
          gammaFactor = 2.0;
        var safeInverse = (gammaFactor > 0) ? (1.0 / gammaFactor) : 1.0;
        this.r = Math.pow(color.r, safeInverse);
        this.g = Math.pow(color.g, safeInverse);
        this.b = Math.pow(color.b, safeInverse);
        return this;
      },
      convertGammaToLinear: function() {
        var r = this.r,
            g = this.g,
            b = this.b;
        this.r = r * r;
        this.g = g * g;
        this.b = b * b;
        return this;
      },
      convertLinearToGamma: function() {
        this.r = Math.sqrt(this.r);
        this.g = Math.sqrt(this.g);
        this.b = Math.sqrt(this.b);
        return this;
      },
      getHex: function() {
        return (this.r * 255) << 16 ^ (this.g * 255) << 8 ^ (this.b * 255) << 0;
      },
      getHexString: function() {
        return ('000000' + this.getHex().toString(16)).slice(-6);
      },
      getHSL: function(optionalTarget) {
        var hsl = optionalTarget || {
          h: 0,
          s: 0,
          l: 0
        };
        var r = this.r,
            g = this.g,
            b = this.b;
        var max = Math.max(r, g, b);
        var min = Math.min(r, g, b);
        var hue,
            saturation;
        var lightness = (min + max) / 2.0;
        if (min === max) {
          hue = 0;
          saturation = 0;
        } else {
          var delta = max - min;
          saturation = lightness <= 0.5 ? delta / (max + min) : delta / (2 - max - min);
          switch (max) {
            case r:
              hue = (g - b) / delta + (g < b ? 6 : 0);
              break;
            case g:
              hue = (b - r) / delta + 2;
              break;
            case b:
              hue = (r - g) / delta + 4;
              break;
          }
          hue /= 6;
        }
        hsl.h = hue;
        hsl.s = saturation;
        hsl.l = lightness;
        return hsl;
      },
      getStyle: function() {
        return 'rgb(' + ((this.r * 255) | 0) + ',' + ((this.g * 255) | 0) + ',' + ((this.b * 255) | 0) + ')';
      },
      offsetHSL: function(h, s, l) {
        var hsl = this.getHSL();
        hsl.h += h;
        hsl.s += s;
        hsl.l += l;
        this.setHSL(hsl.h, hsl.s, hsl.l);
        return this;
      },
      add: function(color) {
        this.r += color.r;
        this.g += color.g;
        this.b += color.b;
        return this;
      },
      addColors: function(color1, color2) {
        this.r = color1.r + color2.r;
        this.g = color1.g + color2.g;
        this.b = color1.b + color2.b;
        return this;
      },
      addScalar: function(s) {
        this.r += s;
        this.g += s;
        this.b += s;
        return this;
      },
      multiply: function(color) {
        this.r *= color.r;
        this.g *= color.g;
        this.b *= color.b;
        return this;
      },
      multiplyScalar: function(s) {
        this.r *= s;
        this.g *= s;
        this.b *= s;
        return this;
      },
      lerp: function(color, alpha) {
        this.r += (color.r - this.r) * alpha;
        this.g += (color.g - this.g) * alpha;
        this.b += (color.b - this.b) * alpha;
        return this;
      },
      equals: function(c) {
        return (c.r === this.r) && (c.g === this.g) && (c.b === this.b);
      },
      fromArray: function(array) {
        this.r = array[0];
        this.g = array[1];
        this.b = array[2];
        return this;
      },
      toArray: function(array, offset) {
        if (array === undefined)
          array = [];
        if (offset === undefined)
          offset = 0;
        array[offset] = this.r;
        array[offset + 1] = this.g;
        array[offset + 2] = this.b;
        return array;
      },
      clone: function() {
        return new THREE.Color().setRGB(this.r, this.g, this.b);
      }
    };
    THREE.ColorKeywords = {
      'aliceblue': 0xF0F8FF,
      'antiquewhite': 0xFAEBD7,
      'aqua': 0x00FFFF,
      'aquamarine': 0x7FFFD4,
      'azure': 0xF0FFFF,
      'beige': 0xF5F5DC,
      'bisque': 0xFFE4C4,
      'black': 0x000000,
      'blanchedalmond': 0xFFEBCD,
      'blue': 0x0000FF,
      'blueviolet': 0x8A2BE2,
      'brown': 0xA52A2A,
      'burlywood': 0xDEB887,
      'cadetblue': 0x5F9EA0,
      'chartreuse': 0x7FFF00,
      'chocolate': 0xD2691E,
      'coral': 0xFF7F50,
      'cornflowerblue': 0x6495ED,
      'cornsilk': 0xFFF8DC,
      'crimson': 0xDC143C,
      'cyan': 0x00FFFF,
      'darkblue': 0x00008B,
      'darkcyan': 0x008B8B,
      'darkgoldenrod': 0xB8860B,
      'darkgray': 0xA9A9A9,
      'darkgreen': 0x006400,
      'darkgrey': 0xA9A9A9,
      'darkkhaki': 0xBDB76B,
      'darkmagenta': 0x8B008B,
      'darkolivegreen': 0x556B2F,
      'darkorange': 0xFF8C00,
      'darkorchid': 0x9932CC,
      'darkred': 0x8B0000,
      'darksalmon': 0xE9967A,
      'darkseagreen': 0x8FBC8F,
      'darkslateblue': 0x483D8B,
      'darkslategray': 0x2F4F4F,
      'darkslategrey': 0x2F4F4F,
      'darkturquoise': 0x00CED1,
      'darkviolet': 0x9400D3,
      'deeppink': 0xFF1493,
      'deepskyblue': 0x00BFFF,
      'dimgray': 0x696969,
      'dimgrey': 0x696969,
      'dodgerblue': 0x1E90FF,
      'firebrick': 0xB22222,
      'floralwhite': 0xFFFAF0,
      'forestgreen': 0x228B22,
      'fuchsia': 0xFF00FF,
      'gainsboro': 0xDCDCDC,
      'ghostwhite': 0xF8F8FF,
      'gold': 0xFFD700,
      'goldenrod': 0xDAA520,
      'gray': 0x808080,
      'green': 0x008000,
      'greenyellow': 0xADFF2F,
      'grey': 0x808080,
      'honeydew': 0xF0FFF0,
      'hotpink': 0xFF69B4,
      'indianred': 0xCD5C5C,
      'indigo': 0x4B0082,
      'ivory': 0xFFFFF0,
      'khaki': 0xF0E68C,
      'lavender': 0xE6E6FA,
      'lavenderblush': 0xFFF0F5,
      'lawngreen': 0x7CFC00,
      'lemonchiffon': 0xFFFACD,
      'lightblue': 0xADD8E6,
      'lightcoral': 0xF08080,
      'lightcyan': 0xE0FFFF,
      'lightgoldenrodyellow': 0xFAFAD2,
      'lightgray': 0xD3D3D3,
      'lightgreen': 0x90EE90,
      'lightgrey': 0xD3D3D3,
      'lightpink': 0xFFB6C1,
      'lightsalmon': 0xFFA07A,
      'lightseagreen': 0x20B2AA,
      'lightskyblue': 0x87CEFA,
      'lightslategray': 0x778899,
      'lightslategrey': 0x778899,
      'lightsteelblue': 0xB0C4DE,
      'lightyellow': 0xFFFFE0,
      'lime': 0x00FF00,
      'limegreen': 0x32CD32,
      'linen': 0xFAF0E6,
      'magenta': 0xFF00FF,
      'maroon': 0x800000,
      'mediumaquamarine': 0x66CDAA,
      'mediumblue': 0x0000CD,
      'mediumorchid': 0xBA55D3,
      'mediumpurple': 0x9370DB,
      'mediumseagreen': 0x3CB371,
      'mediumslateblue': 0x7B68EE,
      'mediumspringgreen': 0x00FA9A,
      'mediumturquoise': 0x48D1CC,
      'mediumvioletred': 0xC71585,
      'midnightblue': 0x191970,
      'mintcream': 0xF5FFFA,
      'mistyrose': 0xFFE4E1,
      'moccasin': 0xFFE4B5,
      'navajowhite': 0xFFDEAD,
      'navy': 0x000080,
      'oldlace': 0xFDF5E6,
      'olive': 0x808000,
      'olivedrab': 0x6B8E23,
      'orange': 0xFFA500,
      'orangered': 0xFF4500,
      'orchid': 0xDA70D6,
      'palegoldenrod': 0xEEE8AA,
      'palegreen': 0x98FB98,
      'paleturquoise': 0xAFEEEE,
      'palevioletred': 0xDB7093,
      'papayawhip': 0xFFEFD5,
      'peachpuff': 0xFFDAB9,
      'peru': 0xCD853F,
      'pink': 0xFFC0CB,
      'plum': 0xDDA0DD,
      'powderblue': 0xB0E0E6,
      'purple': 0x800080,
      'red': 0xFF0000,
      'rosybrown': 0xBC8F8F,
      'royalblue': 0x4169E1,
      'saddlebrown': 0x8B4513,
      'salmon': 0xFA8072,
      'sandybrown': 0xF4A460,
      'seagreen': 0x2E8B57,
      'seashell': 0xFFF5EE,
      'sienna': 0xA0522D,
      'silver': 0xC0C0C0,
      'skyblue': 0x87CEEB,
      'slateblue': 0x6A5ACD,
      'slategray': 0x708090,
      'slategrey': 0x708090,
      'snow': 0xFFFAFA,
      'springgreen': 0x00FF7F,
      'steelblue': 0x4682B4,
      'tan': 0xD2B48C,
      'teal': 0x008080,
      'thistle': 0xD8BFD8,
      'tomato': 0xFF6347,
      'turquoise': 0x40E0D0,
      'violet': 0xEE82EE,
      'wheat': 0xF5DEB3,
      'white': 0xFFFFFF,
      'whitesmoke': 0xF5F5F5,
      'yellow': 0xFFFF00,
      'yellowgreen': 0x9ACD32
    };
    THREE.Quaternion = function(x, y, z, w) {
      this._x = x || 0;
      this._y = y || 0;
      this._z = z || 0;
      this._w = (w !== undefined) ? w : 1;
    };
    THREE.Quaternion.prototype = {
      constructor: THREE.Quaternion,
      _x: 0,
      _y: 0,
      _z: 0,
      _w: 0,
      get x() {
        return this._x;
      },
      set x(value) {
        this._x = value;
        this.onChangeCallback();
      },
      get y() {
        return this._y;
      },
      set y(value) {
        this._y = value;
        this.onChangeCallback();
      },
      get z() {
        return this._z;
      },
      set z(value) {
        this._z = value;
        this.onChangeCallback();
      },
      get w() {
        return this._w;
      },
      set w(value) {
        this._w = value;
        this.onChangeCallback();
      },
      set: function(x, y, z, w) {
        this._x = x;
        this._y = y;
        this._z = z;
        this._w = w;
        this.onChangeCallback();
        return this;
      },
      copy: function(quaternion) {
        this._x = quaternion.x;
        this._y = quaternion.y;
        this._z = quaternion.z;
        this._w = quaternion.w;
        this.onChangeCallback();
        return this;
      },
      setFromEuler: function(euler, update) {
        if (euler instanceof THREE.Euler === false) {
          throw new Error('THREE.Quaternion: .setFromEuler() now expects a Euler rotation rather than a Vector3 and order.');
        }
        var c1 = Math.cos(euler._x / 2);
        var c2 = Math.cos(euler._y / 2);
        var c3 = Math.cos(euler._z / 2);
        var s1 = Math.sin(euler._x / 2);
        var s2 = Math.sin(euler._y / 2);
        var s3 = Math.sin(euler._z / 2);
        if (euler.order === 'XYZ') {
          this._x = s1 * c2 * c3 + c1 * s2 * s3;
          this._y = c1 * s2 * c3 - s1 * c2 * s3;
          this._z = c1 * c2 * s3 + s1 * s2 * c3;
          this._w = c1 * c2 * c3 - s1 * s2 * s3;
        } else if (euler.order === 'YXZ') {
          this._x = s1 * c2 * c3 + c1 * s2 * s3;
          this._y = c1 * s2 * c3 - s1 * c2 * s3;
          this._z = c1 * c2 * s3 - s1 * s2 * c3;
          this._w = c1 * c2 * c3 + s1 * s2 * s3;
        } else if (euler.order === 'ZXY') {
          this._x = s1 * c2 * c3 - c1 * s2 * s3;
          this._y = c1 * s2 * c3 + s1 * c2 * s3;
          this._z = c1 * c2 * s3 + s1 * s2 * c3;
          this._w = c1 * c2 * c3 - s1 * s2 * s3;
        } else if (euler.order === 'ZYX') {
          this._x = s1 * c2 * c3 - c1 * s2 * s3;
          this._y = c1 * s2 * c3 + s1 * c2 * s3;
          this._z = c1 * c2 * s3 - s1 * s2 * c3;
          this._w = c1 * c2 * c3 + s1 * s2 * s3;
        } else if (euler.order === 'YZX') {
          this._x = s1 * c2 * c3 + c1 * s2 * s3;
          this._y = c1 * s2 * c3 + s1 * c2 * s3;
          this._z = c1 * c2 * s3 - s1 * s2 * c3;
          this._w = c1 * c2 * c3 - s1 * s2 * s3;
        } else if (euler.order === 'XZY') {
          this._x = s1 * c2 * c3 - c1 * s2 * s3;
          this._y = c1 * s2 * c3 - s1 * c2 * s3;
          this._z = c1 * c2 * s3 + s1 * s2 * c3;
          this._w = c1 * c2 * c3 + s1 * s2 * s3;
        }
        if (update !== false)
          this.onChangeCallback();
        return this;
      },
      setFromAxisAngle: function(axis, angle) {
        var halfAngle = angle / 2,
            s = Math.sin(halfAngle);
        this._x = axis.x * s;
        this._y = axis.y * s;
        this._z = axis.z * s;
        this._w = Math.cos(halfAngle);
        this.onChangeCallback();
        return this;
      },
      setFromRotationMatrix: function(m) {
        var te = m.elements,
            m11 = te[0],
            m12 = te[4],
            m13 = te[8],
            m21 = te[1],
            m22 = te[5],
            m23 = te[9],
            m31 = te[2],
            m32 = te[6],
            m33 = te[10],
            trace = m11 + m22 + m33,
            s;
        if (trace > 0) {
          s = 0.5 / Math.sqrt(trace + 1.0);
          this._w = 0.25 / s;
          this._x = (m32 - m23) * s;
          this._y = (m13 - m31) * s;
          this._z = (m21 - m12) * s;
        } else if (m11 > m22 && m11 > m33) {
          s = 2.0 * Math.sqrt(1.0 + m11 - m22 - m33);
          this._w = (m32 - m23) / s;
          this._x = 0.25 * s;
          this._y = (m12 + m21) / s;
          this._z = (m13 + m31) / s;
        } else if (m22 > m33) {
          s = 2.0 * Math.sqrt(1.0 + m22 - m11 - m33);
          this._w = (m13 - m31) / s;
          this._x = (m12 + m21) / s;
          this._y = 0.25 * s;
          this._z = (m23 + m32) / s;
        } else {
          s = 2.0 * Math.sqrt(1.0 + m33 - m11 - m22);
          this._w = (m21 - m12) / s;
          this._x = (m13 + m31) / s;
          this._y = (m23 + m32) / s;
          this._z = 0.25 * s;
        }
        this.onChangeCallback();
        return this;
      },
      setFromUnitVectors: function() {
        var v1,
            r;
        var EPS = 0.000001;
        return function(vFrom, vTo) {
          if (v1 === undefined)
            v1 = new THREE.Vector3();
          r = vFrom.dot(vTo) + 1;
          if (r < EPS) {
            r = 0;
            if (Math.abs(vFrom.x) > Math.abs(vFrom.z)) {
              v1.set(-vFrom.y, vFrom.x, 0);
            } else {
              v1.set(0, -vFrom.z, vFrom.y);
            }
          } else {
            v1.crossVectors(vFrom, vTo);
          }
          this._x = v1.x;
          this._y = v1.y;
          this._z = v1.z;
          this._w = r;
          this.normalize();
          return this;
        };
      }(),
      inverse: function() {
        this.conjugate().normalize();
        return this;
      },
      conjugate: function() {
        this._x *= -1;
        this._y *= -1;
        this._z *= -1;
        this.onChangeCallback();
        return this;
      },
      dot: function(v) {
        return this._x * v._x + this._y * v._y + this._z * v._z + this._w * v._w;
      },
      lengthSq: function() {
        return this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w;
      },
      length: function() {
        return Math.sqrt(this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w);
      },
      normalize: function() {
        var l = this.length();
        if (l === 0) {
          this._x = 0;
          this._y = 0;
          this._z = 0;
          this._w = 1;
        } else {
          l = 1 / l;
          this._x = this._x * l;
          this._y = this._y * l;
          this._z = this._z * l;
          this._w = this._w * l;
        }
        this.onChangeCallback();
        return this;
      },
      multiply: function(q, p) {
        if (p !== undefined) {
          THREE.warn('THREE.Quaternion: .multiply() now only accepts one argument. Use .multiplyQuaternions( a, b ) instead.');
          return this.multiplyQuaternions(q, p);
        }
        return this.multiplyQuaternions(this, q);
      },
      multiplyQuaternions: function(a, b) {
        var qax = a._x,
            qay = a._y,
            qaz = a._z,
            qaw = a._w;
        var qbx = b._x,
            qby = b._y,
            qbz = b._z,
            qbw = b._w;
        this._x = qax * qbw + qaw * qbx + qay * qbz - qaz * qby;
        this._y = qay * qbw + qaw * qby + qaz * qbx - qax * qbz;
        this._z = qaz * qbw + qaw * qbz + qax * qby - qay * qbx;
        this._w = qaw * qbw - qax * qbx - qay * qby - qaz * qbz;
        this.onChangeCallback();
        return this;
      },
      multiplyVector3: function(vector) {
        THREE.warn('THREE.Quaternion: .multiplyVector3() has been removed. Use is now vector.applyQuaternion( quaternion ) instead.');
        return vector.applyQuaternion(this);
      },
      slerp: function(qb, t) {
        if (t === 0)
          return this;
        if (t === 1)
          return this.copy(qb);
        var x = this._x,
            y = this._y,
            z = this._z,
            w = this._w;
        var cosHalfTheta = w * qb._w + x * qb._x + y * qb._y + z * qb._z;
        if (cosHalfTheta < 0) {
          this._w = -qb._w;
          this._x = -qb._x;
          this._y = -qb._y;
          this._z = -qb._z;
          cosHalfTheta = -cosHalfTheta;
        } else {
          this.copy(qb);
        }
        if (cosHalfTheta >= 1.0) {
          this._w = w;
          this._x = x;
          this._y = y;
          this._z = z;
          return this;
        }
        var halfTheta = Math.acos(cosHalfTheta);
        var sinHalfTheta = Math.sqrt(1.0 - cosHalfTheta * cosHalfTheta);
        if (Math.abs(sinHalfTheta) < 0.001) {
          this._w = 0.5 * (w + this._w);
          this._x = 0.5 * (x + this._x);
          this._y = 0.5 * (y + this._y);
          this._z = 0.5 * (z + this._z);
          return this;
        }
        var ratioA = Math.sin((1 - t) * halfTheta) / sinHalfTheta,
            ratioB = Math.sin(t * halfTheta) / sinHalfTheta;
        this._w = (w * ratioA + this._w * ratioB);
        this._x = (x * ratioA + this._x * ratioB);
        this._y = (y * ratioA + this._y * ratioB);
        this._z = (z * ratioA + this._z * ratioB);
        this.onChangeCallback();
        return this;
      },
      equals: function(quaternion) {
        return (quaternion._x === this._x) && (quaternion._y === this._y) && (quaternion._z === this._z) && (quaternion._w === this._w);
      },
      fromArray: function(array, offset) {
        if (offset === undefined)
          offset = 0;
        this._x = array[offset];
        this._y = array[offset + 1];
        this._z = array[offset + 2];
        this._w = array[offset + 3];
        this.onChangeCallback();
        return this;
      },
      toArray: function(array, offset) {
        if (array === undefined)
          array = [];
        if (offset === undefined)
          offset = 0;
        array[offset] = this._x;
        array[offset + 1] = this._y;
        array[offset + 2] = this._z;
        array[offset + 3] = this._w;
        return array;
      },
      onChange: function(callback) {
        this.onChangeCallback = callback;
        return this;
      },
      onChangeCallback: function() {},
      clone: function() {
        return new THREE.Quaternion(this._x, this._y, this._z, this._w);
      }
    };
    THREE.Quaternion.slerp = function(qa, qb, qm, t) {
      return qm.copy(qa).slerp(qb, t);
    };
    THREE.Vector2 = function(x, y) {
      this.x = x || 0;
      this.y = y || 0;
    };
    THREE.Vector2.prototype = {
      constructor: THREE.Vector2,
      set: function(x, y) {
        this.x = x;
        this.y = y;
        return this;
      },
      setX: function(x) {
        this.x = x;
        return this;
      },
      setY: function(y) {
        this.y = y;
        return this;
      },
      setComponent: function(index, value) {
        switch (index) {
          case 0:
            this.x = value;
            break;
          case 1:
            this.y = value;
            break;
          default:
            throw new Error('index is out of range: ' + index);
        }
      },
      getComponent: function(index) {
        switch (index) {
          case 0:
            return this.x;
          case 1:
            return this.y;
          default:
            throw new Error('index is out of range: ' + index);
        }
      },
      copy: function(v) {
        this.x = v.x;
        this.y = v.y;
        return this;
      },
      add: function(v, w) {
        if (w !== undefined) {
          THREE.warn('THREE.Vector2: .add() now only accepts one argument. Use .addVectors( a, b ) instead.');
          return this.addVectors(v, w);
        }
        this.x += v.x;
        this.y += v.y;
        return this;
      },
      addScalar: function(s) {
        this.x += s;
        this.y += s;
        return this;
      },
      addVectors: function(a, b) {
        this.x = a.x + b.x;
        this.y = a.y + b.y;
        return this;
      },
      sub: function(v, w) {
        if (w !== undefined) {
          THREE.warn('THREE.Vector2: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.');
          return this.subVectors(v, w);
        }
        this.x -= v.x;
        this.y -= v.y;
        return this;
      },
      subScalar: function(s) {
        this.x -= s;
        this.y -= s;
        return this;
      },
      subVectors: function(a, b) {
        this.x = a.x - b.x;
        this.y = a.y - b.y;
        return this;
      },
      multiply: function(v) {
        this.x *= v.x;
        this.y *= v.y;
        return this;
      },
      multiplyScalar: function(s) {
        this.x *= s;
        this.y *= s;
        return this;
      },
      divide: function(v) {
        this.x /= v.x;
        this.y /= v.y;
        return this;
      },
      divideScalar: function(scalar) {
        if (scalar !== 0) {
          var invScalar = 1 / scalar;
          this.x *= invScalar;
          this.y *= invScalar;
        } else {
          this.x = 0;
          this.y = 0;
        }
        return this;
      },
      min: function(v) {
        if (this.x > v.x) {
          this.x = v.x;
        }
        if (this.y > v.y) {
          this.y = v.y;
        }
        return this;
      },
      max: function(v) {
        if (this.x < v.x) {
          this.x = v.x;
        }
        if (this.y < v.y) {
          this.y = v.y;
        }
        return this;
      },
      clamp: function(min, max) {
        if (this.x < min.x) {
          this.x = min.x;
        } else if (this.x > max.x) {
          this.x = max.x;
        }
        if (this.y < min.y) {
          this.y = min.y;
        } else if (this.y > max.y) {
          this.y = max.y;
        }
        return this;
      },
      clampScalar: (function() {
        var min,
            max;
        return function(minVal, maxVal) {
          if (min === undefined) {
            min = new THREE.Vector2();
            max = new THREE.Vector2();
          }
          min.set(minVal, minVal);
          max.set(maxVal, maxVal);
          return this.clamp(min, max);
        };
      })(),
      floor: function() {
        this.x = Math.floor(this.x);
        this.y = Math.floor(this.y);
        return this;
      },
      ceil: function() {
        this.x = Math.ceil(this.x);
        this.y = Math.ceil(this.y);
        return this;
      },
      round: function() {
        this.x = Math.round(this.x);
        this.y = Math.round(this.y);
        return this;
      },
      roundToZero: function() {
        this.x = (this.x < 0) ? Math.ceil(this.x) : Math.floor(this.x);
        this.y = (this.y < 0) ? Math.ceil(this.y) : Math.floor(this.y);
        return this;
      },
      negate: function() {
        this.x = -this.x;
        this.y = -this.y;
        return this;
      },
      dot: function(v) {
        return this.x * v.x + this.y * v.y;
      },
      lengthSq: function() {
        return this.x * this.x + this.y * this.y;
      },
      length: function() {
        return Math.sqrt(this.x * this.x + this.y * this.y);
      },
      normalize: function() {
        return this.divideScalar(this.length());
      },
      distanceTo: function(v) {
        return Math.sqrt(this.distanceToSquared(v));
      },
      distanceToSquared: function(v) {
        var dx = this.x - v.x,
            dy = this.y - v.y;
        return dx * dx + dy * dy;
      },
      setLength: function(l) {
        var oldLength = this.length();
        if (oldLength !== 0 && l !== oldLength) {
          this.multiplyScalar(l / oldLength);
        }
        return this;
      },
      lerp: function(v, alpha) {
        this.x += (v.x - this.x) * alpha;
        this.y += (v.y - this.y) * alpha;
        return this;
      },
      lerpVectors: function(v1, v2, alpha) {
        this.subVectors(v2, v1).multiplyScalar(alpha).add(v1);
        return this;
      },
      equals: function(v) {
        return ((v.x === this.x) && (v.y === this.y));
      },
      fromArray: function(array, offset) {
        if (offset === undefined)
          offset = 0;
        this.x = array[offset];
        this.y = array[offset + 1];
        return this;
      },
      toArray: function(array, offset) {
        if (array === undefined)
          array = [];
        if (offset === undefined)
          offset = 0;
        array[offset] = this.x;
        array[offset + 1] = this.y;
        return array;
      },
      fromAttribute: function(attribute, index, offset) {
        if (offset === undefined)
          offset = 0;
        index = index * attribute.itemSize + offset;
        this.x = attribute.array[index];
        this.y = attribute.array[index + 1];
        return this;
      },
      clone: function() {
        return new THREE.Vector2(this.x, this.y);
      }
    };
    THREE.Vector3 = function(x, y, z) {
      this.x = x || 0;
      this.y = y || 0;
      this.z = z || 0;
    };
    THREE.Vector3.prototype = {
      constructor: THREE.Vector3,
      set: function(x, y, z) {
        this.x = x;
        this.y = y;
        this.z = z;
        return this;
      },
      setX: function(x) {
        this.x = x;
        return this;
      },
      setY: function(y) {
        this.y = y;
        return this;
      },
      setZ: function(z) {
        this.z = z;
        return this;
      },
      setComponent: function(index, value) {
        switch (index) {
          case 0:
            this.x = value;
            break;
          case 1:
            this.y = value;
            break;
          case 2:
            this.z = value;
            break;
          default:
            throw new Error('index is out of range: ' + index);
        }
      },
      getComponent: function(index) {
        switch (index) {
          case 0:
            return this.x;
          case 1:
            return this.y;
          case 2:
            return this.z;
          default:
            throw new Error('index is out of range: ' + index);
        }
      },
      copy: function(v) {
        this.x = v.x;
        this.y = v.y;
        this.z = v.z;
        return this;
      },
      add: function(v, w) {
        if (w !== undefined) {
          THREE.warn('THREE.Vector3: .add() now only accepts one argument. Use .addVectors( a, b ) instead.');
          return this.addVectors(v, w);
        }
        this.x += v.x;
        this.y += v.y;
        this.z += v.z;
        return this;
      },
      addScalar: function(s) {
        this.x += s;
        this.y += s;
        this.z += s;
        return this;
      },
      addVectors: function(a, b) {
        this.x = a.x + b.x;
        this.y = a.y + b.y;
        this.z = a.z + b.z;
        return this;
      },
      sub: function(v, w) {
        if (w !== undefined) {
          THREE.warn('THREE.Vector3: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.');
          return this.subVectors(v, w);
        }
        this.x -= v.x;
        this.y -= v.y;
        this.z -= v.z;
        return this;
      },
      subScalar: function(s) {
        this.x -= s;
        this.y -= s;
        this.z -= s;
        return this;
      },
      subVectors: function(a, b) {
        this.x = a.x - b.x;
        this.y = a.y - b.y;
        this.z = a.z - b.z;
        return this;
      },
      multiply: function(v, w) {
        if (w !== undefined) {
          THREE.warn('THREE.Vector3: .multiply() now only accepts one argument. Use .multiplyVectors( a, b ) instead.');
          return this.multiplyVectors(v, w);
        }
        this.x *= v.x;
        this.y *= v.y;
        this.z *= v.z;
        return this;
      },
      multiplyScalar: function(scalar) {
        this.x *= scalar;
        this.y *= scalar;
        this.z *= scalar;
        return this;
      },
      multiplyVectors: function(a, b) {
        this.x = a.x * b.x;
        this.y = a.y * b.y;
        this.z = a.z * b.z;
        return this;
      },
      applyEuler: function() {
        var quaternion;
        return function(euler) {
          if (euler instanceof THREE.Euler === false) {
            THREE.error('THREE.Vector3: .applyEuler() now expects a Euler rotation rather than a Vector3 and order.');
          }
          if (quaternion === undefined)
            quaternion = new THREE.Quaternion();
          this.applyQuaternion(quaternion.setFromEuler(euler));
          return this;
        };
      }(),
      applyAxisAngle: function() {
        var quaternion;
        return function(axis, angle) {
          if (quaternion === undefined)
            quaternion = new THREE.Quaternion();
          this.applyQuaternion(quaternion.setFromAxisAngle(axis, angle));
          return this;
        };
      }(),
      applyMatrix3: function(m) {
        var x = this.x;
        var y = this.y;
        var z = this.z;
        var e = m.elements;
        this.x = e[0] * x + e[3] * y + e[6] * z;
        this.y = e[1] * x + e[4] * y + e[7] * z;
        this.z = e[2] * x + e[5] * y + e[8] * z;
        return this;
      },
      applyMatrix4: function(m) {
        var x = this.x,
            y = this.y,
            z = this.z;
        var e = m.elements;
        this.x = e[0] * x + e[4] * y + e[8] * z + e[12];
        this.y = e[1] * x + e[5] * y + e[9] * z + e[13];
        this.z = e[2] * x + e[6] * y + e[10] * z + e[14];
        return this;
      },
      applyProjection: function(m) {
        var x = this.x,
            y = this.y,
            z = this.z;
        var e = m.elements;
        var d = 1 / (e[3] * x + e[7] * y + e[11] * z + e[15]);
        this.x = (e[0] * x + e[4] * y + e[8] * z + e[12]) * d;
        this.y = (e[1] * x + e[5] * y + e[9] * z + e[13]) * d;
        this.z = (e[2] * x + e[6] * y + e[10] * z + e[14]) * d;
        return this;
      },
      applyQuaternion: function(q) {
        var x = this.x;
        var y = this.y;
        var z = this.z;
        var qx = q.x;
        var qy = q.y;
        var qz = q.z;
        var qw = q.w;
        var ix = qw * x + qy * z - qz * y;
        var iy = qw * y + qz * x - qx * z;
        var iz = qw * z + qx * y - qy * x;
        var iw = -qx * x - qy * y - qz * z;
        this.x = ix * qw + iw * -qx + iy * -qz - iz * -qy;
        this.y = iy * qw + iw * -qy + iz * -qx - ix * -qz;
        this.z = iz * qw + iw * -qz + ix * -qy - iy * -qx;
        return this;
      },
      project: function() {
        var matrix;
        return function(camera) {
          if (matrix === undefined)
            matrix = new THREE.Matrix4();
          matrix.multiplyMatrices(camera.projectionMatrix, matrix.getInverse(camera.matrixWorld));
          return this.applyProjection(matrix);
        };
      }(),
      unproject: function() {
        var matrix;
        return function(camera) {
          if (matrix === undefined)
            matrix = new THREE.Matrix4();
          matrix.multiplyMatrices(camera.matrixWorld, matrix.getInverse(camera.projectionMatrix));
          return this.applyProjection(matrix);
        };
      }(),
      transformDirection: function(m) {
        var x = this.x,
            y = this.y,
            z = this.z;
        var e = m.elements;
        this.x = e[0] * x + e[4] * y + e[8] * z;
        this.y = e[1] * x + e[5] * y + e[9] * z;
        this.z = e[2] * x + e[6] * y + e[10] * z;
        this.normalize();
        return this;
      },
      divide: function(v) {
        this.x /= v.x;
        this.y /= v.y;
        this.z /= v.z;
        return this;
      },
      divideScalar: function(scalar) {
        if (scalar !== 0) {
          var invScalar = 1 / scalar;
          this.x *= invScalar;
          this.y *= invScalar;
          this.z *= invScalar;
        } else {
          this.x = 0;
          this.y = 0;
          this.z = 0;
        }
        return this;
      },
      min: function(v) {
        if (this.x > v.x) {
          this.x = v.x;
        }
        if (this.y > v.y) {
          this.y = v.y;
        }
        if (this.z > v.z) {
          this.z = v.z;
        }
        return this;
      },
      max: function(v) {
        if (this.x < v.x) {
          this.x = v.x;
        }
        if (this.y < v.y) {
          this.y = v.y;
        }
        if (this.z < v.z) {
          this.z = v.z;
        }
        return this;
      },
      clamp: function(min, max) {
        if (this.x < min.x) {
          this.x = min.x;
        } else if (this.x > max.x) {
          this.x = max.x;
        }
        if (this.y < min.y) {
          this.y = min.y;
        } else if (this.y > max.y) {
          this.y = max.y;
        }
        if (this.z < min.z) {
          this.z = min.z;
        } else if (this.z > max.z) {
          this.z = max.z;
        }
        return this;
      },
      clampScalar: (function() {
        var min,
            max;
        return function(minVal, maxVal) {
          if (min === undefined) {
            min = new THREE.Vector3();
            max = new THREE.Vector3();
          }
          min.set(minVal, minVal, minVal);
          max.set(maxVal, maxVal, maxVal);
          return this.clamp(min, max);
        };
      })(),
      floor: function() {
        this.x = Math.floor(this.x);
        this.y = Math.floor(this.y);
        this.z = Math.floor(this.z);
        return this;
      },
      ceil: function() {
        this.x = Math.ceil(this.x);
        this.y = Math.ceil(this.y);
        this.z = Math.ceil(this.z);
        return this;
      },
      round: function() {
        this.x = Math.round(this.x);
        this.y = Math.round(this.y);
        this.z = Math.round(this.z);
        return this;
      },
      roundToZero: function() {
        this.x = (this.x < 0) ? Math.ceil(this.x) : Math.floor(this.x);
        this.y = (this.y < 0) ? Math.ceil(this.y) : Math.floor(this.y);
        this.z = (this.z < 0) ? Math.ceil(this.z) : Math.floor(this.z);
        return this;
      },
      negate: function() {
        this.x = -this.x;
        this.y = -this.y;
        this.z = -this.z;
        return this;
      },
      dot: function(v) {
        return this.x * v.x + this.y * v.y + this.z * v.z;
      },
      lengthSq: function() {
        return this.x * this.x + this.y * this.y + this.z * this.z;
      },
      length: function() {
        return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z);
      },
      lengthManhattan: function() {
        return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z);
      },
      normalize: function() {
        return this.divideScalar(this.length());
      },
      setLength: function(l) {
        var oldLength = this.length();
        if (oldLength !== 0 && l !== oldLength) {
          this.multiplyScalar(l / oldLength);
        }
        return this;
      },
      lerp: function(v, alpha) {
        this.x += (v.x - this.x) * alpha;
        this.y += (v.y - this.y) * alpha;
        this.z += (v.z - this.z) * alpha;
        return this;
      },
      lerpVectors: function(v1, v2, alpha) {
        this.subVectors(v2, v1).multiplyScalar(alpha).add(v1);
        return this;
      },
      cross: function(v, w) {
        if (w !== undefined) {
          THREE.warn('THREE.Vector3: .cross() now only accepts one argument. Use .crossVectors( a, b ) instead.');
          return this.crossVectors(v, w);
        }
        var x = this.x,
            y = this.y,
            z = this.z;
        this.x = y * v.z - z * v.y;
        this.y = z * v.x - x * v.z;
        this.z = x * v.y - y * v.x;
        return this;
      },
      crossVectors: function(a, b) {
        var ax = a.x,
            ay = a.y,
            az = a.z;
        var bx = b.x,
            by = b.y,
            bz = b.z;
        this.x = ay * bz - az * by;
        this.y = az * bx - ax * bz;
        this.z = ax * by - ay * bx;
        return this;
      },
      projectOnVector: function() {
        var v1,
            dot;
        return function(vector) {
          if (v1 === undefined)
            v1 = new THREE.Vector3();
          v1.copy(vector).normalize();
          dot = this.dot(v1);
          return this.copy(v1).multiplyScalar(dot);
        };
      }(),
      projectOnPlane: function() {
        var v1;
        return function(planeNormal) {
          if (v1 === undefined)
            v1 = new THREE.Vector3();
          v1.copy(this).projectOnVector(planeNormal);
          return this.sub(v1);
        };
      }(),
      reflect: function() {
        var v1;
        return function(normal) {
          if (v1 === undefined)
            v1 = new THREE.Vector3();
          return this.sub(v1.copy(normal).multiplyScalar(2 * this.dot(normal)));
        };
      }(),
      angleTo: function(v) {
        var theta = this.dot(v) / (this.length() * v.length());
        return Math.acos(THREE.Math.clamp(theta, -1, 1));
      },
      distanceTo: function(v) {
        return Math.sqrt(this.distanceToSquared(v));
      },
      distanceToSquared: function(v) {
        var dx = this.x - v.x;
        var dy = this.y - v.y;
        var dz = this.z - v.z;
        return dx * dx + dy * dy + dz * dz;
      },
      setEulerFromRotationMatrix: function(m, order) {
        THREE.error('THREE.Vector3: .setEulerFromRotationMatrix() has been removed. Use Euler.setFromRotationMatrix() instead.');
      },
      setEulerFromQuaternion: function(q, order) {
        THREE.error('THREE.Vector3: .setEulerFromQuaternion() has been removed. Use Euler.setFromQuaternion() instead.');
      },
      getPositionFromMatrix: function(m) {
        THREE.warn('THREE.Vector3: .getPositionFromMatrix() has been renamed to .setFromMatrixPosition().');
        return this.setFromMatrixPosition(m);
      },
      getScaleFromMatrix: function(m) {
        THREE.warn('THREE.Vector3: .getScaleFromMatrix() has been renamed to .setFromMatrixScale().');
        return this.setFromMatrixScale(m);
      },
      getColumnFromMatrix: function(index, matrix) {
        THREE.warn('THREE.Vector3: .getColumnFromMatrix() has been renamed to .setFromMatrixColumn().');
        return this.setFromMatrixColumn(index, matrix);
      },
      setFromMatrixPosition: function(m) {
        this.x = m.elements[12];
        this.y = m.elements[13];
        this.z = m.elements[14];
        return this;
      },
      setFromMatrixScale: function(m) {
        var sx = this.set(m.elements[0], m.elements[1], m.elements[2]).length();
        var sy = this.set(m.elements[4], m.elements[5], m.elements[6]).length();
        var sz = this.set(m.elements[8], m.elements[9], m.elements[10]).length();
        this.x = sx;
        this.y = sy;
        this.z = sz;
        return this;
      },
      setFromMatrixColumn: function(index, matrix) {
        var offset = index * 4;
        var me = matrix.elements;
        this.x = me[offset];
        this.y = me[offset + 1];
        this.z = me[offset + 2];
        return this;
      },
      equals: function(v) {
        return ((v.x === this.x) && (v.y === this.y) && (v.z === this.z));
      },
      fromArray: function(array, offset) {
        if (offset === undefined)
          offset = 0;
        this.x = array[offset];
        this.y = array[offset + 1];
        this.z = array[offset + 2];
        return this;
      },
      toArray: function(array, offset) {
        if (array === undefined)
          array = [];
        if (offset === undefined)
          offset = 0;
        array[offset] = this.x;
        array[offset + 1] = this.y;
        array[offset + 2] = this.z;
        return array;
      },
      fromAttribute: function(attribute, index, offset) {
        if (offset === undefined)
          offset = 0;
        index = index * attribute.itemSize + offset;
        this.x = attribute.array[index];
        this.y = attribute.array[index + 1];
        this.z = attribute.array[index + 2];
        return this;
      },
      clone: function() {
        return new THREE.Vector3(this.x, this.y, this.z);
      }
    };
    THREE.Vector4 = function(x, y, z, w) {
      this.x = x || 0;
      this.y = y || 0;
      this.z = z || 0;
      this.w = (w !== undefined) ? w : 1;
    };
    THREE.Vector4.prototype = {
      constructor: THREE.Vector4,
      set: function(x, y, z, w) {
        this.x = x;
        this.y = y;
        this.z = z;
        this.w = w;
        return this;
      },
      setX: function(x) {
        this.x = x;
        return this;
      },
      setY: function(y) {
        this.y = y;
        return this;
      },
      setZ: function(z) {
        this.z = z;
        return this;
      },
      setW: function(w) {
        this.w = w;
        return this;
      },
      setComponent: function(index, value) {
        switch (index) {
          case 0:
            this.x = value;
            break;
          case 1:
            this.y = value;
            break;
          case 2:
            this.z = value;
            break;
          case 3:
            this.w = value;
            break;
          default:
            throw new Error('index is out of range: ' + index);
        }
      },
      getComponent: function(index) {
        switch (index) {
          case 0:
            return this.x;
          case 1:
            return this.y;
          case 2:
            return this.z;
          case 3:
            return this.w;
          default:
            throw new Error('index is out of range: ' + index);
        }
      },
      copy: function(v) {
        this.x = v.x;
        this.y = v.y;
        this.z = v.z;
        this.w = (v.w !== undefined) ? v.w : 1;
        return this;
      },
      add: function(v, w) {
        if (w !== undefined) {
          THREE.warn('THREE.Vector4: .add() now only accepts one argument. Use .addVectors( a, b ) instead.');
          return this.addVectors(v, w);
        }
        this.x += v.x;
        this.y += v.y;
        this.z += v.z;
        this.w += v.w;
        return this;
      },
      addScalar: function(s) {
        this.x += s;
        this.y += s;
        this.z += s;
        this.w += s;
        return this;
      },
      addVectors: function(a, b) {
        this.x = a.x + b.x;
        this.y = a.y + b.y;
        this.z = a.z + b.z;
        this.w = a.w + b.w;
        return this;
      },
      sub: function(v, w) {
        if (w !== undefined) {
          THREE.warn('THREE.Vector4: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.');
          return this.subVectors(v, w);
        }
        this.x -= v.x;
        this.y -= v.y;
        this.z -= v.z;
        this.w -= v.w;
        return this;
      },
      subScalar: function(s) {
        this.x -= s;
        this.y -= s;
        this.z -= s;
        this.w -= s;
        return this;
      },
      subVectors: function(a, b) {
        this.x = a.x - b.x;
        this.y = a.y - b.y;
        this.z = a.z - b.z;
        this.w = a.w - b.w;
        return this;
      },
      multiplyScalar: function(scalar) {
        this.x *= scalar;
        this.y *= scalar;
        this.z *= scalar;
        this.w *= scalar;
        return this;
      },
      applyMatrix4: function(m) {
        var x = this.x;
        var y = this.y;
        var z = this.z;
        var w = this.w;
        var e = m.elements;
        this.x = e[0] * x + e[4] * y + e[8] * z + e[12] * w;
        this.y = e[1] * x + e[5] * y + e[9] * z + e[13] * w;
        this.z = e[2] * x + e[6] * y + e[10] * z + e[14] * w;
        this.w = e[3] * x + e[7] * y + e[11] * z + e[15] * w;
        return this;
      },
      divideScalar: function(scalar) {
        if (scalar !== 0) {
          var invScalar = 1 / scalar;
          this.x *= invScalar;
          this.y *= invScalar;
          this.z *= invScalar;
          this.w *= invScalar;
        } else {
          this.x = 0;
          this.y = 0;
          this.z = 0;
          this.w = 1;
        }
        return this;
      },
      setAxisAngleFromQuaternion: function(q) {
        this.w = 2 * Math.acos(q.w);
        var s = Math.sqrt(1 - q.w * q.w);
        if (s < 0.0001) {
          this.x = 1;
          this.y = 0;
          this.z = 0;
        } else {
          this.x = q.x / s;
          this.y = q.y / s;
          this.z = q.z / s;
        }
        return this;
      },
      setAxisAngleFromRotationMatrix: function(m) {
        var angle,
            x,
            y,
            z,
            epsilon = 0.01,
            epsilon2 = 0.1,
            te = m.elements,
            m11 = te[0],
            m12 = te[4],
            m13 = te[8],
            m21 = te[1],
            m22 = te[5],
            m23 = te[9],
            m31 = te[2],
            m32 = te[6],
            m33 = te[10];
        if ((Math.abs(m12 - m21) < epsilon) && (Math.abs(m13 - m31) < epsilon) && (Math.abs(m23 - m32) < epsilon)) {
          if ((Math.abs(m12 + m21) < epsilon2) && (Math.abs(m13 + m31) < epsilon2) && (Math.abs(m23 + m32) < epsilon2) && (Math.abs(m11 + m22 + m33 - 3) < epsilon2)) {
            this.set(1, 0, 0, 0);
            return this;
          }
          angle = Math.PI;
          var xx = (m11 + 1) / 2;
          var yy = (m22 + 1) / 2;
          var zz = (m33 + 1) / 2;
          var xy = (m12 + m21) / 4;
          var xz = (m13 + m31) / 4;
          var yz = (m23 + m32) / 4;
          if ((xx > yy) && (xx > zz)) {
            if (xx < epsilon) {
              x = 0;
              y = 0.707106781;
              z = 0.707106781;
            } else {
              x = Math.sqrt(xx);
              y = xy / x;
              z = xz / x;
            }
          } else if (yy > zz) {
            if (yy < epsilon) {
              x = 0.707106781;
              y = 0;
              z = 0.707106781;
            } else {
              y = Math.sqrt(yy);
              x = xy / y;
              z = yz / y;
            }
          } else {
            if (zz < epsilon) {
              x = 0.707106781;
              y = 0.707106781;
              z = 0;
            } else {
              z = Math.sqrt(zz);
              x = xz / z;
              y = yz / z;
            }
          }
          this.set(x, y, z, angle);
          return this;
        }
        var s = Math.sqrt((m32 - m23) * (m32 - m23) + (m13 - m31) * (m13 - m31) + (m21 - m12) * (m21 - m12));
        if (Math.abs(s) < 0.001)
          s = 1;
        this.x = (m32 - m23) / s;
        this.y = (m13 - m31) / s;
        this.z = (m21 - m12) / s;
        this.w = Math.acos((m11 + m22 + m33 - 1) / 2);
        return this;
      },
      min: function(v) {
        if (this.x > v.x) {
          this.x = v.x;
        }
        if (this.y > v.y) {
          this.y = v.y;
        }
        if (this.z > v.z) {
          this.z = v.z;
        }
        if (this.w > v.w) {
          this.w = v.w;
        }
        return this;
      },
      max: function(v) {
        if (this.x < v.x) {
          this.x = v.x;
        }
        if (this.y < v.y) {
          this.y = v.y;
        }
        if (this.z < v.z) {
          this.z = v.z;
        }
        if (this.w < v.w) {
          this.w = v.w;
        }
        return this;
      },
      clamp: function(min, max) {
        if (this.x < min.x) {
          this.x = min.x;
        } else if (this.x > max.x) {
          this.x = max.x;
        }
        if (this.y < min.y) {
          this.y = min.y;
        } else if (this.y > max.y) {
          this.y = max.y;
        }
        if (this.z < min.z) {
          this.z = min.z;
        } else if (this.z > max.z) {
          this.z = max.z;
        }
        if (this.w < min.w) {
          this.w = min.w;
        } else if (this.w > max.w) {
          this.w = max.w;
        }
        return this;
      },
      clampScalar: (function() {
        var min,
            max;
        return function(minVal, maxVal) {
          if (min === undefined) {
            min = new THREE.Vector4();
            max = new THREE.Vector4();
          }
          min.set(minVal, minVal, minVal, minVal);
          max.set(maxVal, maxVal, maxVal, maxVal);
          return this.clamp(min, max);
        };
      })(),
      floor: function() {
        this.x = Math.floor(this.x);
        this.y = Math.floor(this.y);
        this.z = Math.floor(this.z);
        this.w = Math.floor(this.w);
        return this;
      },
      ceil: function() {
        this.x = Math.ceil(this.x);
        this.y = Math.ceil(this.y);
        this.z = Math.ceil(this.z);
        this.w = Math.ceil(this.w);
        return this;
      },
      round: function() {
        this.x = Math.round(this.x);
        this.y = Math.round(this.y);
        this.z = Math.round(this.z);
        this.w = Math.round(this.w);
        return this;
      },
      roundToZero: function() {
        this.x = (this.x < 0) ? Math.ceil(this.x) : Math.floor(this.x);
        this.y = (this.y < 0) ? Math.ceil(this.y) : Math.floor(this.y);
        this.z = (this.z < 0) ? Math.ceil(this.z) : Math.floor(this.z);
        this.w = (this.w < 0) ? Math.ceil(this.w) : Math.floor(this.w);
        return this;
      },
      negate: function() {
        this.x = -this.x;
        this.y = -this.y;
        this.z = -this.z;
        this.w = -this.w;
        return this;
      },
      dot: function(v) {
        return this.x * v.x + this.y * v.y + this.z * v.z + this.w * v.w;
      },
      lengthSq: function() {
        return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w;
      },
      length: function() {
        return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w);
      },
      lengthManhattan: function() {
        return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z) + Math.abs(this.w);
      },
      normalize: function() {
        return this.divideScalar(this.length());
      },
      setLength: function(l) {
        var oldLength = this.length();
        if (oldLength !== 0 && l !== oldLength) {
          this.multiplyScalar(l / oldLength);
        }
        return this;
      },
      lerp: function(v, alpha) {
        this.x += (v.x - this.x) * alpha;
        this.y += (v.y - this.y) * alpha;
        this.z += (v.z - this.z) * alpha;
        this.w += (v.w - this.w) * alpha;
        return this;
      },
      lerpVectors: function(v1, v2, alpha) {
        this.subVectors(v2, v1).multiplyScalar(alpha).add(v1);
        return this;
      },
      equals: function(v) {
        return ((v.x === this.x) && (v.y === this.y) && (v.z === this.z) && (v.w === this.w));
      },
      fromArray: function(array, offset) {
        if (offset === undefined)
          offset = 0;
        this.x = array[offset];
        this.y = array[offset + 1];
        this.z = array[offset + 2];
        this.w = array[offset + 3];
        return this;
      },
      toArray: function(array, offset) {
        if (array === undefined)
          array = [];
        if (offset === undefined)
          offset = 0;
        array[offset] = this.x;
        array[offset + 1] = this.y;
        array[offset + 2] = this.z;
        array[offset + 3] = this.w;
        return array;
      },
      fromAttribute: function(attribute, index, offset) {
        if (offset === undefined)
          offset = 0;
        index = index * attribute.itemSize + offset;
        this.x = attribute.array[index];
        this.y = attribute.array[index + 1];
        this.z = attribute.array[index + 2];
        this.w = attribute.array[index + 3];
        return this;
      },
      clone: function() {
        return new THREE.Vector4(this.x, this.y, this.z, this.w);
      }
    };
    THREE.Euler = function(x, y, z, order) {
      this._x = x || 0;
      this._y = y || 0;
      this._z = z || 0;
      this._order = order || THREE.Euler.DefaultOrder;
    };
    THREE.Euler.RotationOrders = ['XYZ', 'YZX', 'ZXY', 'XZY', 'YXZ', 'ZYX'];
    THREE.Euler.DefaultOrder = 'XYZ';
    THREE.Euler.prototype = {
      constructor: THREE.Euler,
      _x: 0,
      _y: 0,
      _z: 0,
      _order: THREE.Euler.DefaultOrder,
      get x() {
        return this._x;
      },
      set x(value) {
        this._x = value;
        this.onChangeCallback();
      },
      get y() {
        return this._y;
      },
      set y(value) {
        this._y = value;
        this.onChangeCallback();
      },
      get z() {
        return this._z;
      },
      set z(value) {
        this._z = value;
        this.onChangeCallback();
      },
      get order() {
        return this._order;
      },
      set order(value) {
        this._order = value;
        this.onChangeCallback();
      },
      set: function(x, y, z, order) {
        this._x = x;
        this._y = y;
        this._z = z;
        this._order = order || this._order;
        this.onChangeCallback();
        return this;
      },
      copy: function(euler) {
        this._x = euler._x;
        this._y = euler._y;
        this._z = euler._z;
        this._order = euler._order;
        this.onChangeCallback();
        return this;
      },
      setFromRotationMatrix: function(m, order, update) {
        var clamp = THREE.Math.clamp;
        var te = m.elements;
        var m11 = te[0],
            m12 = te[4],
            m13 = te[8];
        var m21 = te[1],
            m22 = te[5],
            m23 = te[9];
        var m31 = te[2],
            m32 = te[6],
            m33 = te[10];
        order = order || this._order;
        if (order === 'XYZ') {
          this._y = Math.asin(clamp(m13, -1, 1));
          if (Math.abs(m13) < 0.99999) {
            this._x = Math.atan2(-m23, m33);
            this._z = Math.atan2(-m12, m11);
          } else {
            this._x = Math.atan2(m32, m22);
            this._z = 0;
          }
        } else if (order === 'YXZ') {
          this._x = Math.asin(-clamp(m23, -1, 1));
          if (Math.abs(m23) < 0.99999) {
            this._y = Math.atan2(m13, m33);
            this._z = Math.atan2(m21, m22);
          } else {
            this._y = Math.atan2(-m31, m11);
            this._z = 0;
          }
        } else if (order === 'ZXY') {
          this._x = Math.asin(clamp(m32, -1, 1));
          if (Math.abs(m32) < 0.99999) {
            this._y = Math.atan2(-m31, m33);
            this._z = Math.atan2(-m12, m22);
          } else {
            this._y = 0;
            this._z = Math.atan2(m21, m11);
          }
        } else if (order === 'ZYX') {
          this._y = Math.asin(-clamp(m31, -1, 1));
          if (Math.abs(m31) < 0.99999) {
            this._x = Math.atan2(m32, m33);
            this._z = Math.atan2(m21, m11);
          } else {
            this._x = 0;
            this._z = Math.atan2(-m12, m22);
          }
        } else if (order === 'YZX') {
          this._z = Math.asin(clamp(m21, -1, 1));
          if (Math.abs(m21) < 0.99999) {
            this._x = Math.atan2(-m23, m22);
            this._y = Math.atan2(-m31, m11);
          } else {
            this._x = 0;
            this._y = Math.atan2(m13, m33);
          }
        } else if (order === 'XZY') {
          this._z = Math.asin(-clamp(m12, -1, 1));
          if (Math.abs(m12) < 0.99999) {
            this._x = Math.atan2(m32, m22);
            this._y = Math.atan2(m13, m11);
          } else {
            this._x = Math.atan2(-m23, m33);
            this._y = 0;
          }
        } else {
          THREE.warn('THREE.Euler: .setFromRotationMatrix() given unsupported order: ' + order);
        }
        this._order = order;
        if (update !== false)
          this.onChangeCallback();
        return this;
      },
      setFromQuaternion: function() {
        var matrix;
        return function(q, order, update) {
          if (matrix === undefined)
            matrix = new THREE.Matrix4();
          matrix.makeRotationFromQuaternion(q);
          this.setFromRotationMatrix(matrix, order, update);
          return this;
        };
      }(),
      setFromVector3: function(v, order) {
        return this.set(v.x, v.y, v.z, order || this._order);
      },
      reorder: function() {
        var q = new THREE.Quaternion();
        return function(newOrder) {
          q.setFromEuler(this);
          this.setFromQuaternion(q, newOrder);
        };
      }(),
      equals: function(euler) {
        return (euler._x === this._x) && (euler._y === this._y) && (euler._z === this._z) && (euler._order === this._order);
      },
      fromArray: function(array) {
        this._x = array[0];
        this._y = array[1];
        this._z = array[2];
        if (array[3] !== undefined)
          this._order = array[3];
        this.onChangeCallback();
        return this;
      },
      toArray: function(array, offset) {
        if (array === undefined)
          array = [];
        if (offset === undefined)
          offset = 0;
        array[offset] = this._x;
        array[offset + 1] = this._y;
        array[offset + 2] = this._z;
        array[offset + 3] = this._order;
        return array;
      },
      toVector3: function(optionalResult) {
        if (optionalResult) {
          return optionalResult.set(this._x, this._y, this._z);
        } else {
          return new THREE.Vector3(this._x, this._y, this._z);
        }
      },
      onChange: function(callback) {
        this.onChangeCallback = callback;
        return this;
      },
      onChangeCallback: function() {},
      clone: function() {
        return new THREE.Euler(this._x, this._y, this._z, this._order);
      }
    };
    THREE.Line3 = function(start, end) {
      this.start = (start !== undefined) ? start : new THREE.Vector3();
      this.end = (end !== undefined) ? end : new THREE.Vector3();
    };
    THREE.Line3.prototype = {
      constructor: THREE.Line3,
      set: function(start, end) {
        this.start.copy(start);
        this.end.copy(end);
        return this;
      },
      copy: function(line) {
        this.start.copy(line.start);
        this.end.copy(line.end);
        return this;
      },
      center: function(optionalTarget) {
        var result = optionalTarget || new THREE.Vector3();
        return result.addVectors(this.start, this.end).multiplyScalar(0.5);
      },
      delta: function(optionalTarget) {
        var result = optionalTarget || new THREE.Vector3();
        return result.subVectors(this.end, this.start);
      },
      distanceSq: function() {
        return this.start.distanceToSquared(this.end);
      },
      distance: function() {
        return this.start.distanceTo(this.end);
      },
      at: function(t, optionalTarget) {
        var result = optionalTarget || new THREE.Vector3();
        return this.delta(result).multiplyScalar(t).add(this.start);
      },
      closestPointToPointParameter: function() {
        var startP = new THREE.Vector3();
        var startEnd = new THREE.Vector3();
        return function(point, clampToLine) {
          startP.subVectors(point, this.start);
          startEnd.subVectors(this.end, this.start);
          var startEnd2 = startEnd.dot(startEnd);
          var startEnd_startP = startEnd.dot(startP);
          var t = startEnd_startP / startEnd2;
          if (clampToLine) {
            t = THREE.Math.clamp(t, 0, 1);
          }
          return t;
        };
      }(),
      closestPointToPoint: function(point, clampToLine, optionalTarget) {
        var t = this.closestPointToPointParameter(point, clampToLine);
        var result = optionalTarget || new THREE.Vector3();
        return this.delta(result).multiplyScalar(t).add(this.start);
      },
      applyMatrix4: function(matrix) {
        this.start.applyMatrix4(matrix);
        this.end.applyMatrix4(matrix);
        return this;
      },
      equals: function(line) {
        return line.start.equals(this.start) && line.end.equals(this.end);
      },
      clone: function() {
        return new THREE.Line3().copy(this);
      }
    };
    THREE.Box2 = function(min, max) {
      this.min = (min !== undefined) ? min : new THREE.Vector2(Infinity, Infinity);
      this.max = (max !== undefined) ? max : new THREE.Vector2(-Infinity, -Infinity);
    };
    THREE.Box2.prototype = {
      constructor: THREE.Box2,
      set: function(min, max) {
        this.min.copy(min);
        this.max.copy(max);
        return this;
      },
      setFromPoints: function(points) {
        this.makeEmpty();
        for (var i = 0,
            il = points.length; i < il; i++) {
          this.expandByPoint(points[i]);
        }
        return this;
      },
      setFromCenterAndSize: function() {
        var v1 = new THREE.Vector2();
        return function(center, size) {
          var halfSize = v1.copy(size).multiplyScalar(0.5);
          this.min.copy(center).sub(halfSize);
          this.max.copy(center).add(halfSize);
          return this;
        };
      }(),
      copy: function(box) {
        this.min.copy(box.min);
        this.max.copy(box.max);
        return this;
      },
      makeEmpty: function() {
        this.min.x = this.min.y = Infinity;
        this.max.x = this.max.y = -Infinity;
        return this;
      },
      empty: function() {
        return (this.max.x < this.min.x) || (this.max.y < this.min.y);
      },
      center: function(optionalTarget) {
        var result = optionalTarget || new THREE.Vector2();
        return result.addVectors(this.min, this.max).multiplyScalar(0.5);
      },
      size: function(optionalTarget) {
        var result = optionalTarget || new THREE.Vector2();
        return result.subVectors(this.max, this.min);
      },
      expandByPoint: function(point) {
        this.min.min(point);
        this.max.max(point);
        return this;
      },
      expandByVector: function(vector) {
        this.min.sub(vector);
        this.max.add(vector);
        return this;
      },
      expandByScalar: function(scalar) {
        this.min.addScalar(-scalar);
        this.max.addScalar(scalar);
        return this;
      },
      containsPoint: function(point) {
        if (point.x < this.min.x || point.x > this.max.x || point.y < this.min.y || point.y > this.max.y) {
          return false;
        }
        return true;
      },
      containsBox: function(box) {
        if ((this.min.x <= box.min.x) && (box.max.x <= this.max.x) && (this.min.y <= box.min.y) && (box.max.y <= this.max.y)) {
          return true;
        }
        return false;
      },
      getParameter: function(point, optionalTarget) {
        var result = optionalTarget || new THREE.Vector2();
        return result.set((point.x - this.min.x) / (this.max.x - this.min.x), (point.y - this.min.y) / (this.max.y - this.min.y));
      },
      isIntersectionBox: function(box) {
        if (box.max.x < this.min.x || box.min.x > this.max.x || box.max.y < this.min.y || box.min.y > this.max.y) {
          return false;
        }
        return true;
      },
      clampPoint: function(point, optionalTarget) {
        var result = optionalTarget || new THREE.Vector2();
        return result.copy(point).clamp(this.min, this.max);
      },
      distanceToPoint: function() {
        var v1 = new THREE.Vector2();
        return function(point) {
          var clampedPoint = v1.copy(point).clamp(this.min, this.max);
          return clampedPoint.sub(point).length();
        };
      }(),
      intersect: function(box) {
        this.min.max(box.min);
        this.max.min(box.max);
        return this;
      },
      union: function(box) {
        this.min.min(box.min);
        this.max.max(box.max);
        return this;
      },
      translate: function(offset) {
        this.min.add(offset);
        this.max.add(offset);
        return this;
      },
      equals: function(box) {
        return box.min.equals(this.min) && box.max.equals(this.max);
      },
      clone: function() {
        return new THREE.Box2().copy(this);
      }
    };
    THREE.Box3 = function(min, max) {
      this.min = (min !== undefined) ? min : new THREE.Vector3(Infinity, Infinity, Infinity);
      this.max = (max !== undefined) ? max : new THREE.Vector3(-Infinity, -Infinity, -Infinity);
    };
    THREE.Box3.prototype = {
      constructor: THREE.Box3,
      set: function(min, max) {
        this.min.copy(min);
        this.max.copy(max);
        return this;
      },
      setFromPoints: function(points) {
        this.makeEmpty();
        for (var i = 0,
            il = points.length; i < il; i++) {
          this.expandByPoint(points[i]);
        }
        return this;
      },
      setFromCenterAndSize: function() {
        var v1 = new THREE.Vector3();
        return function(center, size) {
          var halfSize = v1.copy(size).multiplyScalar(0.5);
          this.min.copy(center).sub(halfSize);
          this.max.copy(center).add(halfSize);
          return this;
        };
      }(),
      setFromObject: function() {
        var v1 = new THREE.Vector3();
        return function(object) {
          var scope = this;
          object.updateMatrixWorld(true);
          this.makeEmpty();
          object.traverse(function(node) {
            var geometry = node.geometry;
            if (geometry !== undefined) {
              if (geometry instanceof THREE.Geometry) {
                var vertices = geometry.vertices;
                for (var i = 0,
                    il = vertices.length; i < il; i++) {
                  v1.copy(vertices[i]);
                  v1.applyMatrix4(node.matrixWorld);
                  scope.expandByPoint(v1);
                }
              } else if (geometry instanceof THREE.BufferGeometry && geometry.attributes['position'] !== undefined) {
                var positions = geometry.attributes['position'].array;
                for (var i = 0,
                    il = positions.length; i < il; i += 3) {
                  v1.set(positions[i], positions[i + 1], positions[i + 2]);
                  v1.applyMatrix4(node.matrixWorld);
                  scope.expandByPoint(v1);
                }
              }
            }
          });
          return this;
        };
      }(),
      copy: function(box) {
        this.min.copy(box.min);
        this.max.copy(box.max);
        return this;
      },
      makeEmpty: function() {
        this.min.x = this.min.y = this.min.z = Infinity;
        this.max.x = this.max.y = this.max.z = -Infinity;
        return this;
      },
      empty: function() {
        return (this.max.x < this.min.x) || (this.max.y < this.min.y) || (this.max.z < this.min.z);
      },
      center: function(optionalTarget) {
        var result = optionalTarget || new THREE.Vector3();
        return result.addVectors(this.min, this.max).multiplyScalar(0.5);
      },
      size: function(optionalTarget) {
        var result = optionalTarget || new THREE.Vector3();
        return result.subVectors(this.max, this.min);
      },
      expandByPoint: function(point) {
        this.min.min(point);
        this.max.max(point);
        return this;
      },
      expandByVector: function(vector) {
        this.min.sub(vector);
        this.max.add(vector);
        return this;
      },
      expandByScalar: function(scalar) {
        this.min.addScalar(-scalar);
        this.max.addScalar(scalar);
        return this;
      },
      containsPoint: function(point) {
        if (point.x < this.min.x || point.x > this.max.x || point.y < this.min.y || point.y > this.max.y || point.z < this.min.z || point.z > this.max.z) {
          return false;
        }
        return true;
      },
      containsBox: function(box) {
        if ((this.min.x <= box.min.x) && (box.max.x <= this.max.x) && (this.min.y <= box.min.y) && (box.max.y <= this.max.y) && (this.min.z <= box.min.z) && (box.max.z <= this.max.z)) {
          return true;
        }
        return false;
      },
      getParameter: function(point, optionalTarget) {
        var result = optionalTarget || new THREE.Vector3();
        return result.set((point.x - this.min.x) / (this.max.x - this.min.x), (point.y - this.min.y) / (this.max.y - this.min.y), (point.z - this.min.z) / (this.max.z - this.min.z));
      },
      isIntersectionBox: function(box) {
        if (box.max.x < this.min.x || box.min.x > this.max.x || box.max.y < this.min.y || box.min.y > this.max.y || box.max.z < this.min.z || box.min.z > this.max.z) {
          return false;
        }
        return true;
      },
      clampPoint: function(point, optionalTarget) {
        var result = optionalTarget || new THREE.Vector3();
        return result.copy(point).clamp(this.min, this.max);
      },
      distanceToPoint: function() {
        var v1 = new THREE.Vector3();
        return function(point) {
          var clampedPoint = v1.copy(point).clamp(this.min, this.max);
          return clampedPoint.sub(point).length();
        };
      }(),
      getBoundingSphere: function() {
        var v1 = new THREE.Vector3();
        return function(optionalTarget) {
          var result = optionalTarget || new THREE.Sphere();
          result.center = this.center();
          result.radius = this.size(v1).length() * 0.5;
          return result;
        };
      }(),
      intersect: function(box) {
        this.min.max(box.min);
        this.max.min(box.max);
        return this;
      },
      union: function(box) {
        this.min.min(box.min);
        this.max.max(box.max);
        return this;
      },
      applyMatrix4: function() {
        var points = [new THREE.Vector3(), new THREE.Vector3(), new THREE.Vector3(), new THREE.Vector3(), new THREE.Vector3(), new THREE.Vector3(), new THREE.Vector3(), new THREE.Vector3()];
        return function(matrix) {
          points[0].set(this.min.x, this.min.y, this.min.z).applyMatrix4(matrix);
          points[1].set(this.min.x, this.min.y, this.max.z).applyMatrix4(matrix);
          points[2].set(this.min.x, this.max.y, this.min.z).applyMatrix4(matrix);
          points[3].set(this.min.x, this.max.y, this.max.z).applyMatrix4(matrix);
          points[4].set(this.max.x, this.min.y, this.min.z).applyMatrix4(matrix);
          points[5].set(this.max.x, this.min.y, this.max.z).applyMatrix4(matrix);
          points[6].set(this.max.x, this.max.y, this.min.z).applyMatrix4(matrix);
          points[7].set(this.max.x, this.max.y, this.max.z).applyMatrix4(matrix);
          this.makeEmpty();
          this.setFromPoints(points);
          return this;
        };
      }(),
      translate: function(offset) {
        this.min.add(offset);
        this.max.add(offset);
        return this;
      },
      equals: function(box) {
        return box.min.equals(this.min) && box.max.equals(this.max);
      },
      clone: function() {
        return new THREE.Box3().copy(this);
      }
    };
    THREE.Matrix3 = function() {
      this.elements = new Float32Array([1, 0, 0, 0, 1, 0, 0, 0, 1]);
      if (arguments.length > 0) {
        THREE.error('THREE.Matrix3: the constructor no longer reads arguments. use .set() instead.');
      }
    };
    THREE.Matrix3.prototype = {
      constructor: THREE.Matrix3,
      set: function(n11, n12, n13, n21, n22, n23, n31, n32, n33) {
        var te = this.elements;
        te[0] = n11;
        te[3] = n12;
        te[6] = n13;
        te[1] = n21;
        te[4] = n22;
        te[7] = n23;
        te[2] = n31;
        te[5] = n32;
        te[8] = n33;
        return this;
      },
      identity: function() {
        this.set(1, 0, 0, 0, 1, 0, 0, 0, 1);
        return this;
      },
      copy: function(m) {
        var me = m.elements;
        this.set(me[0], me[3], me[6], me[1], me[4], me[7], me[2], me[5], me[8]);
        return this;
      },
      multiplyVector3: function(vector) {
        THREE.warn('THREE.Matrix3: .multiplyVector3() has been removed. Use vector.applyMatrix3( matrix ) instead.');
        return vector.applyMatrix3(this);
      },
      multiplyVector3Array: function(a) {
        THREE.warn('THREE.Matrix3: .multiplyVector3Array() has been renamed. Use matrix.applyToVector3Array( array ) instead.');
        return this.applyToVector3Array(a);
      },
      applyToVector3Array: function() {
        var v1 = new THREE.Vector3();
        return function(array, offset, length) {
          if (offset === undefined)
            offset = 0;
          if (length === undefined)
            length = array.length;
          for (var i = 0,
              j = offset; i < length; i += 3, j += 3) {
            v1.x = array[j];
            v1.y = array[j + 1];
            v1.z = array[j + 2];
            v1.applyMatrix3(this);
            array[j] = v1.x;
            array[j + 1] = v1.y;
            array[j + 2] = v1.z;
          }
          return array;
        };
      }(),
      multiplyScalar: function(s) {
        var te = this.elements;
        te[0] *= s;
        te[3] *= s;
        te[6] *= s;
        te[1] *= s;
        te[4] *= s;
        te[7] *= s;
        te[2] *= s;
        te[5] *= s;
        te[8] *= s;
        return this;
      },
      determinant: function() {
        var te = this.elements;
        var a = te[0],
            b = te[1],
            c = te[2],
            d = te[3],
            e = te[4],
            f = te[5],
            g = te[6],
            h = te[7],
            i = te[8];
        return a * e * i - a * f * h - b * d * i + b * f * g + c * d * h - c * e * g;
      },
      getInverse: function(matrix, throwOnInvertible) {
        var me = matrix.elements;
        var te = this.elements;
        te[0] = me[10] * me[5] - me[6] * me[9];
        te[1] = -me[10] * me[1] + me[2] * me[9];
        te[2] = me[6] * me[1] - me[2] * me[5];
        te[3] = -me[10] * me[4] + me[6] * me[8];
        te[4] = me[10] * me[0] - me[2] * me[8];
        te[5] = -me[6] * me[0] + me[2] * me[4];
        te[6] = me[9] * me[4] - me[5] * me[8];
        te[7] = -me[9] * me[0] + me[1] * me[8];
        te[8] = me[5] * me[0] - me[1] * me[4];
        var det = me[0] * te[0] + me[1] * te[3] + me[2] * te[6];
        if (det === 0) {
          var msg = "Matrix3.getInverse(): can't invert matrix, determinant is 0";
          if (throwOnInvertible || false) {
            throw new Error(msg);
          } else {
            THREE.warn(msg);
          }
          this.identity();
          return this;
        }
        this.multiplyScalar(1.0 / det);
        return this;
      },
      transpose: function() {
        var tmp,
            m = this.elements;
        tmp = m[1];
        m[1] = m[3];
        m[3] = tmp;
        tmp = m[2];
        m[2] = m[6];
        m[6] = tmp;
        tmp = m[5];
        m[5] = m[7];
        m[7] = tmp;
        return this;
      },
      flattenToArrayOffset: function(array, offset) {
        var te = this.elements;
        array[offset] = te[0];
        array[offset + 1] = te[1];
        array[offset + 2] = te[2];
        array[offset + 3] = te[3];
        array[offset + 4] = te[4];
        array[offset + 5] = te[5];
        array[offset + 6] = te[6];
        array[offset + 7] = te[7];
        array[offset + 8] = te[8];
        return array;
      },
      getNormalMatrix: function(m) {
        this.getInverse(m).transpose();
        return this;
      },
      transposeIntoArray: function(r) {
        var m = this.elements;
        r[0] = m[0];
        r[1] = m[3];
        r[2] = m[6];
        r[3] = m[1];
        r[4] = m[4];
        r[5] = m[7];
        r[6] = m[2];
        r[7] = m[5];
        r[8] = m[8];
        return this;
      },
      fromArray: function(array) {
        this.elements.set(array);
        return this;
      },
      toArray: function() {
        var te = this.elements;
        return [te[0], te[1], te[2], te[3], te[4], te[5], te[6], te[7], te[8]];
      },
      clone: function() {
        return new THREE.Matrix3().fromArray(this.elements);
      }
    };
    THREE.Matrix4 = function() {
      this.elements = new Float32Array([1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1]);
      if (arguments.length > 0) {
        THREE.error('THREE.Matrix4: the constructor no longer reads arguments. use .set() instead.');
      }
    };
    THREE.Matrix4.prototype = {
      constructor: THREE.Matrix4,
      set: function(n11, n12, n13, n14, n21, n22, n23, n24, n31, n32, n33, n34, n41, n42, n43, n44) {
        var te = this.elements;
        te[0] = n11;
        te[4] = n12;
        te[8] = n13;
        te[12] = n14;
        te[1] = n21;
        te[5] = n22;
        te[9] = n23;
        te[13] = n24;
        te[2] = n31;
        te[6] = n32;
        te[10] = n33;
        te[14] = n34;
        te[3] = n41;
        te[7] = n42;
        te[11] = n43;
        te[15] = n44;
        return this;
      },
      identity: function() {
        this.set(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1);
        return this;
      },
      copy: function(m) {
        this.elements.set(m.elements);
        return this;
      },
      extractPosition: function(m) {
        THREE.warn('THREE.Matrix4: .extractPosition() has been renamed to .copyPosition().');
        return this.copyPosition(m);
      },
      copyPosition: function(m) {
        var te = this.elements;
        var me = m.elements;
        te[12] = me[12];
        te[13] = me[13];
        te[14] = me[14];
        return this;
      },
      extractBasis: function(xAxis, yAxis, zAxis) {
        var te = this.elements;
        xAxis.set(te[0], te[1], te[2]);
        yAxis.set(te[4], te[5], te[6]);
        zAxis.set(te[8], te[9], te[10]);
        return this;
      },
      makeBasis: function(xAxis, yAxis, zAxis) {
        this.set(xAxis.x, yAxis.x, zAxis.x, 0, xAxis.y, yAxis.y, zAxis.y, 0, xAxis.z, yAxis.z, zAxis.z, 0, 0, 0, 0, 1);
        return this;
      },
      extractRotation: function() {
        var v1 = new THREE.Vector3();
        return function(m) {
          var te = this.elements;
          var me = m.elements;
          var scaleX = 1 / v1.set(me[0], me[1], me[2]).length();
          var scaleY = 1 / v1.set(me[4], me[5], me[6]).length();
          var scaleZ = 1 / v1.set(me[8], me[9], me[10]).length();
          te[0] = me[0] * scaleX;
          te[1] = me[1] * scaleX;
          te[2] = me[2] * scaleX;
          te[4] = me[4] * scaleY;
          te[5] = me[5] * scaleY;
          te[6] = me[6] * scaleY;
          te[8] = me[8] * scaleZ;
          te[9] = me[9] * scaleZ;
          te[10] = me[10] * scaleZ;
          return this;
        };
      }(),
      makeRotationFromEuler: function(euler) {
        if (euler instanceof THREE.Euler === false) {
          THREE.error('THREE.Matrix: .makeRotationFromEuler() now expects a Euler rotation rather than a Vector3 and order.');
        }
        var te = this.elements;
        var x = euler.x,
            y = euler.y,
            z = euler.z;
        var a = Math.cos(x),
            b = Math.sin(x);
        var c = Math.cos(y),
            d = Math.sin(y);
        var e = Math.cos(z),
            f = Math.sin(z);
        if (euler.order === 'XYZ') {
          var ae = a * e,
              af = a * f,
              be = b * e,
              bf = b * f;
          te[0] = c * e;
          te[4] = -c * f;
          te[8] = d;
          te[1] = af + be * d;
          te[5] = ae - bf * d;
          te[9] = -b * c;
          te[2] = bf - ae * d;
          te[6] = be + af * d;
          te[10] = a * c;
        } else if (euler.order === 'YXZ') {
          var ce = c * e,
              cf = c * f,
              de = d * e,
              df = d * f;
          te[0] = ce + df * b;
          te[4] = de * b - cf;
          te[8] = a * d;
          te[1] = a * f;
          te[5] = a * e;
          te[9] = -b;
          te[2] = cf * b - de;
          te[6] = df + ce * b;
          te[10] = a * c;
        } else if (euler.order === 'ZXY') {
          var ce = c * e,
              cf = c * f,
              de = d * e,
              df = d * f;
          te[0] = ce - df * b;
          te[4] = -a * f;
          te[8] = de + cf * b;
          te[1] = cf + de * b;
          te[5] = a * e;
          te[9] = df - ce * b;
          te[2] = -a * d;
          te[6] = b;
          te[10] = a * c;
        } else if (euler.order === 'ZYX') {
          var ae = a * e,
              af = a * f,
              be = b * e,
              bf = b * f;
          te[0] = c * e;
          te[4] = be * d - af;
          te[8] = ae * d + bf;
          te[1] = c * f;
          te[5] = bf * d + ae;
          te[9] = af * d - be;
          te[2] = -d;
          te[6] = b * c;
          te[10] = a * c;
        } else if (euler.order === 'YZX') {
          var ac = a * c,
              ad = a * d,
              bc = b * c,
              bd = b * d;
          te[0] = c * e;
          te[4] = bd - ac * f;
          te[8] = bc * f + ad;
          te[1] = f;
          te[5] = a * e;
          te[9] = -b * e;
          te[2] = -d * e;
          te[6] = ad * f + bc;
          te[10] = ac - bd * f;
        } else if (euler.order === 'XZY') {
          var ac = a * c,
              ad = a * d,
              bc = b * c,
              bd = b * d;
          te[0] = c * e;
          te[4] = -f;
          te[8] = d * e;
          te[1] = ac * f + bd;
          te[5] = a * e;
          te[9] = ad * f - bc;
          te[2] = bc * f - ad;
          te[6] = b * e;
          te[10] = bd * f + ac;
        }
        te[3] = 0;
        te[7] = 0;
        te[11] = 0;
        te[12] = 0;
        te[13] = 0;
        te[14] = 0;
        te[15] = 1;
        return this;
      },
      setRotationFromQuaternion: function(q) {
        THREE.warn('THREE.Matrix4: .setRotationFromQuaternion() has been renamed to .makeRotationFromQuaternion().');
        return this.makeRotationFromQuaternion(q);
      },
      makeRotationFromQuaternion: function(q) {
        var te = this.elements;
        var x = q.x,
            y = q.y,
            z = q.z,
            w = q.w;
        var x2 = x + x,
            y2 = y + y,
            z2 = z + z;
        var xx = x * x2,
            xy = x * y2,
            xz = x * z2;
        var yy = y * y2,
            yz = y * z2,
            zz = z * z2;
        var wx = w * x2,
            wy = w * y2,
            wz = w * z2;
        te[0] = 1 - (yy + zz);
        te[4] = xy - wz;
        te[8] = xz + wy;
        te[1] = xy + wz;
        te[5] = 1 - (xx + zz);
        te[9] = yz - wx;
        te[2] = xz - wy;
        te[6] = yz + wx;
        te[10] = 1 - (xx + yy);
        te[3] = 0;
        te[7] = 0;
        te[11] = 0;
        te[12] = 0;
        te[13] = 0;
        te[14] = 0;
        te[15] = 1;
        return this;
      },
      lookAt: function() {
        var x = new THREE.Vector3();
        var y = new THREE.Vector3();
        var z = new THREE.Vector3();
        return function(eye, target, up) {
          var te = this.elements;
          z.subVectors(eye, target).normalize();
          if (z.length() === 0) {
            z.z = 1;
          }
          x.crossVectors(up, z).normalize();
          if (x.length() === 0) {
            z.x += 0.0001;
            x.crossVectors(up, z).normalize();
          }
          y.crossVectors(z, x);
          te[0] = x.x;
          te[4] = y.x;
          te[8] = z.x;
          te[1] = x.y;
          te[5] = y.y;
          te[9] = z.y;
          te[2] = x.z;
          te[6] = y.z;
          te[10] = z.z;
          return this;
        };
      }(),
      multiply: function(m, n) {
        if (n !== undefined) {
          THREE.warn('THREE.Matrix4: .multiply() now only accepts one argument. Use .multiplyMatrices( a, b ) instead.');
          return this.multiplyMatrices(m, n);
        }
        return this.multiplyMatrices(this, m);
      },
      multiplyMatrices: function(a, b) {
        var ae = a.elements;
        var be = b.elements;
        var te = this.elements;
        var a11 = ae[0],
            a12 = ae[4],
            a13 = ae[8],
            a14 = ae[12];
        var a21 = ae[1],
            a22 = ae[5],
            a23 = ae[9],
            a24 = ae[13];
        var a31 = ae[2],
            a32 = ae[6],
            a33 = ae[10],
            a34 = ae[14];
        var a41 = ae[3],
            a42 = ae[7],
            a43 = ae[11],
            a44 = ae[15];
        var b11 = be[0],
            b12 = be[4],
            b13 = be[8],
            b14 = be[12];
        var b21 = be[1],
            b22 = be[5],
            b23 = be[9],
            b24 = be[13];
        var b31 = be[2],
            b32 = be[6],
            b33 = be[10],
            b34 = be[14];
        var b41 = be[3],
            b42 = be[7],
            b43 = be[11],
            b44 = be[15];
        te[0] = a11 * b11 + a12 * b21 + a13 * b31 + a14 * b41;
        te[4] = a11 * b12 + a12 * b22 + a13 * b32 + a14 * b42;
        te[8] = a11 * b13 + a12 * b23 + a13 * b33 + a14 * b43;
        te[12] = a11 * b14 + a12 * b24 + a13 * b34 + a14 * b44;
        te[1] = a21 * b11 + a22 * b21 + a23 * b31 + a24 * b41;
        te[5] = a21 * b12 + a22 * b22 + a23 * b32 + a24 * b42;
        te[9] = a21 * b13 + a22 * b23 + a23 * b33 + a24 * b43;
        te[13] = a21 * b14 + a22 * b24 + a23 * b34 + a24 * b44;
        te[2] = a31 * b11 + a32 * b21 + a33 * b31 + a34 * b41;
        te[6] = a31 * b12 + a32 * b22 + a33 * b32 + a34 * b42;
        te[10] = a31 * b13 + a32 * b23 + a33 * b33 + a34 * b43;
        te[14] = a31 * b14 + a32 * b24 + a33 * b34 + a34 * b44;
        te[3] = a41 * b11 + a42 * b21 + a43 * b31 + a44 * b41;
        te[7] = a41 * b12 + a42 * b22 + a43 * b32 + a44 * b42;
        te[11] = a41 * b13 + a42 * b23 + a43 * b33 + a44 * b43;
        te[15] = a41 * b14 + a42 * b24 + a43 * b34 + a44 * b44;
        return this;
      },
      multiplyToArray: function(a, b, r) {
        var te = this.elements;
        this.multiplyMatrices(a, b);
        r[0] = te[0];
        r[1] = te[1];
        r[2] = te[2];
        r[3] = te[3];
        r[4] = te[4];
        r[5] = te[5];
        r[6] = te[6];
        r[7] = te[7];
        r[8] = te[8];
        r[9] = te[9];
        r[10] = te[10];
        r[11] = te[11];
        r[12] = te[12];
        r[13] = te[13];
        r[14] = te[14];
        r[15] = te[15];
        return this;
      },
      multiplyScalar: function(s) {
        var te = this.elements;
        te[0] *= s;
        te[4] *= s;
        te[8] *= s;
        te[12] *= s;
        te[1] *= s;
        te[5] *= s;
        te[9] *= s;
        te[13] *= s;
        te[2] *= s;
        te[6] *= s;
        te[10] *= s;
        te[14] *= s;
        te[3] *= s;
        te[7] *= s;
        te[11] *= s;
        te[15] *= s;
        return this;
      },
      multiplyVector3: function(vector) {
        THREE.warn('THREE.Matrix4: .multiplyVector3() has been removed. Use vector.applyMatrix4( matrix ) or vector.applyProjection( matrix ) instead.');
        return vector.applyProjection(this);
      },
      multiplyVector4: function(vector) {
        THREE.warn('THREE.Matrix4: .multiplyVector4() has been removed. Use vector.applyMatrix4( matrix ) instead.');
        return vector.applyMatrix4(this);
      },
      multiplyVector3Array: function(a) {
        THREE.warn('THREE.Matrix4: .multiplyVector3Array() has been renamed. Use matrix.applyToVector3Array( array ) instead.');
        return this.applyToVector3Array(a);
      },
      applyToVector3Array: function() {
        var v1 = new THREE.Vector3();
        return function(array, offset, length) {
          if (offset === undefined)
            offset = 0;
          if (length === undefined)
            length = array.length;
          for (var i = 0,
              j = offset; i < length; i += 3, j += 3) {
            v1.x = array[j];
            v1.y = array[j + 1];
            v1.z = array[j + 2];
            v1.applyMatrix4(this);
            array[j] = v1.x;
            array[j + 1] = v1.y;
            array[j + 2] = v1.z;
          }
          return array;
        };
      }(),
      rotateAxis: function(v) {
        THREE.warn('THREE.Matrix4: .rotateAxis() has been removed. Use Vector3.transformDirection( matrix ) instead.');
        v.transformDirection(this);
      },
      crossVector: function(vector) {
        THREE.warn('THREE.Matrix4: .crossVector() has been removed. Use vector.applyMatrix4( matrix ) instead.');
        return vector.applyMatrix4(this);
      },
      determinant: function() {
        var te = this.elements;
        var n11 = te[0],
            n12 = te[4],
            n13 = te[8],
            n14 = te[12];
        var n21 = te[1],
            n22 = te[5],
            n23 = te[9],
            n24 = te[13];
        var n31 = te[2],
            n32 = te[6],
            n33 = te[10],
            n34 = te[14];
        var n41 = te[3],
            n42 = te[7],
            n43 = te[11],
            n44 = te[15];
        return (n41 * (+n14 * n23 * n32 - n13 * n24 * n32 - n14 * n22 * n33 + n12 * n24 * n33 + n13 * n22 * n34 - n12 * n23 * n34) + n42 * (+n11 * n23 * n34 - n11 * n24 * n33 + n14 * n21 * n33 - n13 * n21 * n34 + n13 * n24 * n31 - n14 * n23 * n31) + n43 * (+n11 * n24 * n32 - n11 * n22 * n34 - n14 * n21 * n32 + n12 * n21 * n34 + n14 * n22 * n31 - n12 * n24 * n31) + n44 * (-n13 * n22 * n31 - n11 * n23 * n32 + n11 * n22 * n33 + n13 * n21 * n32 - n12 * n21 * n33 + n12 * n23 * n31));
      },
      transpose: function() {
        var te = this.elements;
        var tmp;
        tmp = te[1];
        te[1] = te[4];
        te[4] = tmp;
        tmp = te[2];
        te[2] = te[8];
        te[8] = tmp;
        tmp = te[6];
        te[6] = te[9];
        te[9] = tmp;
        tmp = te[3];
        te[3] = te[12];
        te[12] = tmp;
        tmp = te[7];
        te[7] = te[13];
        te[13] = tmp;
        tmp = te[11];
        te[11] = te[14];
        te[14] = tmp;
        return this;
      },
      flattenToArrayOffset: function(array, offset) {
        var te = this.elements;
        array[offset] = te[0];
        array[offset + 1] = te[1];
        array[offset + 2] = te[2];
        array[offset + 3] = te[3];
        array[offset + 4] = te[4];
        array[offset + 5] = te[5];
        array[offset + 6] = te[6];
        array[offset + 7] = te[7];
        array[offset + 8] = te[8];
        array[offset + 9] = te[9];
        array[offset + 10] = te[10];
        array[offset + 11] = te[11];
        array[offset + 12] = te[12];
        array[offset + 13] = te[13];
        array[offset + 14] = te[14];
        array[offset + 15] = te[15];
        return array;
      },
      getPosition: function() {
        var v1 = new THREE.Vector3();
        return function() {
          THREE.warn('THREE.Matrix4: .getPosition() has been removed. Use Vector3.setFromMatrixPosition( matrix ) instead.');
          var te = this.elements;
          return v1.set(te[12], te[13], te[14]);
        };
      }(),
      setPosition: function(v) {
        var te = this.elements;
        te[12] = v.x;
        te[13] = v.y;
        te[14] = v.z;
        return this;
      },
      getInverse: function(m, throwOnInvertible) {
        var te = this.elements;
        var me = m.elements;
        var n11 = me[0],
            n12 = me[4],
            n13 = me[8],
            n14 = me[12];
        var n21 = me[1],
            n22 = me[5],
            n23 = me[9],
            n24 = me[13];
        var n31 = me[2],
            n32 = me[6],
            n33 = me[10],
            n34 = me[14];
        var n41 = me[3],
            n42 = me[7],
            n43 = me[11],
            n44 = me[15];
        te[0] = n23 * n34 * n42 - n24 * n33 * n42 + n24 * n32 * n43 - n22 * n34 * n43 - n23 * n32 * n44 + n22 * n33 * n44;
        te[4] = n14 * n33 * n42 - n13 * n34 * n42 - n14 * n32 * n43 + n12 * n34 * n43 + n13 * n32 * n44 - n12 * n33 * n44;
        te[8] = n13 * n24 * n42 - n14 * n23 * n42 + n14 * n22 * n43 - n12 * n24 * n43 - n13 * n22 * n44 + n12 * n23 * n44;
        te[12] = n14 * n23 * n32 - n13 * n24 * n32 - n14 * n22 * n33 + n12 * n24 * n33 + n13 * n22 * n34 - n12 * n23 * n34;
        te[1] = n24 * n33 * n41 - n23 * n34 * n41 - n24 * n31 * n43 + n21 * n34 * n43 + n23 * n31 * n44 - n21 * n33 * n44;
        te[5] = n13 * n34 * n41 - n14 * n33 * n41 + n14 * n31 * n43 - n11 * n34 * n43 - n13 * n31 * n44 + n11 * n33 * n44;
        te[9] = n14 * n23 * n41 - n13 * n24 * n41 - n14 * n21 * n43 + n11 * n24 * n43 + n13 * n21 * n44 - n11 * n23 * n44;
        te[13] = n13 * n24 * n31 - n14 * n23 * n31 + n14 * n21 * n33 - n11 * n24 * n33 - n13 * n21 * n34 + n11 * n23 * n34;
        te[2] = n22 * n34 * n41 - n24 * n32 * n41 + n24 * n31 * n42 - n21 * n34 * n42 - n22 * n31 * n44 + n21 * n32 * n44;
        te[6] = n14 * n32 * n41 - n12 * n34 * n41 - n14 * n31 * n42 + n11 * n34 * n42 + n12 * n31 * n44 - n11 * n32 * n44;
        te[10] = n12 * n24 * n41 - n14 * n22 * n41 + n14 * n21 * n42 - n11 * n24 * n42 - n12 * n21 * n44 + n11 * n22 * n44;
        te[14] = n14 * n22 * n31 - n12 * n24 * n31 - n14 * n21 * n32 + n11 * n24 * n32 + n12 * n21 * n34 - n11 * n22 * n34;
        te[3] = n23 * n32 * n41 - n22 * n33 * n41 - n23 * n31 * n42 + n21 * n33 * n42 + n22 * n31 * n43 - n21 * n32 * n43;
        te[7] = n12 * n33 * n41 - n13 * n32 * n41 + n13 * n31 * n42 - n11 * n33 * n42 - n12 * n31 * n43 + n11 * n32 * n43;
        te[11] = n13 * n22 * n41 - n12 * n23 * n41 - n13 * n21 * n42 + n11 * n23 * n42 + n12 * n21 * n43 - n11 * n22 * n43;
        te[15] = n12 * n23 * n31 - n13 * n22 * n31 + n13 * n21 * n32 - n11 * n23 * n32 - n12 * n21 * n33 + n11 * n22 * n33;
        var det = n11 * te[0] + n21 * te[4] + n31 * te[8] + n41 * te[12];
        if (det == 0) {
          var msg = "THREE.Matrix4.getInverse(): can't invert matrix, determinant is 0";
          if (throwOnInvertible || false) {
            throw new Error(msg);
          } else {
            THREE.warn(msg);
          }
          this.identity();
          return this;
        }
        this.multiplyScalar(1 / det);
        return this;
      },
      translate: function(v) {
        THREE.error('THREE.Matrix4: .translate() has been removed.');
      },
      rotateX: function(angle) {
        THREE.error('THREE.Matrix4: .rotateX() has been removed.');
      },
      rotateY: function(angle) {
        THREE.error('THREE.Matrix4: .rotateY() has been removed.');
      },
      rotateZ: function(angle) {
        THREE.error('THREE.Matrix4: .rotateZ() has been removed.');
      },
      rotateByAxis: function(axis, angle) {
        THREE.error('THREE.Matrix4: .rotateByAxis() has been removed.');
      },
      scale: function(v) {
        var te = this.elements;
        var x = v.x,
            y = v.y,
            z = v.z;
        te[0] *= x;
        te[4] *= y;
        te[8] *= z;
        te[1] *= x;
        te[5] *= y;
        te[9] *= z;
        te[2] *= x;
        te[6] *= y;
        te[10] *= z;
        te[3] *= x;
        te[7] *= y;
        te[11] *= z;
        return this;
      },
      getMaxScaleOnAxis: function() {
        var te = this.elements;
        var scaleXSq = te[0] * te[0] + te[1] * te[1] + te[2] * te[2];
        var scaleYSq = te[4] * te[4] + te[5] * te[5] + te[6] * te[6];
        var scaleZSq = te[8] * te[8] + te[9] * te[9] + te[10] * te[10];
        return Math.sqrt(Math.max(scaleXSq, Math.max(scaleYSq, scaleZSq)));
      },
      makeTranslation: function(x, y, z) {
        this.set(1, 0, 0, x, 0, 1, 0, y, 0, 0, 1, z, 0, 0, 0, 1);
        return this;
      },
      makeRotationX: function(theta) {
        var c = Math.cos(theta),
            s = Math.sin(theta);
        this.set(1, 0, 0, 0, 0, c, -s, 0, 0, s, c, 0, 0, 0, 0, 1);
        return this;
      },
      makeRotationY: function(theta) {
        var c = Math.cos(theta),
            s = Math.sin(theta);
        this.set(c, 0, s, 0, 0, 1, 0, 0, -s, 0, c, 0, 0, 0, 0, 1);
        return this;
      },
      makeRotationZ: function(theta) {
        var c = Math.cos(theta),
            s = Math.sin(theta);
        this.set(c, -s, 0, 0, s, c, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1);
        return this;
      },
      makeRotationAxis: function(axis, angle) {
        var c = Math.cos(angle);
        var s = Math.sin(angle);
        var t = 1 - c;
        var x = axis.x,
            y = axis.y,
            z = axis.z;
        var tx = t * x,
            ty = t * y;
        this.set(tx * x + c, tx * y - s * z, tx * z + s * y, 0, tx * y + s * z, ty * y + c, ty * z - s * x, 0, tx * z - s * y, ty * z + s * x, t * z * z + c, 0, 0, 0, 0, 1);
        return this;
      },
      makeScale: function(x, y, z) {
        this.set(x, 0, 0, 0, 0, y, 0, 0, 0, 0, z, 0, 0, 0, 0, 1);
        return this;
      },
      compose: function(position, quaternion, scale) {
        this.makeRotationFromQuaternion(quaternion);
        this.scale(scale);
        this.setPosition(position);
        return this;
      },
      decompose: function() {
        var vector = new THREE.Vector3();
        var matrix = new THREE.Matrix4();
        return function(position, quaternion, scale) {
          var te = this.elements;
          var sx = vector.set(te[0], te[1], te[2]).length();
          var sy = vector.set(te[4], te[5], te[6]).length();
          var sz = vector.set(te[8], te[9], te[10]).length();
          var det = this.determinant();
          if (det < 0) {
            sx = -sx;
          }
          position.x = te[12];
          position.y = te[13];
          position.z = te[14];
          matrix.elements.set(this.elements);
          var invSX = 1 / sx;
          var invSY = 1 / sy;
          var invSZ = 1 / sz;
          matrix.elements[0] *= invSX;
          matrix.elements[1] *= invSX;
          matrix.elements[2] *= invSX;
          matrix.elements[4] *= invSY;
          matrix.elements[5] *= invSY;
          matrix.elements[6] *= invSY;
          matrix.elements[8] *= invSZ;
          matrix.elements[9] *= invSZ;
          matrix.elements[10] *= invSZ;
          quaternion.setFromRotationMatrix(matrix);
          scale.x = sx;
          scale.y = sy;
          scale.z = sz;
          return this;
        };
      }(),
      makeFrustum: function(left, right, bottom, top, near, far) {
        var te = this.elements;
        var x = 2 * near / (right - left);
        var y = 2 * near / (top - bottom);
        var a = (right + left) / (right - left);
        var b = (top + bottom) / (top - bottom);
        var c = -(far + near) / (far - near);
        var d = -2 * far * near / (far - near);
        te[0] = x;
        te[4] = 0;
        te[8] = a;
        te[12] = 0;
        te[1] = 0;
        te[5] = y;
        te[9] = b;
        te[13] = 0;
        te[2] = 0;
        te[6] = 0;
        te[10] = c;
        te[14] = d;
        te[3] = 0;
        te[7] = 0;
        te[11] = -1;
        te[15] = 0;
        return this;
      },
      makePerspective: function(fov, aspect, near, far) {
        var ymax = near * Math.tan(THREE.Math.degToRad(fov * 0.5));
        var ymin = -ymax;
        var xmin = ymin * aspect;
        var xmax = ymax * aspect;
        return this.makeFrustum(xmin, xmax, ymin, ymax, near, far);
      },
      makeOrthographic: function(left, right, top, bottom, near, far) {
        var te = this.elements;
        var w = right - left;
        var h = top - bottom;
        var p = far - near;
        var x = (right + left) / w;
        var y = (top + bottom) / h;
        var z = (far + near) / p;
        te[0] = 2 / w;
        te[4] = 0;
        te[8] = 0;
        te[12] = -x;
        te[1] = 0;
        te[5] = 2 / h;
        te[9] = 0;
        te[13] = -y;
        te[2] = 0;
        te[6] = 0;
        te[10] = -2 / p;
        te[14] = -z;
        te[3] = 0;
        te[7] = 0;
        te[11] = 0;
        te[15] = 1;
        return this;
      },
      fromArray: function(array) {
        this.elements.set(array);
        return this;
      },
      toArray: function() {
        var te = this.elements;
        return [te[0], te[1], te[2], te[3], te[4], te[5], te[6], te[7], te[8], te[9], te[10], te[11], te[12], te[13], te[14], te[15]];
      },
      clone: function() {
        return new THREE.Matrix4().fromArray(this.elements);
      }
    };
    THREE.Ray = function(origin, direction) {
      this.origin = (origin !== undefined) ? origin : new THREE.Vector3();
      this.direction = (direction !== undefined) ? direction : new THREE.Vector3();
    };
    THREE.Ray.prototype = {
      constructor: THREE.Ray,
      set: function(origin, direction) {
        this.origin.copy(origin);
        this.direction.copy(direction);
        return this;
      },
      copy: function(ray) {
        this.origin.copy(ray.origin);
        this.direction.copy(ray.direction);
        return this;
      },
      at: function(t, optionalTarget) {
        var result = optionalTarget || new THREE.Vector3();
        return result.copy(this.direction).multiplyScalar(t).add(this.origin);
      },
      recast: function() {
        var v1 = new THREE.Vector3();
        return function(t) {
          this.origin.copy(this.at(t, v1));
          return this;
        };
      }(),
      closestPointToPoint: function(point, optionalTarget) {
        var result = optionalTarget || new THREE.Vector3();
        result.subVectors(point, this.origin);
        var directionDistance = result.dot(this.direction);
        if (directionDistance < 0) {
          return result.copy(this.origin);
        }
        return result.copy(this.direction).multiplyScalar(directionDistance).add(this.origin);
      },
      distanceToPoint: function() {
        var v1 = new THREE.Vector3();
        return function(point) {
          var directionDistance = v1.subVectors(point, this.origin).dot(this.direction);
          if (directionDistance < 0) {
            return this.origin.distanceTo(point);
          }
          v1.copy(this.direction).multiplyScalar(directionDistance).add(this.origin);
          return v1.distanceTo(point);
        };
      }(),
      distanceSqToSegment: function() {
        var segCenter = new THREE.Vector3();
        var segDir = new THREE.Vector3();
        var diff = new THREE.Vector3();
        return function(v0, v1, optionalPointOnRay, optionalPointOnSegment) {
          segCenter.copy(v0).add(v1).multiplyScalar(0.5);
          segDir.copy(v1).sub(v0).normalize();
          diff.copy(this.origin).sub(segCenter);
          var segExtent = v0.distanceTo(v1) * 0.5;
          var a01 = -this.direction.dot(segDir);
          var b0 = diff.dot(this.direction);
          var b1 = -diff.dot(segDir);
          var c = diff.lengthSq();
          var det = Math.abs(1 - a01 * a01);
          var s0,
              s1,
              sqrDist,
              extDet;
          if (det > 0) {
            s0 = a01 * b1 - b0;
            s1 = a01 * b0 - b1;
            extDet = segExtent * det;
            if (s0 >= 0) {
              if (s1 >= -extDet) {
                if (s1 <= extDet) {
                  var invDet = 1 / det;
                  s0 *= invDet;
                  s1 *= invDet;
                  sqrDist = s0 * (s0 + a01 * s1 + 2 * b0) + s1 * (a01 * s0 + s1 + 2 * b1) + c;
                } else {
                  s1 = segExtent;
                  s0 = Math.max(0, -(a01 * s1 + b0));
                  sqrDist = -s0 * s0 + s1 * (s1 + 2 * b1) + c;
                }
              } else {
                s1 = -segExtent;
                s0 = Math.max(0, -(a01 * s1 + b0));
                sqrDist = -s0 * s0 + s1 * (s1 + 2 * b1) + c;
              }
            } else {
              if (s1 <= -extDet) {
                s0 = Math.max(0, -(-a01 * segExtent + b0));
                s1 = (s0 > 0) ? -segExtent : Math.min(Math.max(-segExtent, -b1), segExtent);
                sqrDist = -s0 * s0 + s1 * (s1 + 2 * b1) + c;
              } else if (s1 <= extDet) {
                s0 = 0;
                s1 = Math.min(Math.max(-segExtent, -b1), segExtent);
                sqrDist = s1 * (s1 + 2 * b1) + c;
              } else {
                s0 = Math.max(0, -(a01 * segExtent + b0));
                s1 = (s0 > 0) ? segExtent : Math.min(Math.max(-segExtent, -b1), segExtent);
                sqrDist = -s0 * s0 + s1 * (s1 + 2 * b1) + c;
              }
            }
          } else {
            s1 = (a01 > 0) ? -segExtent : segExtent;
            s0 = Math.max(0, -(a01 * s1 + b0));
            sqrDist = -s0 * s0 + s1 * (s1 + 2 * b1) + c;
          }
          if (optionalPointOnRay) {
            optionalPointOnRay.copy(this.direction).multiplyScalar(s0).add(this.origin);
          }
          if (optionalPointOnSegment) {
            optionalPointOnSegment.copy(segDir).multiplyScalar(s1).add(segCenter);
          }
          return sqrDist;
        };
      }(),
      isIntersectionSphere: function(sphere) {
        return this.distanceToPoint(sphere.center) <= sphere.radius;
      },
      intersectSphere: function() {
        var v1 = new THREE.Vector3();
        return function(sphere, optionalTarget) {
          v1.subVectors(sphere.center, this.origin);
          var tca = v1.dot(this.direction);
          var d2 = v1.dot(v1) - tca * tca;
          var radius2 = sphere.radius * sphere.radius;
          if (d2 > radius2)
            return null;
          var thc = Math.sqrt(radius2 - d2);
          var t0 = tca - thc;
          var t1 = tca + thc;
          if (t0 < 0 && t1 < 0)
            return null;
          if (t0 < 0)
            return this.at(t1, optionalTarget);
          return this.at(t0, optionalTarget);
        };
      }(),
      isIntersectionPlane: function(plane) {
        var distToPoint = plane.distanceToPoint(this.origin);
        if (distToPoint === 0) {
          return true;
        }
        var denominator = plane.normal.dot(this.direction);
        if (denominator * distToPoint < 0) {
          return true;
        }
        return false;
      },
      distanceToPlane: function(plane) {
        var denominator = plane.normal.dot(this.direction);
        if (denominator == 0) {
          if (plane.distanceToPoint(this.origin) == 0) {
            return 0;
          }
          return null;
        }
        var t = -(this.origin.dot(plane.normal) + plane.constant) / denominator;
        return t >= 0 ? t : null;
      },
      intersectPlane: function(plane, optionalTarget) {
        var t = this.distanceToPlane(plane);
        if (t === null) {
          return null;
        }
        return this.at(t, optionalTarget);
      },
      isIntersectionBox: function() {
        var v = new THREE.Vector3();
        return function(box) {
          return this.intersectBox(box, v) !== null;
        };
      }(),
      intersectBox: function(box, optionalTarget) {
        var tmin,
            tmax,
            tymin,
            tymax,
            tzmin,
            tzmax;
        var invdirx = 1 / this.direction.x,
            invdiry = 1 / this.direction.y,
            invdirz = 1 / this.direction.z;
        var origin = this.origin;
        if (invdirx >= 0) {
          tmin = (box.min.x - origin.x) * invdirx;
          tmax = (box.max.x - origin.x) * invdirx;
        } else {
          tmin = (box.max.x - origin.x) * invdirx;
          tmax = (box.min.x - origin.x) * invdirx;
        }
        if (invdiry >= 0) {
          tymin = (box.min.y - origin.y) * invdiry;
          tymax = (box.max.y - origin.y) * invdiry;
        } else {
          tymin = (box.max.y - origin.y) * invdiry;
          tymax = (box.min.y - origin.y) * invdiry;
        }
        if ((tmin > tymax) || (tymin > tmax))
          return null;
        if (tymin > tmin || tmin !== tmin)
          tmin = tymin;
        if (tymax < tmax || tmax !== tmax)
          tmax = tymax;
        if (invdirz >= 0) {
          tzmin = (box.min.z - origin.z) * invdirz;
          tzmax = (box.max.z - origin.z) * invdirz;
        } else {
          tzmin = (box.max.z - origin.z) * invdirz;
          tzmax = (box.min.z - origin.z) * invdirz;
        }
        if ((tmin > tzmax) || (tzmin > tmax))
          return null;
        if (tzmin > tmin || tmin !== tmin)
          tmin = tzmin;
        if (tzmax < tmax || tmax !== tmax)
          tmax = tzmax;
        if (tmax < 0)
          return null;
        return this.at(tmin >= 0 ? tmin : tmax, optionalTarget);
      },
      intersectTriangle: function() {
        var diff = new THREE.Vector3();
        var edge1 = new THREE.Vector3();
        var edge2 = new THREE.Vector3();
        var normal = new THREE.Vector3();
        return function(a, b, c, backfaceCulling, optionalTarget) {
          edge1.subVectors(b, a);
          edge2.subVectors(c, a);
          normal.crossVectors(edge1, edge2);
          var DdN = this.direction.dot(normal);
          var sign;
          if (DdN > 0) {
            if (backfaceCulling)
              return null;
            sign = 1;
          } else if (DdN < 0) {
            sign = -1;
            DdN = -DdN;
          } else {
            return null;
          }
          diff.subVectors(this.origin, a);
          var DdQxE2 = sign * this.direction.dot(edge2.crossVectors(diff, edge2));
          if (DdQxE2 < 0) {
            return null;
          }
          var DdE1xQ = sign * this.direction.dot(edge1.cross(diff));
          if (DdE1xQ < 0) {
            return null;
          }
          if (DdQxE2 + DdE1xQ > DdN) {
            return null;
          }
          var QdN = -sign * diff.dot(normal);
          if (QdN < 0) {
            return null;
          }
          return this.at(QdN / DdN, optionalTarget);
        };
      }(),
      applyMatrix4: function(matrix4) {
        this.direction.add(this.origin).applyMatrix4(matrix4);
        this.origin.applyMatrix4(matrix4);
        this.direction.sub(this.origin);
        this.direction.normalize();
        return this;
      },
      equals: function(ray) {
        return ray.origin.equals(this.origin) && ray.direction.equals(this.direction);
      },
      clone: function() {
        return new THREE.Ray().copy(this);
      }
    };
    THREE.Sphere = function(center, radius) {
      this.center = (center !== undefined) ? center : new THREE.Vector3();
      this.radius = (radius !== undefined) ? radius : 0;
    };
    THREE.Sphere.prototype = {
      constructor: THREE.Sphere,
      set: function(center, radius) {
        this.center.copy(center);
        this.radius = radius;
        return this;
      },
      setFromPoints: function() {
        var box = new THREE.Box3();
        return function(points, optionalCenter) {
          var center = this.center;
          if (optionalCenter !== undefined) {
            center.copy(optionalCenter);
          } else {
            box.setFromPoints(points).center(center);
          }
          var maxRadiusSq = 0;
          for (var i = 0,
              il = points.length; i < il; i++) {
            maxRadiusSq = Math.max(maxRadiusSq, center.distanceToSquared(points[i]));
          }
          this.radius = Math.sqrt(maxRadiusSq);
          return this;
        };
      }(),
      copy: function(sphere) {
        this.center.copy(sphere.center);
        this.radius = sphere.radius;
        return this;
      },
      empty: function() {
        return (this.radius <= 0);
      },
      containsPoint: function(point) {
        return (point.distanceToSquared(this.center) <= (this.radius * this.radius));
      },
      distanceToPoint: function(point) {
        return (point.distanceTo(this.center) - this.radius);
      },
      intersectsSphere: function(sphere) {
        var radiusSum = this.radius + sphere.radius;
        return sphere.center.distanceToSquared(this.center) <= (radiusSum * radiusSum);
      },
      clampPoint: function(point, optionalTarget) {
        var deltaLengthSq = this.center.distanceToSquared(point);
        var result = optionalTarget || new THREE.Vector3();
        result.copy(point);
        if (deltaLengthSq > (this.radius * this.radius)) {
          result.sub(this.center).normalize();
          result.multiplyScalar(this.radius).add(this.center);
        }
        return result;
      },
      getBoundingBox: function(optionalTarget) {
        var box = optionalTarget || new THREE.Box3();
        box.set(this.center, this.center);
        box.expandByScalar(this.radius);
        return box;
      },
      applyMatrix4: function(matrix) {
        this.center.applyMatrix4(matrix);
        this.radius = this.radius * matrix.getMaxScaleOnAxis();
        return this;
      },
      translate: function(offset) {
        this.center.add(offset);
        return this;
      },
      equals: function(sphere) {
        return sphere.center.equals(this.center) && (sphere.radius === this.radius);
      },
      clone: function() {
        return new THREE.Sphere().copy(this);
      }
    };
    THREE.Frustum = function(p0, p1, p2, p3, p4, p5) {
      this.planes = [(p0 !== undefined) ? p0 : new THREE.Plane(), (p1 !== undefined) ? p1 : new THREE.Plane(), (p2 !== undefined) ? p2 : new THREE.Plane(), (p3 !== undefined) ? p3 : new THREE.Plane(), (p4 !== undefined) ? p4 : new THREE.Plane(), (p5 !== undefined) ? p5 : new THREE.Plane()];
    };
    THREE.Frustum.prototype = {
      constructor: THREE.Frustum,
      set: function(p0, p1, p2, p3, p4, p5) {
        var planes = this.planes;
        planes[0].copy(p0);
        planes[1].copy(p1);
        planes[2].copy(p2);
        planes[3].copy(p3);
        planes[4].copy(p4);
        planes[5].copy(p5);
        return this;
      },
      copy: function(frustum) {
        var planes = this.planes;
        for (var i = 0; i < 6; i++) {
          planes[i].copy(frustum.planes[i]);
        }
        return this;
      },
      setFromMatrix: function(m) {
        var planes = this.planes;
        var me = m.elements;
        var me0 = me[0],
            me1 = me[1],
            me2 = me[2],
            me3 = me[3];
        var me4 = me[4],
            me5 = me[5],
            me6 = me[6],
            me7 = me[7];
        var me8 = me[8],
            me9 = me[9],
            me10 = me[10],
            me11 = me[11];
        var me12 = me[12],
            me13 = me[13],
            me14 = me[14],
            me15 = me[15];
        planes[0].setComponents(me3 - me0, me7 - me4, me11 - me8, me15 - me12).normalize();
        planes[1].setComponents(me3 + me0, me7 + me4, me11 + me8, me15 + me12).normalize();
        planes[2].setComponents(me3 + me1, me7 + me5, me11 + me9, me15 + me13).normalize();
        planes[3].setComponents(me3 - me1, me7 - me5, me11 - me9, me15 - me13).normalize();
        planes[4].setComponents(me3 - me2, me7 - me6, me11 - me10, me15 - me14).normalize();
        planes[5].setComponents(me3 + me2, me7 + me6, me11 + me10, me15 + me14).normalize();
        return this;
      },
      intersectsObject: function() {
        var sphere = new THREE.Sphere();
        return function(object) {
          var geometry = object.geometry;
          if (geometry.boundingSphere === null)
            geometry.computeBoundingSphere();
          sphere.copy(geometry.boundingSphere);
          sphere.applyMatrix4(object.matrixWorld);
          return this.intersectsSphere(sphere);
        };
      }(),
      intersectsSphere: function(sphere) {
        var planes = this.planes;
        var center = sphere.center;
        var negRadius = -sphere.radius;
        for (var i = 0; i < 6; i++) {
          var distance = planes[i].distanceToPoint(center);
          if (distance < negRadius) {
            return false;
          }
        }
        return true;
      },
      intersectsBox: function() {
        var p1 = new THREE.Vector3(),
            p2 = new THREE.Vector3();
        return function(box) {
          var planes = this.planes;
          for (var i = 0; i < 6; i++) {
            var plane = planes[i];
            p1.x = plane.normal.x > 0 ? box.min.x : box.max.x;
            p2.x = plane.normal.x > 0 ? box.max.x : box.min.x;
            p1.y = plane.normal.y > 0 ? box.min.y : box.max.y;
            p2.y = plane.normal.y > 0 ? box.max.y : box.min.y;
            p1.z = plane.normal.z > 0 ? box.min.z : box.max.z;
            p2.z = plane.normal.z > 0 ? box.max.z : box.min.z;
            var d1 = plane.distanceToPoint(p1);
            var d2 = plane.distanceToPoint(p2);
            if (d1 < 0 && d2 < 0) {
              return false;
            }
          }
          return true;
        };
      }(),
      containsPoint: function(point) {
        var planes = this.planes;
        for (var i = 0; i < 6; i++) {
          if (planes[i].distanceToPoint(point) < 0) {
            return false;
          }
        }
        return true;
      },
      clone: function() {
        return new THREE.Frustum().copy(this);
      }
    };
    THREE.Plane = function(normal, constant) {
      this.normal = (normal !== undefined) ? normal : new THREE.Vector3(1, 0, 0);
      this.constant = (constant !== undefined) ? constant : 0;
    };
    THREE.Plane.prototype = {
      constructor: THREE.Plane,
      set: function(normal, constant) {
        this.normal.copy(normal);
        this.constant = constant;
        return this;
      },
      setComponents: function(x, y, z, w) {
        this.normal.set(x, y, z);
        this.constant = w;
        return this;
      },
      setFromNormalAndCoplanarPoint: function(normal, point) {
        this.normal.copy(normal);
        this.constant = -point.dot(this.normal);
        return this;
      },
      setFromCoplanarPoints: function() {
        var v1 = new THREE.Vector3();
        var v2 = new THREE.Vector3();
        return function(a, b, c) {
          var normal = v1.subVectors(c, b).cross(v2.subVectors(a, b)).normalize();
          this.setFromNormalAndCoplanarPoint(normal, a);
          return this;
        };
      }(),
      copy: function(plane) {
        this.normal.copy(plane.normal);
        this.constant = plane.constant;
        return this;
      },
      normalize: function() {
        var inverseNormalLength = 1.0 / this.normal.length();
        this.normal.multiplyScalar(inverseNormalLength);
        this.constant *= inverseNormalLength;
        return this;
      },
      negate: function() {
        this.constant *= -1;
        this.normal.negate();
        return this;
      },
      distanceToPoint: function(point) {
        return this.normal.dot(point) + this.constant;
      },
      distanceToSphere: function(sphere) {
        return this.distanceToPoint(sphere.center) - sphere.radius;
      },
      projectPoint: function(point, optionalTarget) {
        return this.orthoPoint(point, optionalTarget).sub(point).negate();
      },
      orthoPoint: function(point, optionalTarget) {
        var perpendicularMagnitude = this.distanceToPoint(point);
        var result = optionalTarget || new THREE.Vector3();
        return result.copy(this.normal).multiplyScalar(perpendicularMagnitude);
      },
      isIntersectionLine: function(line) {
        var startSign = this.distanceToPoint(line.start);
        var endSign = this.distanceToPoint(line.end);
        return (startSign < 0 && endSign > 0) || (endSign < 0 && startSign > 0);
      },
      intersectLine: function() {
        var v1 = new THREE.Vector3();
        return function(line, optionalTarget) {
          var result = optionalTarget || new THREE.Vector3();
          var direction = line.delta(v1);
          var denominator = this.normal.dot(direction);
          if (denominator == 0) {
            if (this.distanceToPoint(line.start) == 0) {
              return result.copy(line.start);
            }
            return undefined;
          }
          var t = -(line.start.dot(this.normal) + this.constant) / denominator;
          if (t < 0 || t > 1) {
            return undefined;
          }
          return result.copy(direction).multiplyScalar(t).add(line.start);
        };
      }(),
      coplanarPoint: function(optionalTarget) {
        var result = optionalTarget || new THREE.Vector3();
        return result.copy(this.normal).multiplyScalar(-this.constant);
      },
      applyMatrix4: function() {
        var v1 = new THREE.Vector3();
        var v2 = new THREE.Vector3();
        var m1 = new THREE.Matrix3();
        return function(matrix, optionalNormalMatrix) {
          var normalMatrix = optionalNormalMatrix || m1.getNormalMatrix(matrix);
          var newNormal = v1.copy(this.normal).applyMatrix3(normalMatrix);
          var newCoplanarPoint = this.coplanarPoint(v2);
          newCoplanarPoint.applyMatrix4(matrix);
          this.setFromNormalAndCoplanarPoint(newNormal, newCoplanarPoint);
          return this;
        };
      }(),
      translate: function(offset) {
        this.constant = this.constant - offset.dot(this.normal);
        return this;
      },
      equals: function(plane) {
        return plane.normal.equals(this.normal) && (plane.constant == this.constant);
      },
      clone: function() {
        return new THREE.Plane().copy(this);
      }
    };
    THREE.Math = {
      generateUUID: function() {
        var chars = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz'.split('');
        var uuid = new Array(36);
        var rnd = 0,
            r;
        return function() {
          for (var i = 0; i < 36; i++) {
            if (i == 8 || i == 13 || i == 18 || i == 23) {
              uuid[i] = '-';
            } else if (i == 14) {
              uuid[i] = '4';
            } else {
              if (rnd <= 0x02)
                rnd = 0x2000000 + (Math.random() * 0x1000000) | 0;
              r = rnd & 0xf;
              rnd = rnd >> 4;
              uuid[i] = chars[(i == 19) ? (r & 0x3) | 0x8 : r];
            }
          }
          return uuid.join('');
        };
      }(),
      clamp: function(x, a, b) {
        return (x < a) ? a : ((x > b) ? b : x);
      },
      clampBottom: function(x, a) {
        return x < a ? a : x;
      },
      mapLinear: function(x, a1, a2, b1, b2) {
        return b1 + (x - a1) * (b2 - b1) / (a2 - a1);
      },
      smoothstep: function(x, min, max) {
        if (x <= min)
          return 0;
        if (x >= max)
          return 1;
        x = (x - min) / (max - min);
        return x * x * (3 - 2 * x);
      },
      smootherstep: function(x, min, max) {
        if (x <= min)
          return 0;
        if (x >= max)
          return 1;
        x = (x - min) / (max - min);
        return x * x * x * (x * (x * 6 - 15) + 10);
      },
      random16: function() {
        return (65280 * Math.random() + 255 * Math.random()) / 65535;
      },
      randInt: function(low, high) {
        return Math.floor(this.randFloat(low, high));
      },
      randFloat: function(low, high) {
        return low + Math.random() * (high - low);
      },
      randFloatSpread: function(range) {
        return range * (0.5 - Math.random());
      },
      degToRad: function() {
        var degreeToRadiansFactor = Math.PI / 180;
        return function(degrees) {
          return degrees * degreeToRadiansFactor;
        };
      }(),
      radToDeg: function() {
        var radianToDegreesFactor = 180 / Math.PI;
        return function(radians) {
          return radians * radianToDegreesFactor;
        };
      }(),
      isPowerOfTwo: function(value) {
        return (value & (value - 1)) === 0 && value !== 0;
      },
      nextPowerOfTwo: function(value) {
        value--;
        value |= value >> 1;
        value |= value >> 2;
        value |= value >> 4;
        value |= value >> 8;
        value |= value >> 16;
        value++;
        return value;
      }
    };
    THREE.Spline = function(points) {
      this.points = points;
      var c = [],
          v3 = {
            x: 0,
            y: 0,
            z: 0
          },
          point,
          intPoint,
          weight,
          w2,
          w3,
          pa,
          pb,
          pc,
          pd;
      this.initFromArray = function(a) {
        this.points = [];
        for (var i = 0; i < a.length; i++) {
          this.points[i] = {
            x: a[i][0],
            y: a[i][1],
            z: a[i][2]
          };
        }
      };
      this.getPoint = function(k) {
        point = (this.points.length - 1) * k;
        intPoint = Math.floor(point);
        weight = point - intPoint;
        c[0] = intPoint === 0 ? intPoint : intPoint - 1;
        c[1] = intPoint;
        c[2] = intPoint > this.points.length - 2 ? this.points.length - 1 : intPoint + 1;
        c[3] = intPoint > this.points.length - 3 ? this.points.length - 1 : intPoint + 2;
        pa = this.points[c[0]];
        pb = this.points[c[1]];
        pc = this.points[c[2]];
        pd = this.points[c[3]];
        w2 = weight * weight;
        w3 = weight * w2;
        v3.x = interpolate(pa.x, pb.x, pc.x, pd.x, weight, w2, w3);
        v3.y = interpolate(pa.y, pb.y, pc.y, pd.y, weight, w2, w3);
        v3.z = interpolate(pa.z, pb.z, pc.z, pd.z, weight, w2, w3);
        return v3;
      };
      this.getControlPointsArray = function() {
        var i,
            p,
            l = this.points.length,
            coords = [];
        for (i = 0; i < l; i++) {
          p = this.points[i];
          coords[i] = [p.x, p.y, p.z];
        }
        return coords;
      };
      this.getLength = function(nSubDivisions) {
        var i,
            index,
            nSamples,
            position,
            point = 0,
            intPoint = 0,
            oldIntPoint = 0,
            oldPosition = new THREE.Vector3(),
            tmpVec = new THREE.Vector3(),
            chunkLengths = [],
            totalLength = 0;
        chunkLengths[0] = 0;
        if (!nSubDivisions)
          nSubDivisions = 100;
        nSamples = this.points.length * nSubDivisions;
        oldPosition.copy(this.points[0]);
        for (i = 1; i < nSamples; i++) {
          index = i / nSamples;
          position = this.getPoint(index);
          tmpVec.copy(position);
          totalLength += tmpVec.distanceTo(oldPosition);
          oldPosition.copy(position);
          point = (this.points.length - 1) * index;
          intPoint = Math.floor(point);
          if (intPoint != oldIntPoint) {
            chunkLengths[intPoint] = totalLength;
            oldIntPoint = intPoint;
          }
        }
        chunkLengths[chunkLengths.length] = totalLength;
        return {
          chunks: chunkLengths,
          total: totalLength
        };
      };
      this.reparametrizeByArcLength = function(samplingCoef) {
        var i,
            j,
            index,
            indexCurrent,
            indexNext,
            realDistance,
            sampling,
            position,
            newpoints = [],
            tmpVec = new THREE.Vector3(),
            sl = this.getLength();
        newpoints.push(tmpVec.copy(this.points[0]).clone());
        for (i = 1; i < this.points.length; i++) {
          realDistance = sl.chunks[i] - sl.chunks[i - 1];
          sampling = Math.ceil(samplingCoef * realDistance / sl.total);
          indexCurrent = (i - 1) / (this.points.length - 1);
          indexNext = i / (this.points.length - 1);
          for (j = 1; j < sampling - 1; j++) {
            index = indexCurrent + j * (1 / sampling) * (indexNext - indexCurrent);
            position = this.getPoint(index);
            newpoints.push(tmpVec.copy(position).clone());
          }
          newpoints.push(tmpVec.copy(this.points[i]).clone());
        }
        this.points = newpoints;
      };
      function interpolate(p0, p1, p2, p3, t, t2, t3) {
        var v0 = (p2 - p0) * 0.5,
            v1 = (p3 - p1) * 0.5;
        return (2 * (p1 - p2) + v0 + v1) * t3 + (-3 * (p1 - p2) - 2 * v0 - v1) * t2 + v0 * t + p1;
      }
      ;
    };
    THREE.Triangle = function(a, b, c) {
      this.a = (a !== undefined) ? a : new THREE.Vector3();
      this.b = (b !== undefined) ? b : new THREE.Vector3();
      this.c = (c !== undefined) ? c : new THREE.Vector3();
    };
    THREE.Triangle.normal = function() {
      var v0 = new THREE.Vector3();
      return function(a, b, c, optionalTarget) {
        var result = optionalTarget || new THREE.Vector3();
        result.subVectors(c, b);
        v0.subVectors(a, b);
        result.cross(v0);
        var resultLengthSq = result.lengthSq();
        if (resultLengthSq > 0) {
          return result.multiplyScalar(1 / Math.sqrt(resultLengthSq));
        }
        return result.set(0, 0, 0);
      };
    }();
    THREE.Triangle.barycoordFromPoint = function() {
      var v0 = new THREE.Vector3();
      var v1 = new THREE.Vector3();
      var v2 = new THREE.Vector3();
      return function(point, a, b, c, optionalTarget) {
        v0.subVectors(c, a);
        v1.subVectors(b, a);
        v2.subVectors(point, a);
        var dot00 = v0.dot(v0);
        var dot01 = v0.dot(v1);
        var dot02 = v0.dot(v2);
        var dot11 = v1.dot(v1);
        var dot12 = v1.dot(v2);
        var denom = (dot00 * dot11 - dot01 * dot01);
        var result = optionalTarget || new THREE.Vector3();
        if (denom == 0) {
          return result.set(-2, -1, -1);
        }
        var invDenom = 1 / denom;
        var u = (dot11 * dot02 - dot01 * dot12) * invDenom;
        var v = (dot00 * dot12 - dot01 * dot02) * invDenom;
        return result.set(1 - u - v, v, u);
      };
    }();
    THREE.Triangle.containsPoint = function() {
      var v1 = new THREE.Vector3();
      return function(point, a, b, c) {
        var result = THREE.Triangle.barycoordFromPoint(point, a, b, c, v1);
        return (result.x >= 0) && (result.y >= 0) && ((result.x + result.y) <= 1);
      };
    }();
    THREE.Triangle.prototype = {
      constructor: THREE.Triangle,
      set: function(a, b, c) {
        this.a.copy(a);
        this.b.copy(b);
        this.c.copy(c);
        return this;
      },
      setFromPointsAndIndices: function(points, i0, i1, i2) {
        this.a.copy(points[i0]);
        this.b.copy(points[i1]);
        this.c.copy(points[i2]);
        return this;
      },
      copy: function(triangle) {
        this.a.copy(triangle.a);
        this.b.copy(triangle.b);
        this.c.copy(triangle.c);
        return this;
      },
      area: function() {
        var v0 = new THREE.Vector3();
        var v1 = new THREE.Vector3();
        return function() {
          v0.subVectors(this.c, this.b);
          v1.subVectors(this.a, this.b);
          return v0.cross(v1).length() * 0.5;
        };
      }(),
      midpoint: function(optionalTarget) {
        var result = optionalTarget || new THREE.Vector3();
        return result.addVectors(this.a, this.b).add(this.c).multiplyScalar(1 / 3);
      },
      normal: function(optionalTarget) {
        return THREE.Triangle.normal(this.a, this.b, this.c, optionalTarget);
      },
      plane: function(optionalTarget) {
        var result = optionalTarget || new THREE.Plane();
        return result.setFromCoplanarPoints(this.a, this.b, this.c);
      },
      barycoordFromPoint: function(point, optionalTarget) {
        return THREE.Triangle.barycoordFromPoint(point, this.a, this.b, this.c, optionalTarget);
      },
      containsPoint: function(point) {
        return THREE.Triangle.containsPoint(point, this.a, this.b, this.c);
      },
      equals: function(triangle) {
        return triangle.a.equals(this.a) && triangle.b.equals(this.b) && triangle.c.equals(this.c);
      },
      clone: function() {
        return new THREE.Triangle().copy(this);
      }
    };
    THREE.Clock = function(autoStart) {
      this.autoStart = (autoStart !== undefined) ? autoStart : true;
      this.startTime = 0;
      this.oldTime = 0;
      this.elapsedTime = 0;
      this.running = false;
    };
    THREE.Clock.prototype = {
      constructor: THREE.Clock,
      start: function() {
        this.startTime = self.performance !== undefined && self.performance.now !== undefined ? self.performance.now() : Date.now();
        this.oldTime = this.startTime;
        this.running = true;
      },
      stop: function() {
        this.getElapsedTime();
        this.running = false;
      },
      getElapsedTime: function() {
        this.getDelta();
        return this.elapsedTime;
      },
      getDelta: function() {
        var diff = 0;
        if (this.autoStart && !this.running) {
          this.start();
        }
        if (this.running) {
          var newTime = self.performance !== undefined && self.performance.now !== undefined ? self.performance.now() : Date.now();
          diff = 0.001 * (newTime - this.oldTime);
          this.oldTime = newTime;
          this.elapsedTime += diff;
        }
        return diff;
      }
    };
    THREE.EventDispatcher = function() {};
    THREE.EventDispatcher.prototype = {
      constructor: THREE.EventDispatcher,
      apply: function(object) {
        object.addEventListener = THREE.EventDispatcher.prototype.addEventListener;
        object.hasEventListener = THREE.EventDispatcher.prototype.hasEventListener;
        object.removeEventListener = THREE.EventDispatcher.prototype.removeEventListener;
        object.dispatchEvent = THREE.EventDispatcher.prototype.dispatchEvent;
      },
      addEventListener: function(type, listener) {
        if (this._listeners === undefined)
          this._listeners = {};
        var listeners = this._listeners;
        if (listeners[type] === undefined) {
          listeners[type] = [];
        }
        if (listeners[type].indexOf(listener) === -1) {
          listeners[type].push(listener);
        }
      },
      hasEventListener: function(type, listener) {
        if (this._listeners === undefined)
          return false;
        var listeners = this._listeners;
        if (listeners[type] !== undefined && listeners[type].indexOf(listener) !== -1) {
          return true;
        }
        return false;
      },
      removeEventListener: function(type, listener) {
        if (this._listeners === undefined)
          return ;
        var listeners = this._listeners;
        var listenerArray = listeners[type];
        if (listenerArray !== undefined) {
          var index = listenerArray.indexOf(listener);
          if (index !== -1) {
            listenerArray.splice(index, 1);
          }
        }
      },
      dispatchEvent: function(event) {
        if (this._listeners === undefined)
          return ;
        var listeners = this._listeners;
        var listenerArray = listeners[event.type];
        if (listenerArray !== undefined) {
          event.target = this;
          var array = [];
          var length = listenerArray.length;
          for (var i = 0; i < length; i++) {
            array[i] = listenerArray[i];
          }
          for (var i = 0; i < length; i++) {
            array[i].call(this, event);
          }
        }
      }
    };
    (function(THREE) {
      THREE.Raycaster = function(origin, direction, near, far) {
        this.ray = new THREE.Ray(origin, direction);
        this.near = near || 0;
        this.far = far || Infinity;
        this.params = {
          Sprite: {},
          Mesh: {},
          PointCloud: {threshold: 1},
          LOD: {},
          Line: {}
        };
      };
      var descSort = function(a, b) {
        return a.distance - b.distance;
      };
      var intersectObject = function(object, raycaster, intersects, recursive) {
        object.raycast(raycaster, intersects);
        if (recursive === true) {
          var children = object.children;
          for (var i = 0,
              l = children.length; i < l; i++) {
            intersectObject(children[i], raycaster, intersects, true);
          }
        }
      };
      THREE.Raycaster.prototype = {
        constructor: THREE.Raycaster,
        precision: 0.0001,
        linePrecision: 1,
        set: function(origin, direction) {
          this.ray.set(origin, direction);
        },
        setFromCamera: function(coords, camera) {
          if (camera instanceof THREE.PerspectiveCamera) {
            this.ray.origin.copy(camera.position);
            this.ray.direction.set(coords.x, coords.y, 0.5).unproject(camera).sub(camera.position).normalize();
          } else if (camera instanceof THREE.OrthographicCamera) {
            this.ray.origin.set(coords.x, coords.y, -1).unproject(camera);
            this.ray.direction.set(0, 0, -1).transformDirection(camera.matrixWorld);
          } else {
            THREE.error('THREE.Raycaster: Unsupported camera type.');
          }
        },
        intersectObject: function(object, recursive) {
          var intersects = [];
          intersectObject(object, this, intersects, recursive);
          intersects.sort(descSort);
          return intersects;
        },
        intersectObjects: function(objects, recursive) {
          var intersects = [];
          if (objects instanceof Array === false) {
            THREE.warn('THREE.Raycaster.intersectObjects: objects is not an Array.');
            return intersects;
          }
          for (var i = 0,
              l = objects.length; i < l; i++) {
            intersectObject(objects[i], this, intersects, recursive);
          }
          intersects.sort(descSort);
          return intersects;
        }
      };
    }(THREE));
    THREE.Object3D = function() {
      Object.defineProperty(this, 'id', {value: THREE.Object3DIdCount++});
      this.uuid = THREE.Math.generateUUID();
      this.name = '';
      this.type = 'Object3D';
      this.parent = undefined;
      this.children = [];
      this.up = THREE.Object3D.DefaultUp.clone();
      var position = new THREE.Vector3();
      var rotation = new THREE.Euler();
      var quaternion = new THREE.Quaternion();
      var scale = new THREE.Vector3(1, 1, 1);
      var onRotationChange = function() {
        quaternion.setFromEuler(rotation, false);
      };
      var onQuaternionChange = function() {
        rotation.setFromQuaternion(quaternion, undefined, false);
      };
      rotation.onChange(onRotationChange);
      quaternion.onChange(onQuaternionChange);
      Object.defineProperties(this, {
        position: {
          enumerable: true,
          value: position
        },
        rotation: {
          enumerable: true,
          value: rotation
        },
        quaternion: {
          enumerable: true,
          value: quaternion
        },
        scale: {
          enumerable: true,
          value: scale
        }
      });
      this.rotationAutoUpdate = true;
      this.matrix = new THREE.Matrix4();
      this.matrixWorld = new THREE.Matrix4();
      this.matrixAutoUpdate = true;
      this.matrixWorldNeedsUpdate = false;
      this.visible = true;
      this.castShadow = false;
      this.receiveShadow = false;
      this.frustumCulled = true;
      this.renderOrder = 0;
      this.userData = {};
    };
    THREE.Object3D.DefaultUp = new THREE.Vector3(0, 1, 0);
    THREE.Object3D.prototype = {
      constructor: THREE.Object3D,
      get eulerOrder() {
        THREE.warn('THREE.Object3D: .eulerOrder has been moved to .rotation.order.');
        return this.rotation.order;
      },
      set eulerOrder(value) {
        THREE.warn('THREE.Object3D: .eulerOrder has been moved to .rotation.order.');
        this.rotation.order = value;
      },
      get useQuaternion() {
        THREE.warn('THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.');
      },
      set useQuaternion(value) {
        THREE.warn('THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.');
      },
      applyMatrix: function(matrix) {
        this.matrix.multiplyMatrices(matrix, this.matrix);
        this.matrix.decompose(this.position, this.quaternion, this.scale);
      },
      setRotationFromAxisAngle: function(axis, angle) {
        this.quaternion.setFromAxisAngle(axis, angle);
      },
      setRotationFromEuler: function(euler) {
        this.quaternion.setFromEuler(euler, true);
      },
      setRotationFromMatrix: function(m) {
        this.quaternion.setFromRotationMatrix(m);
      },
      setRotationFromQuaternion: function(q) {
        this.quaternion.copy(q);
      },
      rotateOnAxis: function() {
        var q1 = new THREE.Quaternion();
        return function(axis, angle) {
          q1.setFromAxisAngle(axis, angle);
          this.quaternion.multiply(q1);
          return this;
        };
      }(),
      rotateX: function() {
        var v1 = new THREE.Vector3(1, 0, 0);
        return function(angle) {
          return this.rotateOnAxis(v1, angle);
        };
      }(),
      rotateY: function() {
        var v1 = new THREE.Vector3(0, 1, 0);
        return function(angle) {
          return this.rotateOnAxis(v1, angle);
        };
      }(),
      rotateZ: function() {
        var v1 = new THREE.Vector3(0, 0, 1);
        return function(angle) {
          return this.rotateOnAxis(v1, angle);
        };
      }(),
      translateOnAxis: function() {
        var v1 = new THREE.Vector3();
        return function(axis, distance) {
          v1.copy(axis).applyQuaternion(this.quaternion);
          this.position.add(v1.multiplyScalar(distance));
          return this;
        };
      }(),
      translate: function(distance, axis) {
        THREE.warn('THREE.Object3D: .translate() has been removed. Use .translateOnAxis( axis, distance ) instead.');
        return this.translateOnAxis(axis, distance);
      },
      translateX: function() {
        var v1 = new THREE.Vector3(1, 0, 0);
        return function(distance) {
          return this.translateOnAxis(v1, distance);
        };
      }(),
      translateY: function() {
        var v1 = new THREE.Vector3(0, 1, 0);
        return function(distance) {
          return this.translateOnAxis(v1, distance);
        };
      }(),
      translateZ: function() {
        var v1 = new THREE.Vector3(0, 0, 1);
        return function(distance) {
          return this.translateOnAxis(v1, distance);
        };
      }(),
      localToWorld: function(vector) {
        return vector.applyMatrix4(this.matrixWorld);
      },
      worldToLocal: function() {
        var m1 = new THREE.Matrix4();
        return function(vector) {
          return vector.applyMatrix4(m1.getInverse(this.matrixWorld));
        };
      }(),
      lookAt: function() {
        var m1 = new THREE.Matrix4();
        return function(vector) {
          m1.lookAt(vector, this.position, this.up);
          this.quaternion.setFromRotationMatrix(m1);
        };
      }(),
      add: function(object) {
        if (arguments.length > 1) {
          for (var i = 0; i < arguments.length; i++) {
            this.add(arguments[i]);
          }
          return this;
        }
        ;
        if (object === this) {
          THREE.error("THREE.Object3D.add: object can't be added as a child of itself.", object);
          return this;
        }
        if (object instanceof THREE.Object3D) {
          if (object.parent !== undefined) {
            object.parent.remove(object);
          }
          object.parent = this;
          object.dispatchEvent({type: 'added'});
          this.children.push(object);
        } else {
          THREE.error("THREE.Object3D.add: object not an instance of THREE.Object3D.", object);
        }
        return this;
      },
      remove: function(object) {
        if (arguments.length > 1) {
          for (var i = 0; i < arguments.length; i++) {
            this.remove(arguments[i]);
          }
        }
        ;
        var index = this.children.indexOf(object);
        if (index !== -1) {
          object.parent = undefined;
          object.dispatchEvent({type: 'removed'});
          this.children.splice(index, 1);
        }
      },
      getChildByName: function(name) {
        THREE.warn('THREE.Object3D: .getChildByName() has been renamed to .getObjectByName().');
        return this.getObjectByName(name);
      },
      getObjectById: function(id) {
        return this.getObjectByProperty('id', id);
      },
      getObjectByName: function(name) {
        return this.getObjectByProperty('name', name);
      },
      getObjectByProperty: function(name, value) {
        if (this[name] === value)
          return this;
        for (var i = 0,
            l = this.children.length; i < l; i++) {
          var child = this.children[i];
          var object = child.getObjectByProperty(name, value);
          if (object !== undefined) {
            return object;
          }
        }
        return undefined;
      },
      getWorldPosition: function(optionalTarget) {
        var result = optionalTarget || new THREE.Vector3();
        this.updateMatrixWorld(true);
        return result.setFromMatrixPosition(this.matrixWorld);
      },
      getWorldQuaternion: function() {
        var position = new THREE.Vector3();
        var scale = new THREE.Vector3();
        return function(optionalTarget) {
          var result = optionalTarget || new THREE.Quaternion();
          this.updateMatrixWorld(true);
          this.matrixWorld.decompose(position, result, scale);
          return result;
        };
      }(),
      getWorldRotation: function() {
        var quaternion = new THREE.Quaternion();
        return function(optionalTarget) {
          var result = optionalTarget || new THREE.Euler();
          this.getWorldQuaternion(quaternion);
          return result.setFromQuaternion(quaternion, this.rotation.order, false);
        };
      }(),
      getWorldScale: function() {
        var position = new THREE.Vector3();
        var quaternion = new THREE.Quaternion();
        return function(optionalTarget) {
          var result = optionalTarget || new THREE.Vector3();
          this.updateMatrixWorld(true);
          this.matrixWorld.decompose(position, quaternion, result);
          return result;
        };
      }(),
      getWorldDirection: function() {
        var quaternion = new THREE.Quaternion();
        return function(optionalTarget) {
          var result = optionalTarget || new THREE.Vector3();
          this.getWorldQuaternion(quaternion);
          return result.set(0, 0, 1).applyQuaternion(quaternion);
        };
      }(),
      raycast: function() {},
      traverse: function(callback) {
        callback(this);
        for (var i = 0,
            l = this.children.length; i < l; i++) {
          this.children[i].traverse(callback);
        }
      },
      traverseVisible: function(callback) {
        if (this.visible === false)
          return ;
        callback(this);
        for (var i = 0,
            l = this.children.length; i < l; i++) {
          this.children[i].traverseVisible(callback);
        }
      },
      traverseAncestors: function(callback) {
        if (this.parent) {
          callback(this.parent);
          this.parent.traverseAncestors(callback);
        }
      },
      updateMatrix: function() {
        this.matrix.compose(this.position, this.quaternion, this.scale);
        this.matrixWorldNeedsUpdate = true;
      },
      updateMatrixWorld: function(force) {
        if (this.matrixAutoUpdate === true)
          this.updateMatrix();
        if (this.matrixWorldNeedsUpdate === true || force === true) {
          if (this.parent === undefined) {
            this.matrixWorld.copy(this.matrix);
          } else {
            this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix);
          }
          this.matrixWorldNeedsUpdate = false;
          force = true;
        }
        for (var i = 0,
            l = this.children.length; i < l; i++) {
          this.children[i].updateMatrixWorld(force);
        }
      },
      toJSON: function() {
        var output = {metadata: {
            version: 4.3,
            type: 'Object',
            generator: 'ObjectExporter'
          }};
        var geometries = {};
        var parseGeometry = function(geometry) {
          if (output.geometries === undefined) {
            output.geometries = [];
          }
          if (geometries[geometry.uuid] === undefined) {
            var json = geometry.toJSON();
            delete json.metadata;
            geometries[geometry.uuid] = json;
            output.geometries.push(json);
          }
          return geometry.uuid;
        };
        var materials = {};
        var parseMaterial = function(material) {
          if (output.materials === undefined) {
            output.materials = [];
          }
          if (materials[material.uuid] === undefined) {
            var json = material.toJSON();
            delete json.metadata;
            materials[material.uuid] = json;
            output.materials.push(json);
          }
          return material.uuid;
        };
        var parseObject = function(object) {
          var data = {};
          data.uuid = object.uuid;
          data.type = object.type;
          if (object.name !== '')
            data.name = object.name;
          if (JSON.stringify(object.userData) !== '{}')
            data.userData = object.userData;
          if (object.visible !== true)
            data.visible = object.visible;
          if (object instanceof THREE.PerspectiveCamera) {
            data.fov = object.fov;
            data.aspect = object.aspect;
            data.near = object.near;
            data.far = object.far;
          } else if (object instanceof THREE.OrthographicCamera) {
            data.left = object.left;
            data.right = object.right;
            data.top = object.top;
            data.bottom = object.bottom;
            data.near = object.near;
            data.far = object.far;
          } else if (object instanceof THREE.AmbientLight) {
            data.color = object.color.getHex();
          } else if (object instanceof THREE.DirectionalLight) {
            data.color = object.color.getHex();
            data.intensity = object.intensity;
          } else if (object instanceof THREE.PointLight) {
            data.color = object.color.getHex();
            data.intensity = object.intensity;
            data.distance = object.distance;
            data.decay = object.decay;
          } else if (object instanceof THREE.SpotLight) {
            data.color = object.color.getHex();
            data.intensity = object.intensity;
            data.distance = object.distance;
            data.angle = object.angle;
            data.exponent = object.exponent;
            data.decay = object.decay;
          } else if (object instanceof THREE.HemisphereLight) {
            data.color = object.color.getHex();
            data.groundColor = object.groundColor.getHex();
          } else if (object instanceof THREE.Mesh || object instanceof THREE.Line || object instanceof THREE.PointCloud) {
            data.geometry = parseGeometry(object.geometry);
            data.material = parseMaterial(object.material);
            if (object instanceof THREE.Line)
              data.mode = object.mode;
          } else if (object instanceof THREE.Sprite) {
            data.material = parseMaterial(object.material);
          }
          data.matrix = object.matrix.toArray();
          if (object.children.length > 0) {
            data.children = [];
            for (var i = 0; i < object.children.length; i++) {
              data.children.push(parseObject(object.children[i]));
            }
          }
          return data;
        };
        output.object = parseObject(this);
        return output;
      },
      clone: function(object, recursive) {
        if (object === undefined)
          object = new THREE.Object3D();
        if (recursive === undefined)
          recursive = true;
        object.name = this.name;
        object.up.copy(this.up);
        object.position.copy(this.position);
        object.quaternion.copy(this.quaternion);
        object.scale.copy(this.scale);
        object.rotationAutoUpdate = this.rotationAutoUpdate;
        object.matrix.copy(this.matrix);
        object.matrixWorld.copy(this.matrixWorld);
        object.matrixAutoUpdate = this.matrixAutoUpdate;
        object.matrixWorldNeedsUpdate = this.matrixWorldNeedsUpdate;
        object.visible = this.visible;
        object.castShadow = this.castShadow;
        object.receiveShadow = this.receiveShadow;
        object.frustumCulled = this.frustumCulled;
        object.userData = JSON.parse(JSON.stringify(this.userData));
        if (recursive === true) {
          for (var i = 0; i < this.children.length; i++) {
            var child = this.children[i];
            object.add(child.clone());
          }
        }
        return object;
      }
    };
    THREE.EventDispatcher.prototype.apply(THREE.Object3D.prototype);
    THREE.Object3DIdCount = 0;
    THREE.Face3 = function(a, b, c, normal, color, materialIndex) {
      this.a = a;
      this.b = b;
      this.c = c;
      this.normal = normal instanceof THREE.Vector3 ? normal : new THREE.Vector3();
      this.vertexNormals = normal instanceof Array ? normal : [];
      this.color = color instanceof THREE.Color ? color : new THREE.Color();
      this.vertexColors = color instanceof Array ? color : [];
      this.vertexTangents = [];
      this.materialIndex = materialIndex !== undefined ? materialIndex : 0;
    };
    THREE.Face3.prototype = {
      constructor: THREE.Face3,
      clone: function() {
        var face = new THREE.Face3(this.a, this.b, this.c);
        face.normal.copy(this.normal);
        face.color.copy(this.color);
        face.materialIndex = this.materialIndex;
        for (var i = 0,
            il = this.vertexNormals.length; i < il; i++) {
          face.vertexNormals[i] = this.vertexNormals[i].clone();
        }
        for (var i = 0,
            il = this.vertexColors.length; i < il; i++) {
          face.vertexColors[i] = this.vertexColors[i].clone();
        }
        for (var i = 0,
            il = this.vertexTangents.length; i < il; i++) {
          face.vertexTangents[i] = this.vertexTangents[i].clone();
        }
        return face;
      }
    };
    THREE.Face4 = function(a, b, c, d, normal, color, materialIndex) {
      THREE.warn('THREE.Face4 has been removed. A THREE.Face3 will be created instead.');
      return new THREE.Face3(a, b, c, normal, color, materialIndex);
    };
    THREE.BufferAttribute = function(array, itemSize) {
      this.array = array;
      this.itemSize = itemSize;
      this.needsUpdate = false;
    };
    THREE.BufferAttribute.prototype = {
      constructor: THREE.BufferAttribute,
      get length() {
        return this.array.length;
      },
      copyAt: function(index1, attribute, index2) {
        index1 *= this.itemSize;
        index2 *= attribute.itemSize;
        for (var i = 0,
            l = this.itemSize; i < l; i++) {
          this.array[index1 + i] = attribute.array[index2 + i];
        }
        return this;
      },
      set: function(value, offset) {
        if (offset === undefined)
          offset = 0;
        this.array.set(value, offset);
        return this;
      },
      setX: function(index, x) {
        this.array[index * this.itemSize] = x;
        return this;
      },
      setY: function(index, y) {
        this.array[index * this.itemSize + 1] = y;
        return this;
      },
      setZ: function(index, z) {
        this.array[index * this.itemSize + 2] = z;
        return this;
      },
      setXY: function(index, x, y) {
        index *= this.itemSize;
        this.array[index] = x;
        this.array[index + 1] = y;
        return this;
      },
      setXYZ: function(index, x, y, z) {
        index *= this.itemSize;
        this.array[index] = x;
        this.array[index + 1] = y;
        this.array[index + 2] = z;
        return this;
      },
      setXYZW: function(index, x, y, z, w) {
        index *= this.itemSize;
        this.array[index] = x;
        this.array[index + 1] = y;
        this.array[index + 2] = z;
        this.array[index + 3] = w;
        return this;
      },
      clone: function() {
        return new THREE.BufferAttribute(new this.array.constructor(this.array), this.itemSize);
      }
    };
    THREE.Int8Attribute = function(data, itemSize) {
      THREE.warn('THREE.Int8Attribute has been removed. Use THREE.BufferAttribute( array, itemSize ) instead.');
      return new THREE.BufferAttribute(data, itemSize);
    };
    THREE.Uint8Attribute = function(data, itemSize) {
      THREE.warn('THREE.Uint8Attribute has been removed. Use THREE.BufferAttribute( array, itemSize ) instead.');
      return new THREE.BufferAttribute(data, itemSize);
    };
    THREE.Uint8ClampedAttribute = function(data, itemSize) {
      THREE.warn('THREE.Uint8ClampedAttribute has been removed. Use THREE.BufferAttribute( array, itemSize ) instead.');
      return new THREE.BufferAttribute(data, itemSize);
    };
    THREE.Int16Attribute = function(data, itemSize) {
      THREE.warn('THREE.Int16Attribute has been removed. Use THREE.BufferAttribute( array, itemSize ) instead.');
      return new THREE.BufferAttribute(data, itemSize);
    };
    THREE.Uint16Attribute = function(data, itemSize) {
      THREE.warn('THREE.Uint16Attribute has been removed. Use THREE.BufferAttribute( array, itemSize ) instead.');
      return new THREE.BufferAttribute(data, itemSize);
    };
    THREE.Int32Attribute = function(data, itemSize) {
      THREE.warn('THREE.Int32Attribute has been removed. Use THREE.BufferAttribute( array, itemSize ) instead.');
      return new THREE.BufferAttribute(data, itemSize);
    };
    THREE.Uint32Attribute = function(data, itemSize) {
      THREE.warn('THREE.Uint32Attribute has been removed. Use THREE.BufferAttribute( array, itemSize ) instead.');
      return new THREE.BufferAttribute(data, itemSize);
    };
    THREE.Float32Attribute = function(data, itemSize) {
      THREE.warn('THREE.Float32Attribute has been removed. Use THREE.BufferAttribute( array, itemSize ) instead.');
      return new THREE.BufferAttribute(data, itemSize);
    };
    THREE.Float64Attribute = function(data, itemSize) {
      THREE.warn('THREE.Float64Attribute has been removed. Use THREE.BufferAttribute( array, itemSize ) instead.');
      return new THREE.BufferAttribute(data, itemSize);
    };
    THREE.DynamicBufferAttribute = function(array, itemSize) {
      THREE.BufferAttribute.call(this, array, itemSize);
      this.updateRange = {
        offset: 0,
        count: -1
      };
    };
    THREE.DynamicBufferAttribute.prototype = Object.create(THREE.BufferAttribute.prototype);
    THREE.DynamicBufferAttribute.prototype.constructor = THREE.DynamicBufferAttribute;
    THREE.DynamicBufferAttribute.prototype.clone = function() {
      return new THREE.DynamicBufferAttribute(new this.array.constructor(this.array), this.itemSize);
    };
    THREE.BufferGeometry = function() {
      Object.defineProperty(this, 'id', {value: THREE.GeometryIdCount++});
      this.uuid = THREE.Math.generateUUID();
      this.name = '';
      this.type = 'BufferGeometry';
      this.attributes = {};
      this.attributesKeys = [];
      this.drawcalls = [];
      this.offsets = this.drawcalls;
      this.boundingBox = null;
      this.boundingSphere = null;
    };
    THREE.BufferGeometry.prototype = {
      constructor: THREE.BufferGeometry,
      addAttribute: function(name, attribute) {
        if (attribute instanceof THREE.BufferAttribute === false) {
          THREE.warn('THREE.BufferGeometry: .addAttribute() now expects ( name, attribute ).');
          this.attributes[name] = {
            array: arguments[1],
            itemSize: arguments[2]
          };
          return ;
        }
        this.attributes[name] = attribute;
        this.attributesKeys = Object.keys(this.attributes);
      },
      getAttribute: function(name) {
        return this.attributes[name];
      },
      addDrawCall: function(start, count, indexOffset) {
        this.drawcalls.push({
          start: start,
          count: count,
          index: indexOffset !== undefined ? indexOffset : 0
        });
      },
      applyMatrix: function(matrix) {
        var position = this.attributes.position;
        if (position !== undefined) {
          matrix.applyToVector3Array(position.array);
          position.needsUpdate = true;
        }
        var normal = this.attributes.normal;
        if (normal !== undefined) {
          var normalMatrix = new THREE.Matrix3().getNormalMatrix(matrix);
          normalMatrix.applyToVector3Array(normal.array);
          normal.needsUpdate = true;
        }
        if (this.boundingBox !== null) {
          this.computeBoundingBox();
        }
        if (this.boundingSphere !== null) {
          this.computeBoundingSphere();
        }
      },
      center: function() {
        this.computeBoundingBox();
        var offset = this.boundingBox.center().negate();
        this.applyMatrix(new THREE.Matrix4().setPosition(offset));
        return offset;
      },
      fromGeometry: function(geometry, settings) {
        settings = settings || {'vertexColors': THREE.NoColors};
        var vertices = geometry.vertices;
        var faces = geometry.faces;
        var faceVertexUvs = geometry.faceVertexUvs;
        var vertexColors = settings.vertexColors;
        var hasFaceVertexUv = faceVertexUvs[0].length > 0;
        var hasFaceVertexNormals = faces[0].vertexNormals.length == 3;
        var positions = new Float32Array(faces.length * 3 * 3);
        this.addAttribute('position', new THREE.BufferAttribute(positions, 3));
        var normals = new Float32Array(faces.length * 3 * 3);
        this.addAttribute('normal', new THREE.BufferAttribute(normals, 3));
        if (vertexColors !== THREE.NoColors) {
          var colors = new Float32Array(faces.length * 3 * 3);
          this.addAttribute('color', new THREE.BufferAttribute(colors, 3));
        }
        if (hasFaceVertexUv === true) {
          var uvs = new Float32Array(faces.length * 3 * 2);
          this.addAttribute('uv', new THREE.BufferAttribute(uvs, 2));
        }
        for (var i = 0,
            i2 = 0,
            i3 = 0; i < faces.length; i++, i2 += 6, i3 += 9) {
          var face = faces[i];
          var a = vertices[face.a];
          var b = vertices[face.b];
          var c = vertices[face.c];
          positions[i3] = a.x;
          positions[i3 + 1] = a.y;
          positions[i3 + 2] = a.z;
          positions[i3 + 3] = b.x;
          positions[i3 + 4] = b.y;
          positions[i3 + 5] = b.z;
          positions[i3 + 6] = c.x;
          positions[i3 + 7] = c.y;
          positions[i3 + 8] = c.z;
          if (hasFaceVertexNormals === true) {
            var na = face.vertexNormals[0];
            var nb = face.vertexNormals[1];
            var nc = face.vertexNormals[2];
            normals[i3] = na.x;
            normals[i3 + 1] = na.y;
            normals[i3 + 2] = na.z;
            normals[i3 + 3] = nb.x;
            normals[i3 + 4] = nb.y;
            normals[i3 + 5] = nb.z;
            normals[i3 + 6] = nc.x;
            normals[i3 + 7] = nc.y;
            normals[i3 + 8] = nc.z;
          } else {
            var n = face.normal;
            normals[i3] = n.x;
            normals[i3 + 1] = n.y;
            normals[i3 + 2] = n.z;
            normals[i3 + 3] = n.x;
            normals[i3 + 4] = n.y;
            normals[i3 + 5] = n.z;
            normals[i3 + 6] = n.x;
            normals[i3 + 7] = n.y;
            normals[i3 + 8] = n.z;
          }
          if (vertexColors === THREE.FaceColors) {
            var fc = face.color;
            colors[i3] = fc.r;
            colors[i3 + 1] = fc.g;
            colors[i3 + 2] = fc.b;
            colors[i3 + 3] = fc.r;
            colors[i3 + 4] = fc.g;
            colors[i3 + 5] = fc.b;
            colors[i3 + 6] = fc.r;
            colors[i3 + 7] = fc.g;
            colors[i3 + 8] = fc.b;
          } else if (vertexColors === THREE.VertexColors) {
            var vca = face.vertexColors[0];
            var vcb = face.vertexColors[1];
            var vcc = face.vertexColors[2];
            colors[i3] = vca.r;
            colors[i3 + 1] = vca.g;
            colors[i3 + 2] = vca.b;
            colors[i3 + 3] = vcb.r;
            colors[i3 + 4] = vcb.g;
            colors[i3 + 5] = vcb.b;
            colors[i3 + 6] = vcc.r;
            colors[i3 + 7] = vcc.g;
            colors[i3 + 8] = vcc.b;
          }
          if (hasFaceVertexUv === true) {
            var uva = faceVertexUvs[0][i][0];
            var uvb = faceVertexUvs[0][i][1];
            var uvc = faceVertexUvs[0][i][2];
            uvs[i2] = uva.x;
            uvs[i2 + 1] = uva.y;
            uvs[i2 + 2] = uvb.x;
            uvs[i2 + 3] = uvb.y;
            uvs[i2 + 4] = uvc.x;
            uvs[i2 + 5] = uvc.y;
          }
        }
        this.computeBoundingSphere();
        return this;
      },
      computeBoundingBox: function() {
        var vector = new THREE.Vector3();
        return function() {
          if (this.boundingBox === null) {
            this.boundingBox = new THREE.Box3();
          }
          var positions = this.attributes.position.array;
          if (positions) {
            var bb = this.boundingBox;
            bb.makeEmpty();
            for (var i = 0,
                il = positions.length; i < il; i += 3) {
              vector.set(positions[i], positions[i + 1], positions[i + 2]);
              bb.expandByPoint(vector);
            }
          }
          if (positions === undefined || positions.length === 0) {
            this.boundingBox.min.set(0, 0, 0);
            this.boundingBox.max.set(0, 0, 0);
          }
          if (isNaN(this.boundingBox.min.x) || isNaN(this.boundingBox.min.y) || isNaN(this.boundingBox.min.z)) {
            THREE.error('THREE.BufferGeometry.computeBoundingBox: Computed min/max have NaN values. The "position" attribute is likely to have NaN values.');
          }
        };
      }(),
      computeBoundingSphere: function() {
        var box = new THREE.Box3();
        var vector = new THREE.Vector3();
        return function() {
          if (this.boundingSphere === null) {
            this.boundingSphere = new THREE.Sphere();
          }
          var positions = this.attributes.position.array;
          if (positions) {
            box.makeEmpty();
            var center = this.boundingSphere.center;
            for (var i = 0,
                il = positions.length; i < il; i += 3) {
              vector.set(positions[i], positions[i + 1], positions[i + 2]);
              box.expandByPoint(vector);
            }
            box.center(center);
            var maxRadiusSq = 0;
            for (var i = 0,
                il = positions.length; i < il; i += 3) {
              vector.set(positions[i], positions[i + 1], positions[i + 2]);
              maxRadiusSq = Math.max(maxRadiusSq, center.distanceToSquared(vector));
            }
            this.boundingSphere.radius = Math.sqrt(maxRadiusSq);
            if (isNaN(this.boundingSphere.radius)) {
              THREE.error('THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.');
            }
          }
        };
      }(),
      computeFaceNormals: function() {},
      computeVertexNormals: function() {
        var attributes = this.attributes;
        if (attributes.position) {
          var positions = attributes.position.array;
          if (attributes.normal === undefined) {
            this.addAttribute('normal', new THREE.BufferAttribute(new Float32Array(positions.length), 3));
          } else {
            var normals = attributes.normal.array;
            for (var i = 0,
                il = normals.length; i < il; i++) {
              normals[i] = 0;
            }
          }
          var normals = attributes.normal.array;
          var vA,
              vB,
              vC,
              pA = new THREE.Vector3(),
              pB = new THREE.Vector3(),
              pC = new THREE.Vector3(),
              cb = new THREE.Vector3(),
              ab = new THREE.Vector3();
          if (attributes.index) {
            var indices = attributes.index.array;
            var offsets = (this.offsets.length > 0 ? this.offsets : [{
              start: 0,
              count: indices.length,
              index: 0
            }]);
            for (var j = 0,
                jl = offsets.length; j < jl; ++j) {
              var start = offsets[j].start;
              var count = offsets[j].count;
              var index = offsets[j].index;
              for (var i = start,
                  il = start + count; i < il; i += 3) {
                vA = (index + indices[i]) * 3;
                vB = (index + indices[i + 1]) * 3;
                vC = (index + indices[i + 2]) * 3;
                pA.fromArray(positions, vA);
                pB.fromArray(positions, vB);
                pC.fromArray(positions, vC);
                cb.subVectors(pC, pB);
                ab.subVectors(pA, pB);
                cb.cross(ab);
                normals[vA] += cb.x;
                normals[vA + 1] += cb.y;
                normals[vA + 2] += cb.z;
                normals[vB] += cb.x;
                normals[vB + 1] += cb.y;
                normals[vB + 2] += cb.z;
                normals[vC] += cb.x;
                normals[vC + 1] += cb.y;
                normals[vC + 2] += cb.z;
              }
            }
          } else {
            for (var i = 0,
                il = positions.length; i < il; i += 9) {
              pA.fromArray(positions, i);
              pB.fromArray(positions, i + 3);
              pC.fromArray(positions, i + 6);
              cb.subVectors(pC, pB);
              ab.subVectors(pA, pB);
              cb.cross(ab);
              normals[i] = cb.x;
              normals[i + 1] = cb.y;
              normals[i + 2] = cb.z;
              normals[i + 3] = cb.x;
              normals[i + 4] = cb.y;
              normals[i + 5] = cb.z;
              normals[i + 6] = cb.x;
              normals[i + 7] = cb.y;
              normals[i + 8] = cb.z;
            }
          }
          this.normalizeNormals();
          attributes.normal.needsUpdate = true;
        }
      },
      computeTangents: function() {
        if (this.attributes.index === undefined || this.attributes.position === undefined || this.attributes.normal === undefined || this.attributes.uv === undefined) {
          THREE.warn('THREE.BufferGeometry: Missing required attributes (index, position, normal or uv) in BufferGeometry.computeTangents()');
          return ;
        }
        var indices = this.attributes.index.array;
        var positions = this.attributes.position.array;
        var normals = this.attributes.normal.array;
        var uvs = this.attributes.uv.array;
        var nVertices = positions.length / 3;
        if (this.attributes.tangent === undefined) {
          this.addAttribute('tangent', new THREE.BufferAttribute(new Float32Array(4 * nVertices), 4));
        }
        var tangents = this.attributes.tangent.array;
        var tan1 = [],
            tan2 = [];
        for (var k = 0; k < nVertices; k++) {
          tan1[k] = new THREE.Vector3();
          tan2[k] = new THREE.Vector3();
        }
        var vA = new THREE.Vector3(),
            vB = new THREE.Vector3(),
            vC = new THREE.Vector3(),
            uvA = new THREE.Vector2(),
            uvB = new THREE.Vector2(),
            uvC = new THREE.Vector2(),
            x1,
            x2,
            y1,
            y2,
            z1,
            z2,
            s1,
            s2,
            t1,
            t2,
            r;
        var sdir = new THREE.Vector3(),
            tdir = new THREE.Vector3();
        function handleTriangle(a, b, c) {
          vA.fromArray(positions, a * 3);
          vB.fromArray(positions, b * 3);
          vC.fromArray(positions, c * 3);
          uvA.fromArray(uvs, a * 2);
          uvB.fromArray(uvs, b * 2);
          uvC.fromArray(uvs, c * 2);
          x1 = vB.x - vA.x;
          x2 = vC.x - vA.x;
          y1 = vB.y - vA.y;
          y2 = vC.y - vA.y;
          z1 = vB.z - vA.z;
          z2 = vC.z - vA.z;
          s1 = uvB.x - uvA.x;
          s2 = uvC.x - uvA.x;
          t1 = uvB.y - uvA.y;
          t2 = uvC.y - uvA.y;
          r = 1.0 / (s1 * t2 - s2 * t1);
          sdir.set((t2 * x1 - t1 * x2) * r, (t2 * y1 - t1 * y2) * r, (t2 * z1 - t1 * z2) * r);
          tdir.set((s1 * x2 - s2 * x1) * r, (s1 * y2 - s2 * y1) * r, (s1 * z2 - s2 * z1) * r);
          tan1[a].add(sdir);
          tan1[b].add(sdir);
          tan1[c].add(sdir);
          tan2[a].add(tdir);
          tan2[b].add(tdir);
          tan2[c].add(tdir);
        }
        var i,
            il;
        var j,
            jl;
        var iA,
            iB,
            iC;
        if (this.drawcalls.length === 0) {
          this.addDrawCall(0, indices.length, 0);
        }
        var drawcalls = this.drawcalls;
        for (j = 0, jl = drawcalls.length; j < jl; ++j) {
          var start = drawcalls[j].start;
          var count = drawcalls[j].count;
          var index = drawcalls[j].index;
          for (i = start, il = start + count; i < il; i += 3) {
            iA = index + indices[i];
            iB = index + indices[i + 1];
            iC = index + indices[i + 2];
            handleTriangle(iA, iB, iC);
          }
        }
        var tmp = new THREE.Vector3(),
            tmp2 = new THREE.Vector3();
        var n = new THREE.Vector3(),
            n2 = new THREE.Vector3();
        var w,
            t,
            test;
        function handleVertex(v) {
          n.fromArray(normals, v * 3);
          n2.copy(n);
          t = tan1[v];
          tmp.copy(t);
          tmp.sub(n.multiplyScalar(n.dot(t))).normalize();
          tmp2.crossVectors(n2, t);
          test = tmp2.dot(tan2[v]);
          w = (test < 0.0) ? -1.0 : 1.0;
          tangents[v * 4] = tmp.x;
          tangents[v * 4 + 1] = tmp.y;
          tangents[v * 4 + 2] = tmp.z;
          tangents[v * 4 + 3] = w;
        }
        for (j = 0, jl = drawcalls.length; j < jl; ++j) {
          var start = drawcalls[j].start;
          var count = drawcalls[j].count;
          var index = drawcalls[j].index;
          for (i = start, il = start + count; i < il; i += 3) {
            iA = index + indices[i];
            iB = index + indices[i + 1];
            iC = index + indices[i + 2];
            handleVertex(iA);
            handleVertex(iB);
            handleVertex(iC);
          }
        }
      },
      computeOffsets: function(size) {
        if (size === undefined)
          size = 65535;
        var indices = this.attributes.index.array;
        var vertices = this.attributes.position.array;
        var facesCount = (indices.length / 3);
        var sortedIndices = new Uint16Array(indices.length);
        var indexPtr = 0;
        var vertexPtr = 0;
        var offsets = [{
          start: 0,
          count: 0,
          index: 0
        }];
        var offset = offsets[0];
        var duplicatedVertices = 0;
        var newVerticeMaps = 0;
        var faceVertices = new Int32Array(6);
        var vertexMap = new Int32Array(vertices.length);
        var revVertexMap = new Int32Array(vertices.length);
        for (var j = 0; j < vertices.length; j++) {
          vertexMap[j] = -1;
          revVertexMap[j] = -1;
        }
        for (var findex = 0; findex < facesCount; findex++) {
          newVerticeMaps = 0;
          for (var vo = 0; vo < 3; vo++) {
            var vid = indices[findex * 3 + vo];
            if (vertexMap[vid] == -1) {
              faceVertices[vo * 2] = vid;
              faceVertices[vo * 2 + 1] = -1;
              newVerticeMaps++;
            } else if (vertexMap[vid] < offset.index) {
              faceVertices[vo * 2] = vid;
              faceVertices[vo * 2 + 1] = -1;
              duplicatedVertices++;
            } else {
              faceVertices[vo * 2] = vid;
              faceVertices[vo * 2 + 1] = vertexMap[vid];
            }
          }
          var faceMax = vertexPtr + newVerticeMaps;
          if (faceMax > (offset.index + size)) {
            var new_offset = {
              start: indexPtr,
              count: 0,
              index: vertexPtr
            };
            offsets.push(new_offset);
            offset = new_offset;
            for (var v = 0; v < 6; v += 2) {
              var new_vid = faceVertices[v + 1];
              if (new_vid > -1 && new_vid < offset.index)
                faceVertices[v + 1] = -1;
            }
          }
          for (var v = 0; v < 6; v += 2) {
            var vid = faceVertices[v];
            var new_vid = faceVertices[v + 1];
            if (new_vid === -1)
              new_vid = vertexPtr++;
            vertexMap[vid] = new_vid;
            revVertexMap[new_vid] = vid;
            sortedIndices[indexPtr++] = new_vid - offset.index;
            offset.count++;
          }
        }
        this.reorderBuffers(sortedIndices, revVertexMap, vertexPtr);
        this.offsets = offsets;
        this.drawcalls = offsets;
        return offsets;
      },
      merge: function(geometry, offset) {
        if (geometry instanceof THREE.BufferGeometry === false) {
          THREE.error('THREE.BufferGeometry.merge(): geometry not an instance of THREE.BufferGeometry.', geometry);
          return ;
        }
        if (offset === undefined)
          offset = 0;
        var attributes = this.attributes;
        for (var key in attributes) {
          if (geometry.attributes[key] === undefined)
            continue;
          var attribute1 = attributes[key];
          var attributeArray1 = attribute1.array;
          var attribute2 = geometry.attributes[key];
          var attributeArray2 = attribute2.array;
          var attributeSize = attribute2.itemSize;
          for (var i = 0,
              j = attributeSize * offset; i < attributeArray2.length; i++, j++) {
            attributeArray1[j] = attributeArray2[i];
          }
        }
        return this;
      },
      normalizeNormals: function() {
        var normals = this.attributes.normal.array;
        var x,
            y,
            z,
            n;
        for (var i = 0,
            il = normals.length; i < il; i += 3) {
          x = normals[i];
          y = normals[i + 1];
          z = normals[i + 2];
          n = 1.0 / Math.sqrt(x * x + y * y + z * z);
          normals[i] *= n;
          normals[i + 1] *= n;
          normals[i + 2] *= n;
        }
      },
      reorderBuffers: function(indexBuffer, indexMap, vertexCount) {
        var sortedAttributes = {};
        for (var attr in this.attributes) {
          if (attr == 'index')
            continue;
          var sourceArray = this.attributes[attr].array;
          sortedAttributes[attr] = new sourceArray.constructor(this.attributes[attr].itemSize * vertexCount);
        }
        for (var new_vid = 0; new_vid < vertexCount; new_vid++) {
          var vid = indexMap[new_vid];
          for (var attr in this.attributes) {
            if (attr == 'index')
              continue;
            var attrArray = this.attributes[attr].array;
            var attrSize = this.attributes[attr].itemSize;
            var sortedAttr = sortedAttributes[attr];
            for (var k = 0; k < attrSize; k++)
              sortedAttr[new_vid * attrSize + k] = attrArray[vid * attrSize + k];
          }
        }
        this.attributes['index'].array = indexBuffer;
        for (var attr in this.attributes) {
          if (attr == 'index')
            continue;
          this.attributes[attr].array = sortedAttributes[attr];
          this.attributes[attr].numItems = this.attributes[attr].itemSize * vertexCount;
        }
      },
      toJSON: function() {
        var output = {
          metadata: {
            version: 4.0,
            type: 'BufferGeometry',
            generator: 'BufferGeometryExporter'
          },
          uuid: this.uuid,
          type: this.type,
          data: {attributes: {}}
        };
        var attributes = this.attributes;
        var offsets = this.offsets;
        var boundingSphere = this.boundingSphere;
        for (var key in attributes) {
          var attribute = attributes[key];
          var array = Array.prototype.slice.call(attribute.array);
          output.data.attributes[key] = {
            itemSize: attribute.itemSize,
            type: attribute.array.constructor.name,
            array: array
          };
        }
        if (offsets.length > 0) {
          output.data.offsets = JSON.parse(JSON.stringify(offsets));
        }
        if (boundingSphere !== null) {
          output.data.boundingSphere = {
            center: boundingSphere.center.toArray(),
            radius: boundingSphere.radius
          };
        }
        return output;
      },
      clone: function() {
        var geometry = new THREE.BufferGeometry();
        for (var attr in this.attributes) {
          var sourceAttr = this.attributes[attr];
          geometry.addAttribute(attr, sourceAttr.clone());
        }
        for (var i = 0,
            il = this.offsets.length; i < il; i++) {
          var offset = this.offsets[i];
          geometry.offsets.push({
            start: offset.start,
            index: offset.index,
            count: offset.count
          });
        }
        return geometry;
      },
      dispose: function() {
        this.dispatchEvent({type: 'dispose'});
      }
    };
    THREE.EventDispatcher.prototype.apply(THREE.BufferGeometry.prototype);
    THREE.Geometry = function() {
      Object.defineProperty(this, 'id', {value: THREE.GeometryIdCount++});
      this.uuid = THREE.Math.generateUUID();
      this.name = '';
      this.type = 'Geometry';
      this.vertices = [];
      this.colors = [];
      this.faces = [];
      this.faceVertexUvs = [[]];
      this.morphTargets = [];
      this.morphColors = [];
      this.morphNormals = [];
      this.skinWeights = [];
      this.skinIndices = [];
      this.lineDistances = [];
      this.boundingBox = null;
      this.boundingSphere = null;
      this.hasTangents = false;
      this.dynamic = true;
      this.verticesNeedUpdate = false;
      this.elementsNeedUpdate = false;
      this.uvsNeedUpdate = false;
      this.normalsNeedUpdate = false;
      this.tangentsNeedUpdate = false;
      this.colorsNeedUpdate = false;
      this.lineDistancesNeedUpdate = false;
      this.groupsNeedUpdate = false;
    };
    THREE.Geometry.prototype = {
      constructor: THREE.Geometry,
      applyMatrix: function(matrix) {
        var normalMatrix = new THREE.Matrix3().getNormalMatrix(matrix);
        for (var i = 0,
            il = this.vertices.length; i < il; i++) {
          var vertex = this.vertices[i];
          vertex.applyMatrix4(matrix);
        }
        for (var i = 0,
            il = this.faces.length; i < il; i++) {
          var face = this.faces[i];
          face.normal.applyMatrix3(normalMatrix).normalize();
          for (var j = 0,
              jl = face.vertexNormals.length; j < jl; j++) {
            face.vertexNormals[j].applyMatrix3(normalMatrix).normalize();
          }
        }
        if (this.boundingBox !== null) {
          this.computeBoundingBox();
        }
        if (this.boundingSphere !== null) {
          this.computeBoundingSphere();
        }
        this.verticesNeedUpdate = true;
        this.normalsNeedUpdate = true;
      },
      fromBufferGeometry: function(geometry) {
        var scope = this;
        var attributes = geometry.attributes;
        var vertices = attributes.position.array;
        var indices = attributes.index !== undefined ? attributes.index.array : undefined;
        var normals = attributes.normal !== undefined ? attributes.normal.array : undefined;
        var colors = attributes.color !== undefined ? attributes.color.array : undefined;
        var uvs = attributes.uv !== undefined ? attributes.uv.array : undefined;
        var tempNormals = [];
        var tempUVs = [];
        for (var i = 0,
            j = 0; i < vertices.length; i += 3, j += 2) {
          scope.vertices.push(new THREE.Vector3(vertices[i], vertices[i + 1], vertices[i + 2]));
          if (normals !== undefined) {
            tempNormals.push(new THREE.Vector3(normals[i], normals[i + 1], normals[i + 2]));
          }
          if (colors !== undefined) {
            scope.colors.push(new THREE.Color(colors[i], colors[i + 1], colors[i + 2]));
          }
          if (uvs !== undefined) {
            tempUVs.push(new THREE.Vector2(uvs[j], uvs[j + 1]));
          }
        }
        var addFace = function(a, b, c) {
          var vertexNormals = normals !== undefined ? [tempNormals[a].clone(), tempNormals[b].clone(), tempNormals[c].clone()] : [];
          var vertexColors = colors !== undefined ? [scope.colors[a].clone(), scope.colors[b].clone(), scope.colors[c].clone()] : [];
          scope.faces.push(new THREE.Face3(a, b, c, vertexNormals, vertexColors));
          if (uvs !== undefined) {
            scope.faceVertexUvs[0].push([tempUVs[a].clone(), tempUVs[b].clone(), tempUVs[c].clone()]);
          }
        };
        if (indices !== undefined) {
          var drawcalls = geometry.drawcalls;
          if (drawcalls.length > 0) {
            for (var i = 0; i < drawcalls.length; i++) {
              var drawcall = drawcalls[i];
              var start = drawcall.start;
              var count = drawcall.count;
              var index = drawcall.index;
              for (var j = start,
                  jl = start + count; j < jl; j += 3) {
                addFace(index + indices[j], index + indices[j + 1], index + indices[j + 2]);
              }
            }
          } else {
            for (var i = 0; i < indices.length; i += 3) {
              addFace(indices[i], indices[i + 1], indices[i + 2]);
            }
          }
        } else {
          for (var i = 0; i < vertices.length / 3; i += 3) {
            addFace(i, i + 1, i + 2);
          }
        }
        this.computeFaceNormals();
        if (geometry.boundingBox !== null) {
          this.boundingBox = geometry.boundingBox.clone();
        }
        if (geometry.boundingSphere !== null) {
          this.boundingSphere = geometry.boundingSphere.clone();
        }
        return this;
      },
      center: function() {
        this.computeBoundingBox();
        var offset = this.boundingBox.center().negate();
        this.applyMatrix(new THREE.Matrix4().setPosition(offset));
        return offset;
      },
      computeFaceNormals: function() {
        var cb = new THREE.Vector3(),
            ab = new THREE.Vector3();
        for (var f = 0,
            fl = this.faces.length; f < fl; f++) {
          var face = this.faces[f];
          var vA = this.vertices[face.a];
          var vB = this.vertices[face.b];
          var vC = this.vertices[face.c];
          cb.subVectors(vC, vB);
          ab.subVectors(vA, vB);
          cb.cross(ab);
          cb.normalize();
          face.normal.copy(cb);
        }
      },
      computeVertexNormals: function(areaWeighted) {
        var v,
            vl,
            f,
            fl,
            face,
            vertices;
        vertices = new Array(this.vertices.length);
        for (v = 0, vl = this.vertices.length; v < vl; v++) {
          vertices[v] = new THREE.Vector3();
        }
        if (areaWeighted) {
          var vA,
              vB,
              vC;
          var cb = new THREE.Vector3(),
              ab = new THREE.Vector3();
          for (f = 0, fl = this.faces.length; f < fl; f++) {
            face = this.faces[f];
            vA = this.vertices[face.a];
            vB = this.vertices[face.b];
            vC = this.vertices[face.c];
            cb.subVectors(vC, vB);
            ab.subVectors(vA, vB);
            cb.cross(ab);
            vertices[face.a].add(cb);
            vertices[face.b].add(cb);
            vertices[face.c].add(cb);
          }
        } else {
          for (f = 0, fl = this.faces.length; f < fl; f++) {
            face = this.faces[f];
            vertices[face.a].add(face.normal);
            vertices[face.b].add(face.normal);
            vertices[face.c].add(face.normal);
          }
        }
        for (v = 0, vl = this.vertices.length; v < vl; v++) {
          vertices[v].normalize();
        }
        for (f = 0, fl = this.faces.length; f < fl; f++) {
          face = this.faces[f];
          face.vertexNormals[0] = vertices[face.a].clone();
          face.vertexNormals[1] = vertices[face.b].clone();
          face.vertexNormals[2] = vertices[face.c].clone();
        }
      },
      computeMorphNormals: function() {
        var i,
            il,
            f,
            fl,
            face;
        for (f = 0, fl = this.faces.length; f < fl; f++) {
          face = this.faces[f];
          if (!face.__originalFaceNormal) {
            face.__originalFaceNormal = face.normal.clone();
          } else {
            face.__originalFaceNormal.copy(face.normal);
          }
          if (!face.__originalVertexNormals)
            face.__originalVertexNormals = [];
          for (i = 0, il = face.vertexNormals.length; i < il; i++) {
            if (!face.__originalVertexNormals[i]) {
              face.__originalVertexNormals[i] = face.vertexNormals[i].clone();
            } else {
              face.__originalVertexNormals[i].copy(face.vertexNormals[i]);
            }
          }
        }
        var tmpGeo = new THREE.Geometry();
        tmpGeo.faces = this.faces;
        for (i = 0, il = this.morphTargets.length; i < il; i++) {
          if (!this.morphNormals[i]) {
            this.morphNormals[i] = {};
            this.morphNormals[i].faceNormals = [];
            this.morphNormals[i].vertexNormals = [];
            var dstNormalsFace = this.morphNormals[i].faceNormals;
            var dstNormalsVertex = this.morphNormals[i].vertexNormals;
            var faceNormal,
                vertexNormals;
            for (f = 0, fl = this.faces.length; f < fl; f++) {
              faceNormal = new THREE.Vector3();
              vertexNormals = {
                a: new THREE.Vector3(),
                b: new THREE.Vector3(),
                c: new THREE.Vector3()
              };
              dstNormalsFace.push(faceNormal);
              dstNormalsVertex.push(vertexNormals);
            }
          }
          var morphNormals = this.morphNormals[i];
          tmpGeo.vertices = this.morphTargets[i].vertices;
          tmpGeo.computeFaceNormals();
          tmpGeo.computeVertexNormals();
          var faceNormal,
              vertexNormals;
          for (f = 0, fl = this.faces.length; f < fl; f++) {
            face = this.faces[f];
            faceNormal = morphNormals.faceNormals[f];
            vertexNormals = morphNormals.vertexNormals[f];
            faceNormal.copy(face.normal);
            vertexNormals.a.copy(face.vertexNormals[0]);
            vertexNormals.b.copy(face.vertexNormals[1]);
            vertexNormals.c.copy(face.vertexNormals[2]);
          }
        }
        for (f = 0, fl = this.faces.length; f < fl; f++) {
          face = this.faces[f];
          face.normal = face.__originalFaceNormal;
          face.vertexNormals = face.__originalVertexNormals;
        }
      },
      computeTangents: function() {
        var f,
            fl,
            v,
            vl,
            i,
            vertexIndex,
            face,
            uv,
            vA,
            vB,
            vC,
            uvA,
            uvB,
            uvC,
            x1,
            x2,
            y1,
            y2,
            z1,
            z2,
            s1,
            s2,
            t1,
            t2,
            r,
            t,
            test,
            tan1 = [],
            tan2 = [],
            sdir = new THREE.Vector3(),
            tdir = new THREE.Vector3(),
            tmp = new THREE.Vector3(),
            tmp2 = new THREE.Vector3(),
            n = new THREE.Vector3(),
            w;
        for (v = 0, vl = this.vertices.length; v < vl; v++) {
          tan1[v] = new THREE.Vector3();
          tan2[v] = new THREE.Vector3();
        }
        function handleTriangle(context, a, b, c, ua, ub, uc) {
          vA = context.vertices[a];
          vB = context.vertices[b];
          vC = context.vertices[c];
          uvA = uv[ua];
          uvB = uv[ub];
          uvC = uv[uc];
          x1 = vB.x - vA.x;
          x2 = vC.x - vA.x;
          y1 = vB.y - vA.y;
          y2 = vC.y - vA.y;
          z1 = vB.z - vA.z;
          z2 = vC.z - vA.z;
          s1 = uvB.x - uvA.x;
          s2 = uvC.x - uvA.x;
          t1 = uvB.y - uvA.y;
          t2 = uvC.y - uvA.y;
          r = 1.0 / (s1 * t2 - s2 * t1);
          sdir.set((t2 * x1 - t1 * x2) * r, (t2 * y1 - t1 * y2) * r, (t2 * z1 - t1 * z2) * r);
          tdir.set((s1 * x2 - s2 * x1) * r, (s1 * y2 - s2 * y1) * r, (s1 * z2 - s2 * z1) * r);
          tan1[a].add(sdir);
          tan1[b].add(sdir);
          tan1[c].add(sdir);
          tan2[a].add(tdir);
          tan2[b].add(tdir);
          tan2[c].add(tdir);
        }
        for (f = 0, fl = this.faces.length; f < fl; f++) {
          face = this.faces[f];
          uv = this.faceVertexUvs[0][f];
          handleTriangle(this, face.a, face.b, face.c, 0, 1, 2);
        }
        var faceIndex = ['a', 'b', 'c', 'd'];
        for (f = 0, fl = this.faces.length; f < fl; f++) {
          face = this.faces[f];
          for (i = 0; i < Math.min(face.vertexNormals.length, 3); i++) {
            n.copy(face.vertexNormals[i]);
            vertexIndex = face[faceIndex[i]];
            t = tan1[vertexIndex];
            tmp.copy(t);
            tmp.sub(n.multiplyScalar(n.dot(t))).normalize();
            tmp2.crossVectors(face.vertexNormals[i], t);
            test = tmp2.dot(tan2[vertexIndex]);
            w = (test < 0.0) ? -1.0 : 1.0;
            face.vertexTangents[i] = new THREE.Vector4(tmp.x, tmp.y, tmp.z, w);
          }
        }
        this.hasTangents = true;
      },
      computeLineDistances: function() {
        var d = 0;
        var vertices = this.vertices;
        for (var i = 0,
            il = vertices.length; i < il; i++) {
          if (i > 0) {
            d += vertices[i].distanceTo(vertices[i - 1]);
          }
          this.lineDistances[i] = d;
        }
      },
      computeBoundingBox: function() {
        if (this.boundingBox === null) {
          this.boundingBox = new THREE.Box3();
        }
        this.boundingBox.setFromPoints(this.vertices);
      },
      computeBoundingSphere: function() {
        if (this.boundingSphere === null) {
          this.boundingSphere = new THREE.Sphere();
        }
        this.boundingSphere.setFromPoints(this.vertices);
      },
      merge: function(geometry, matrix, materialIndexOffset) {
        if (geometry instanceof THREE.Geometry === false) {
          THREE.error('THREE.Geometry.merge(): geometry not an instance of THREE.Geometry.', geometry);
          return ;
        }
        var normalMatrix,
            vertexOffset = this.vertices.length,
            vertices1 = this.vertices,
            vertices2 = geometry.vertices,
            faces1 = this.faces,
            faces2 = geometry.faces,
            uvs1 = this.faceVertexUvs[0],
            uvs2 = geometry.faceVertexUvs[0];
        if (materialIndexOffset === undefined)
          materialIndexOffset = 0;
        if (matrix !== undefined) {
          normalMatrix = new THREE.Matrix3().getNormalMatrix(matrix);
        }
        for (var i = 0,
            il = vertices2.length; i < il; i++) {
          var vertex = vertices2[i];
          var vertexCopy = vertex.clone();
          if (matrix !== undefined)
            vertexCopy.applyMatrix4(matrix);
          vertices1.push(vertexCopy);
        }
        for (i = 0, il = faces2.length; i < il; i++) {
          var face = faces2[i],
              faceCopy,
              normal,
              color,
              faceVertexNormals = face.vertexNormals,
              faceVertexColors = face.vertexColors;
          faceCopy = new THREE.Face3(face.a + vertexOffset, face.b + vertexOffset, face.c + vertexOffset);
          faceCopy.normal.copy(face.normal);
          if (normalMatrix !== undefined) {
            faceCopy.normal.applyMatrix3(normalMatrix).normalize();
          }
          for (var j = 0,
              jl = faceVertexNormals.length; j < jl; j++) {
            normal = faceVertexNormals[j].clone();
            if (normalMatrix !== undefined) {
              normal.applyMatrix3(normalMatrix).normalize();
            }
            faceCopy.vertexNormals.push(normal);
          }
          faceCopy.color.copy(face.color);
          for (var j = 0,
              jl = faceVertexColors.length; j < jl; j++) {
            color = faceVertexColors[j];
            faceCopy.vertexColors.push(color.clone());
          }
          faceCopy.materialIndex = face.materialIndex + materialIndexOffset;
          faces1.push(faceCopy);
        }
        for (i = 0, il = uvs2.length; i < il; i++) {
          var uv = uvs2[i],
              uvCopy = [];
          if (uv === undefined) {
            continue;
          }
          for (var j = 0,
              jl = uv.length; j < jl; j++) {
            uvCopy.push(uv[j].clone());
          }
          uvs1.push(uvCopy);
        }
      },
      mergeMesh: function(mesh) {
        if (mesh instanceof THREE.Mesh === false) {
          THREE.error('THREE.Geometry.mergeMesh(): mesh not an instance of THREE.Mesh.', mesh);
          return ;
        }
        mesh.matrixAutoUpdate && mesh.updateMatrix();
        this.merge(mesh.geometry, mesh.matrix);
      },
      mergeVertices: function() {
        var verticesMap = {};
        var unique = [],
            changes = [];
        var v,
            key;
        var precisionPoints = 4;
        var precision = Math.pow(10, precisionPoints);
        var i,
            il,
            face;
        var indices,
            j,
            jl;
        for (i = 0, il = this.vertices.length; i < il; i++) {
          v = this.vertices[i];
          key = Math.round(v.x * precision) + '_' + Math.round(v.y * precision) + '_' + Math.round(v.z * precision);
          if (verticesMap[key] === undefined) {
            verticesMap[key] = i;
            unique.push(this.vertices[i]);
            changes[i] = unique.length - 1;
          } else {
            changes[i] = changes[verticesMap[key]];
          }
        }
        ;
        var faceIndicesToRemove = [];
        for (i = 0, il = this.faces.length; i < il; i++) {
          face = this.faces[i];
          face.a = changes[face.a];
          face.b = changes[face.b];
          face.c = changes[face.c];
          indices = [face.a, face.b, face.c];
          var dupIndex = -1;
          for (var n = 0; n < 3; n++) {
            if (indices[n] == indices[(n + 1) % 3]) {
              dupIndex = n;
              faceIndicesToRemove.push(i);
              break;
            }
          }
        }
        for (i = faceIndicesToRemove.length - 1; i >= 0; i--) {
          var idx = faceIndicesToRemove[i];
          this.faces.splice(idx, 1);
          for (j = 0, jl = this.faceVertexUvs.length; j < jl; j++) {
            this.faceVertexUvs[j].splice(idx, 1);
          }
        }
        var diff = this.vertices.length - unique.length;
        this.vertices = unique;
        return diff;
      },
      toJSON: function() {
        var output = {
          metadata: {
            version: 4.0,
            type: 'BufferGeometry',
            generator: 'BufferGeometryExporter'
          },
          uuid: this.uuid,
          type: this.type
        };
        if (this.name !== "")
          output.name = this.name;
        if (this.parameters !== undefined) {
          var parameters = this.parameters;
          for (var key in parameters) {
            if (parameters[key] !== undefined)
              output[key] = parameters[key];
          }
          return output;
        }
        var vertices = [];
        for (var i = 0; i < this.vertices.length; i++) {
          var vertex = this.vertices[i];
          vertices.push(vertex.x, vertex.y, vertex.z);
        }
        var faces = [];
        var normals = [];
        var normalsHash = {};
        var colors = [];
        var colorsHash = {};
        var uvs = [];
        var uvsHash = {};
        for (var i = 0; i < this.faces.length; i++) {
          var face = this.faces[i];
          var hasMaterial = false;
          var hasFaceUv = false;
          var hasFaceVertexUv = this.faceVertexUvs[0][i] !== undefined;
          var hasFaceNormal = face.normal.length() > 0;
          var hasFaceVertexNormal = face.vertexNormals.length > 0;
          var hasFaceColor = face.color.r !== 1 || face.color.g !== 1 || face.color.b !== 1;
          var hasFaceVertexColor = face.vertexColors.length > 0;
          var faceType = 0;
          faceType = setBit(faceType, 0, 0);
          faceType = setBit(faceType, 1, hasMaterial);
          faceType = setBit(faceType, 2, hasFaceUv);
          faceType = setBit(faceType, 3, hasFaceVertexUv);
          faceType = setBit(faceType, 4, hasFaceNormal);
          faceType = setBit(faceType, 5, hasFaceVertexNormal);
          faceType = setBit(faceType, 6, hasFaceColor);
          faceType = setBit(faceType, 7, hasFaceVertexColor);
          faces.push(faceType);
          faces.push(face.a, face.b, face.c);
          if (hasFaceVertexUv) {
            var faceVertexUvs = this.faceVertexUvs[0][i];
            faces.push(getUvIndex(faceVertexUvs[0]), getUvIndex(faceVertexUvs[1]), getUvIndex(faceVertexUvs[2]));
          }
          if (hasFaceNormal) {
            faces.push(getNormalIndex(face.normal));
          }
          if (hasFaceVertexNormal) {
            var vertexNormals = face.vertexNormals;
            faces.push(getNormalIndex(vertexNormals[0]), getNormalIndex(vertexNormals[1]), getNormalIndex(vertexNormals[2]));
          }
          if (hasFaceColor) {
            faces.push(getColorIndex(face.color));
          }
          if (hasFaceVertexColor) {
            var vertexColors = face.vertexColors;
            faces.push(getColorIndex(vertexColors[0]), getColorIndex(vertexColors[1]), getColorIndex(vertexColors[2]));
          }
        }
        function setBit(value, position, enabled) {
          return enabled ? value | (1 << position) : value & (~(1 << position));
        }
        function getNormalIndex(normal) {
          var hash = normal.x.toString() + normal.y.toString() + normal.z.toString();
          if (normalsHash[hash] !== undefined) {
            return normalsHash[hash];
          }
          normalsHash[hash] = normals.length / 3;
          normals.push(normal.x, normal.y, normal.z);
          return normalsHash[hash];
        }
        function getColorIndex(color) {
          var hash = color.r.toString() + color.g.toString() + color.b.toString();
          if (colorsHash[hash] !== undefined) {
            return colorsHash[hash];
          }
          colorsHash[hash] = colors.length;
          colors.push(color.getHex());
          return colorsHash[hash];
        }
        function getUvIndex(uv) {
          var hash = uv.x.toString() + uv.y.toString();
          if (uvsHash[hash] !== undefined) {
            return uvsHash[hash];
          }
          uvsHash[hash] = uvs.length / 2;
          uvs.push(uv.x, uv.y);
          return uvsHash[hash];
        }
        output.data = {};
        output.data.vertices = vertices;
        output.data.normals = normals;
        if (colors.length > 0)
          output.data.colors = colors;
        if (uvs.length > 0)
          output.data.uvs = [uvs];
        output.data.faces = faces;
        return output;
      },
      clone: function() {
        var geometry = new THREE.Geometry();
        var vertices = this.vertices;
        for (var i = 0,
            il = vertices.length; i < il; i++) {
          geometry.vertices.push(vertices[i].clone());
        }
        var faces = this.faces;
        for (var i = 0,
            il = faces.length; i < il; i++) {
          geometry.faces.push(faces[i].clone());
        }
        for (var i = 0,
            il = this.faceVertexUvs.length; i < il; i++) {
          var faceVertexUvs = this.faceVertexUvs[i];
          if (geometry.faceVertexUvs[i] === undefined) {
            geometry.faceVertexUvs[i] = [];
          }
          for (var j = 0,
              jl = faceVertexUvs.length; j < jl; j++) {
            var uvs = faceVertexUvs[j],
                uvsCopy = [];
            for (var k = 0,
                kl = uvs.length; k < kl; k++) {
              var uv = uvs[k];
              uvsCopy.push(uv.clone());
            }
            geometry.faceVertexUvs[i].push(uvsCopy);
          }
        }
        return geometry;
      },
      dispose: function() {
        this.dispatchEvent({type: 'dispose'});
      }
    };
    THREE.EventDispatcher.prototype.apply(THREE.Geometry.prototype);
    THREE.GeometryIdCount = 0;
    THREE.Camera = function() {
      THREE.Object3D.call(this);
      this.type = 'Camera';
      this.matrixWorldInverse = new THREE.Matrix4();
      this.projectionMatrix = new THREE.Matrix4();
    };
    THREE.Camera.prototype = Object.create(THREE.Object3D.prototype);
    THREE.Camera.prototype.constructor = THREE.Camera;
    THREE.Camera.prototype.getWorldDirection = function() {
      var quaternion = new THREE.Quaternion();
      return function(optionalTarget) {
        var result = optionalTarget || new THREE.Vector3();
        this.getWorldQuaternion(quaternion);
        return result.set(0, 0, -1).applyQuaternion(quaternion);
      };
    }();
    THREE.Camera.prototype.lookAt = function() {
      var m1 = new THREE.Matrix4();
      return function(vector) {
        m1.lookAt(this.position, vector, this.up);
        this.quaternion.setFromRotationMatrix(m1);
      };
    }();
    THREE.Camera.prototype.clone = function(camera) {
      if (camera === undefined)
        camera = new THREE.Camera();
      THREE.Object3D.prototype.clone.call(this, camera);
      camera.matrixWorldInverse.copy(this.matrixWorldInverse);
      camera.projectionMatrix.copy(this.projectionMatrix);
      return camera;
    };
    THREE.CubeCamera = function(near, far, cubeResolution) {
      THREE.Object3D.call(this);
      this.type = 'CubeCamera';
      var fov = 90,
          aspect = 1;
      var cameraPX = new THREE.PerspectiveCamera(fov, aspect, near, far);
      cameraPX.up.set(0, -1, 0);
      cameraPX.lookAt(new THREE.Vector3(1, 0, 0));
      this.add(cameraPX);
      var cameraNX = new THREE.PerspectiveCamera(fov, aspect, near, far);
      cameraNX.up.set(0, -1, 0);
      cameraNX.lookAt(new THREE.Vector3(-1, 0, 0));
      this.add(cameraNX);
      var cameraPY = new THREE.PerspectiveCamera(fov, aspect, near, far);
      cameraPY.up.set(0, 0, 1);
      cameraPY.lookAt(new THREE.Vector3(0, 1, 0));
      this.add(cameraPY);
      var cameraNY = new THREE.PerspectiveCamera(fov, aspect, near, far);
      cameraNY.up.set(0, 0, -1);
      cameraNY.lookAt(new THREE.Vector3(0, -1, 0));
      this.add(cameraNY);
      var cameraPZ = new THREE.PerspectiveCamera(fov, aspect, near, far);
      cameraPZ.up.set(0, -1, 0);
      cameraPZ.lookAt(new THREE.Vector3(0, 0, 1));
      this.add(cameraPZ);
      var cameraNZ = new THREE.PerspectiveCamera(fov, aspect, near, far);
      cameraNZ.up.set(0, -1, 0);
      cameraNZ.lookAt(new THREE.Vector3(0, 0, -1));
      this.add(cameraNZ);
      this.renderTarget = new THREE.WebGLRenderTargetCube(cubeResolution, cubeResolution, {
        format: THREE.RGBFormat,
        magFilter: THREE.LinearFilter,
        minFilter: THREE.LinearFilter
      });
      this.updateCubeMap = function(renderer, scene) {
        var renderTarget = this.renderTarget;
        var generateMipmaps = renderTarget.generateMipmaps;
        renderTarget.generateMipmaps = false;
        renderTarget.activeCubeFace = 0;
        renderer.render(scene, cameraPX, renderTarget);
        renderTarget.activeCubeFace = 1;
        renderer.render(scene, cameraNX, renderTarget);
        renderTarget.activeCubeFace = 2;
        renderer.render(scene, cameraPY, renderTarget);
        renderTarget.activeCubeFace = 3;
        renderer.render(scene, cameraNY, renderTarget);
        renderTarget.activeCubeFace = 4;
        renderer.render(scene, cameraPZ, renderTarget);
        renderTarget.generateMipmaps = generateMipmaps;
        renderTarget.activeCubeFace = 5;
        renderer.render(scene, cameraNZ, renderTarget);
      };
    };
    THREE.CubeCamera.prototype = Object.create(THREE.Object3D.prototype);
    THREE.CubeCamera.prototype.constructor = THREE.CubeCamera;
    THREE.OrthographicCamera = function(left, right, top, bottom, near, far) {
      THREE.Camera.call(this);
      this.type = 'OrthographicCamera';
      this.zoom = 1;
      this.left = left;
      this.right = right;
      this.top = top;
      this.bottom = bottom;
      this.near = (near !== undefined) ? near : 0.1;
      this.far = (far !== undefined) ? far : 2000;
      this.updateProjectionMatrix();
    };
    THREE.OrthographicCamera.prototype = Object.create(THREE.Camera.prototype);
    THREE.OrthographicCamera.prototype.constructor = THREE.OrthographicCamera;
    THREE.OrthographicCamera.prototype.updateProjectionMatrix = function() {
      var dx = (this.right - this.left) / (2 * this.zoom);
      var dy = (this.top - this.bottom) / (2 * this.zoom);
      var cx = (this.right + this.left) / 2;
      var cy = (this.top + this.bottom) / 2;
      this.projectionMatrix.makeOrthographic(cx - dx, cx + dx, cy + dy, cy - dy, this.near, this.far);
    };
    THREE.OrthographicCamera.prototype.clone = function() {
      var camera = new THREE.OrthographicCamera();
      THREE.Camera.prototype.clone.call(this, camera);
      camera.zoom = this.zoom;
      camera.left = this.left;
      camera.right = this.right;
      camera.top = this.top;
      camera.bottom = this.bottom;
      camera.near = this.near;
      camera.far = this.far;
      camera.projectionMatrix.copy(this.projectionMatrix);
      return camera;
    };
    THREE.PerspectiveCamera = function(fov, aspect, near, far) {
      THREE.Camera.call(this);
      this.type = 'PerspectiveCamera';
      this.zoom = 1;
      this.fov = fov !== undefined ? fov : 50;
      this.aspect = aspect !== undefined ? aspect : 1;
      this.near = near !== undefined ? near : 0.1;
      this.far = far !== undefined ? far : 2000;
      this.updateProjectionMatrix();
    };
    THREE.PerspectiveCamera.prototype = Object.create(THREE.Camera.prototype);
    THREE.PerspectiveCamera.prototype.constructor = THREE.PerspectiveCamera;
    THREE.PerspectiveCamera.prototype.setLens = function(focalLength, frameHeight) {
      if (frameHeight === undefined)
        frameHeight = 24;
      this.fov = 2 * THREE.Math.radToDeg(Math.atan(frameHeight / (focalLength * 2)));
      this.updateProjectionMatrix();
    };
    THREE.PerspectiveCamera.prototype.setViewOffset = function(fullWidth, fullHeight, x, y, width, height) {
      this.fullWidth = fullWidth;
      this.fullHeight = fullHeight;
      this.x = x;
      this.y = y;
      this.width = width;
      this.height = height;
      this.updateProjectionMatrix();
    };
    THREE.PerspectiveCamera.prototype.updateProjectionMatrix = function() {
      var fov = THREE.Math.radToDeg(2 * Math.atan(Math.tan(THREE.Math.degToRad(this.fov) * 0.5) / this.zoom));
      if (this.fullWidth) {
        var aspect = this.fullWidth / this.fullHeight;
        var top = Math.tan(THREE.Math.degToRad(fov * 0.5)) * this.near;
        var bottom = -top;
        var left = aspect * bottom;
        var right = aspect * top;
        var width = Math.abs(right - left);
        var height = Math.abs(top - bottom);
        this.projectionMatrix.makeFrustum(left + this.x * width / this.fullWidth, left + (this.x + this.width) * width / this.fullWidth, top - (this.y + this.height) * height / this.fullHeight, top - this.y * height / this.fullHeight, this.near, this.far);
      } else {
        this.projectionMatrix.makePerspective(fov, this.aspect, this.near, this.far);
      }
    };
    THREE.PerspectiveCamera.prototype.clone = function() {
      var camera = new THREE.PerspectiveCamera();
      THREE.Camera.prototype.clone.call(this, camera);
      camera.zoom = this.zoom;
      camera.fov = this.fov;
      camera.aspect = this.aspect;
      camera.near = this.near;
      camera.far = this.far;
      camera.projectionMatrix.copy(this.projectionMatrix);
      return camera;
    };
    THREE.Light = function(color) {
      THREE.Object3D.call(this);
      this.type = 'Light';
      this.color = new THREE.Color(color);
    };
    THREE.Light.prototype = Object.create(THREE.Object3D.prototype);
    THREE.Light.prototype.constructor = THREE.Light;
    THREE.Light.prototype.clone = function(light) {
      if (light === undefined)
        light = new THREE.Light();
      THREE.Object3D.prototype.clone.call(this, light);
      light.color.copy(this.color);
      return light;
    };
    THREE.AmbientLight = function(color) {
      THREE.Light.call(this, color);
      this.type = 'AmbientLight';
    };
    THREE.AmbientLight.prototype = Object.create(THREE.Light.prototype);
    THREE.AmbientLight.prototype.constructor = THREE.AmbientLight;
    THREE.AmbientLight.prototype.clone = function() {
      var light = new THREE.AmbientLight();
      THREE.Light.prototype.clone.call(this, light);
      return light;
    };
    THREE.AreaLight = function(color, intensity) {
      THREE.Light.call(this, color);
      this.type = 'AreaLight';
      this.normal = new THREE.Vector3(0, -1, 0);
      this.right = new THREE.Vector3(1, 0, 0);
      this.intensity = (intensity !== undefined) ? intensity : 1;
      this.width = 1.0;
      this.height = 1.0;
      this.constantAttenuation = 1.5;
      this.linearAttenuation = 0.5;
      this.quadraticAttenuation = 0.1;
    };
    THREE.AreaLight.prototype = Object.create(THREE.Light.prototype);
    THREE.AreaLight.prototype.constructor = THREE.AreaLight;
    THREE.DirectionalLight = function(color, intensity) {
      THREE.Light.call(this, color);
      this.type = 'DirectionalLight';
      this.position.set(0, 1, 0);
      this.target = new THREE.Object3D();
      this.intensity = (intensity !== undefined) ? intensity : 1;
      this.castShadow = false;
      this.onlyShadow = false;
      this.shadowCameraNear = 50;
      this.shadowCameraFar = 5000;
      this.shadowCameraLeft = -500;
      this.shadowCameraRight = 500;
      this.shadowCameraTop = 500;
      this.shadowCameraBottom = -500;
      this.shadowCameraVisible = false;
      this.shadowBias = 0;
      this.shadowDarkness = 0.5;
      this.shadowMapWidth = 512;
      this.shadowMapHeight = 512;
      this.shadowCascade = false;
      this.shadowCascadeOffset = new THREE.Vector3(0, 0, -1000);
      this.shadowCascadeCount = 2;
      this.shadowCascadeBias = [0, 0, 0];
      this.shadowCascadeWidth = [512, 512, 512];
      this.shadowCascadeHeight = [512, 512, 512];
      this.shadowCascadeNearZ = [-1.000, 0.990, 0.998];
      this.shadowCascadeFarZ = [0.990, 0.998, 1.000];
      this.shadowCascadeArray = [];
      this.shadowMap = null;
      this.shadowMapSize = null;
      this.shadowCamera = null;
      this.shadowMatrix = null;
    };
    THREE.DirectionalLight.prototype = Object.create(THREE.Light.prototype);
    THREE.DirectionalLight.prototype.constructor = THREE.DirectionalLight;
    THREE.DirectionalLight.prototype.clone = function() {
      var light = new THREE.DirectionalLight();
      THREE.Light.prototype.clone.call(this, light);
      light.target = this.target.clone();
      light.intensity = this.intensity;
      light.castShadow = this.castShadow;
      light.onlyShadow = this.onlyShadow;
      light.shadowCameraNear = this.shadowCameraNear;
      light.shadowCameraFar = this.shadowCameraFar;
      light.shadowCameraLeft = this.shadowCameraLeft;
      light.shadowCameraRight = this.shadowCameraRight;
      light.shadowCameraTop = this.shadowCameraTop;
      light.shadowCameraBottom = this.shadowCameraBottom;
      light.shadowCameraVisible = this.shadowCameraVisible;
      light.shadowBias = this.shadowBias;
      light.shadowDarkness = this.shadowDarkness;
      light.shadowMapWidth = this.shadowMapWidth;
      light.shadowMapHeight = this.shadowMapHeight;
      light.shadowCascade = this.shadowCascade;
      light.shadowCascadeOffset.copy(this.shadowCascadeOffset);
      light.shadowCascadeCount = this.shadowCascadeCount;
      light.shadowCascadeBias = this.shadowCascadeBias.slice(0);
      light.shadowCascadeWidth = this.shadowCascadeWidth.slice(0);
      light.shadowCascadeHeight = this.shadowCascadeHeight.slice(0);
      light.shadowCascadeNearZ = this.shadowCascadeNearZ.slice(0);
      light.shadowCascadeFarZ = this.shadowCascadeFarZ.slice(0);
      return light;
    };
    THREE.HemisphereLight = function(skyColor, groundColor, intensity) {
      THREE.Light.call(this, skyColor);
      this.type = 'HemisphereLight';
      this.position.set(0, 100, 0);
      this.groundColor = new THREE.Color(groundColor);
      this.intensity = (intensity !== undefined) ? intensity : 1;
    };
    THREE.HemisphereLight.prototype = Object.create(THREE.Light.prototype);
    THREE.HemisphereLight.prototype.constructor = THREE.HemisphereLight;
    THREE.HemisphereLight.prototype.clone = function() {
      var light = new THREE.HemisphereLight();
      THREE.Light.prototype.clone.call(this, light);
      light.groundColor.copy(this.groundColor);
      light.intensity = this.intensity;
      return light;
    };
    THREE.PointLight = function(color, intensity, distance, decay) {
      THREE.Light.call(this, color);
      this.type = 'PointLight';
      this.intensity = (intensity !== undefined) ? intensity : 1;
      this.distance = (distance !== undefined) ? distance : 0;
      this.decay = (decay !== undefined) ? decay : 1;
    };
    THREE.PointLight.prototype = Object.create(THREE.Light.prototype);
    THREE.PointLight.prototype.constructor = THREE.PointLight;
    THREE.PointLight.prototype.clone = function() {
      var light = new THREE.PointLight();
      THREE.Light.prototype.clone.call(this, light);
      light.intensity = this.intensity;
      light.distance = this.distance;
      light.decay = this.decay;
      return light;
    };
    THREE.SpotLight = function(color, intensity, distance, angle, exponent, decay) {
      THREE.Light.call(this, color);
      this.type = 'SpotLight';
      this.position.set(0, 1, 0);
      this.target = new THREE.Object3D();
      this.intensity = (intensity !== undefined) ? intensity : 1;
      this.distance = (distance !== undefined) ? distance : 0;
      this.angle = (angle !== undefined) ? angle : Math.PI / 3;
      this.exponent = (exponent !== undefined) ? exponent : 10;
      this.decay = (decay !== undefined) ? decay : 1;
      this.castShadow = false;
      this.onlyShadow = false;
      this.shadowCameraNear = 50;
      this.shadowCameraFar = 5000;
      this.shadowCameraFov = 50;
      this.shadowCameraVisible = false;
      this.shadowBias = 0;
      this.shadowDarkness = 0.5;
      this.shadowMapWidth = 512;
      this.shadowMapHeight = 512;
      this.shadowMap = null;
      this.shadowMapSize = null;
      this.shadowCamera = null;
      this.shadowMatrix = null;
    };
    THREE.SpotLight.prototype = Object.create(THREE.Light.prototype);
    THREE.SpotLight.prototype.constructor = THREE.SpotLight;
    THREE.SpotLight.prototype.clone = function() {
      var light = new THREE.SpotLight();
      THREE.Light.prototype.clone.call(this, light);
      light.target = this.target.clone();
      light.intensity = this.intensity;
      light.distance = this.distance;
      light.angle = this.angle;
      light.exponent = this.exponent;
      light.decay = this.decay;
      light.castShadow = this.castShadow;
      light.onlyShadow = this.onlyShadow;
      light.shadowCameraNear = this.shadowCameraNear;
      light.shadowCameraFar = this.shadowCameraFar;
      light.shadowCameraFov = this.shadowCameraFov;
      light.shadowCameraVisible = this.shadowCameraVisible;
      light.shadowBias = this.shadowBias;
      light.shadowDarkness = this.shadowDarkness;
      light.shadowMapWidth = this.shadowMapWidth;
      light.shadowMapHeight = this.shadowMapHeight;
      return light;
    };
    THREE.Cache = {
      files: {},
      add: function(key, file) {
        this.files[key] = file;
      },
      get: function(key) {
        return this.files[key];
      },
      remove: function(key) {
        delete this.files[key];
      },
      clear: function() {
        this.files = {};
      }
    };
    THREE.Loader = function(showStatus) {
      this.showStatus = showStatus;
      this.statusDomElement = showStatus ? THREE.Loader.prototype.addStatusElement() : null;
      this.imageLoader = new THREE.ImageLoader();
      this.onLoadStart = function() {};
      this.onLoadProgress = function() {};
      this.onLoadComplete = function() {};
    };
    THREE.Loader.prototype = {
      constructor: THREE.Loader,
      crossOrigin: undefined,
      addStatusElement: function() {
        var e = document.createElement('div');
        e.style.position = 'absolute';
        e.style.right = '0px';
        e.style.top = '0px';
        e.style.fontSize = '0.8em';
        e.style.textAlign = 'left';
        e.style.background = 'rgba(0,0,0,0.25)';
        e.style.color = '#fff';
        e.style.width = '120px';
        e.style.padding = '0.5em 0.5em 0.5em 0.5em';
        e.style.zIndex = 1000;
        e.innerHTML = 'Loading ...';
        return e;
      },
      updateProgress: function(progress) {
        var message = 'Loaded ';
        if (progress.total) {
          message += (100 * progress.loaded / progress.total).toFixed(0) + '%';
        } else {
          message += (progress.loaded / 1024).toFixed(2) + ' KB';
        }
        this.statusDomElement.innerHTML = message;
      },
      extractUrlBase: function(url) {
        var parts = url.split('/');
        if (parts.length === 1)
          return './';
        parts.pop();
        return parts.join('/') + '/';
      },
      initMaterials: function(materials, texturePath) {
        var array = [];
        for (var i = 0; i < materials.length; ++i) {
          array[i] = this.createMaterial(materials[i], texturePath);
        }
        return array;
      },
      needsTangents: function(materials) {
        for (var i = 0,
            il = materials.length; i < il; i++) {
          var m = materials[i];
          if (m instanceof THREE.ShaderMaterial)
            return true;
        }
        return false;
      },
      createMaterial: function(m, texturePath) {
        var scope = this;
        function nearest_pow2(n) {
          var l = Math.log(n) / Math.LN2;
          return Math.pow(2, Math.round(l));
        }
        function create_texture(where, name, sourceFile, repeat, offset, wrap, anisotropy) {
          var fullPath = texturePath + sourceFile;
          var texture;
          var loader = THREE.Loader.Handlers.get(fullPath);
          if (loader !== null) {
            texture = loader.load(fullPath);
          } else {
            texture = new THREE.Texture();
            loader = scope.imageLoader;
            loader.crossOrigin = scope.crossOrigin;
            loader.load(fullPath, function(image) {
              if (THREE.Math.isPowerOfTwo(image.width) === false || THREE.Math.isPowerOfTwo(image.height) === false) {
                var width = nearest_pow2(image.width);
                var height = nearest_pow2(image.height);
                var canvas = document.createElement('canvas');
                canvas.width = width;
                canvas.height = height;
                var context = canvas.getContext('2d');
                context.drawImage(image, 0, 0, width, height);
                texture.image = canvas;
              } else {
                texture.image = image;
              }
              texture.needsUpdate = true;
            });
          }
          texture.sourceFile = sourceFile;
          if (repeat) {
            texture.repeat.set(repeat[0], repeat[1]);
            if (repeat[0] !== 1)
              texture.wrapS = THREE.RepeatWrapping;
            if (repeat[1] !== 1)
              texture.wrapT = THREE.RepeatWrapping;
          }
          if (offset) {
            texture.offset.set(offset[0], offset[1]);
          }
          if (wrap) {
            var wrapMap = {
              'repeat': THREE.RepeatWrapping,
              'mirror': THREE.MirroredRepeatWrapping
            };
            if (wrapMap[wrap[0]] !== undefined)
              texture.wrapS = wrapMap[wrap[0]];
            if (wrapMap[wrap[1]] !== undefined)
              texture.wrapT = wrapMap[wrap[1]];
          }
          if (anisotropy) {
            texture.anisotropy = anisotropy;
          }
          where[name] = texture;
        }
        function rgb2hex(rgb) {
          return (rgb[0] * 255 << 16) + (rgb[1] * 255 << 8) + rgb[2] * 255;
        }
        var mtype = 'MeshLambertMaterial';
        var mpars = {
          color: 0xeeeeee,
          opacity: 1.0,
          map: null,
          lightMap: null,
          normalMap: null,
          bumpMap: null,
          wireframe: false
        };
        if (m.shading) {
          var shading = m.shading.toLowerCase();
          if (shading === 'phong')
            mtype = 'MeshPhongMaterial';
          else if (shading === 'basic')
            mtype = 'MeshBasicMaterial';
        }
        if (m.blending !== undefined && THREE[m.blending] !== undefined) {
          mpars.blending = THREE[m.blending];
        }
        if (m.transparent !== undefined) {
          mpars.transparent = m.transparent;
        }
        if (m.opacity !== undefined && m.opacity < 1.0) {
          mpars.transparent = true;
        }
        if (m.depthTest !== undefined) {
          mpars.depthTest = m.depthTest;
        }
        if (m.depthWrite !== undefined) {
          mpars.depthWrite = m.depthWrite;
        }
        if (m.visible !== undefined) {
          mpars.visible = m.visible;
        }
        if (m.flipSided !== undefined) {
          mpars.side = THREE.BackSide;
        }
        if (m.doubleSided !== undefined) {
          mpars.side = THREE.DoubleSide;
        }
        if (m.wireframe !== undefined) {
          mpars.wireframe = m.wireframe;
        }
        if (m.vertexColors !== undefined) {
          if (m.vertexColors === 'face') {
            mpars.vertexColors = THREE.FaceColors;
          } else if (m.vertexColors) {
            mpars.vertexColors = THREE.VertexColors;
          }
        }
        if (m.colorDiffuse) {
          mpars.color = rgb2hex(m.colorDiffuse);
        } else if (m.DbgColor) {
          mpars.color = m.DbgColor;
        }
        if (m.colorSpecular) {
          mpars.specular = rgb2hex(m.colorSpecular);
        }
        if (m.colorEmissive) {
          mpars.emissive = rgb2hex(m.colorEmissive);
        }
        if (m.transparency !== undefined) {
          console.warn('THREE.Loader: transparency has been renamed to opacity');
          m.opacity = m.transparency;
        }
        if (m.opacity !== undefined) {
          mpars.opacity = m.opacity;
        }
        if (m.specularCoef) {
          mpars.shininess = m.specularCoef;
        }
        if (m.mapDiffuse && texturePath) {
          create_texture(mpars, 'map', m.mapDiffuse, m.mapDiffuseRepeat, m.mapDiffuseOffset, m.mapDiffuseWrap, m.mapDiffuseAnisotropy);
        }
        if (m.mapLight && texturePath) {
          create_texture(mpars, 'lightMap', m.mapLight, m.mapLightRepeat, m.mapLightOffset, m.mapLightWrap, m.mapLightAnisotropy);
        }
        if (m.mapBump && texturePath) {
          create_texture(mpars, 'bumpMap', m.mapBump, m.mapBumpRepeat, m.mapBumpOffset, m.mapBumpWrap, m.mapBumpAnisotropy);
        }
        if (m.mapNormal && texturePath) {
          create_texture(mpars, 'normalMap', m.mapNormal, m.mapNormalRepeat, m.mapNormalOffset, m.mapNormalWrap, m.mapNormalAnisotropy);
        }
        if (m.mapSpecular && texturePath) {
          create_texture(mpars, 'specularMap', m.mapSpecular, m.mapSpecularRepeat, m.mapSpecularOffset, m.mapSpecularWrap, m.mapSpecularAnisotropy);
        }
        if (m.mapAlpha && texturePath) {
          create_texture(mpars, 'alphaMap', m.mapAlpha, m.mapAlphaRepeat, m.mapAlphaOffset, m.mapAlphaWrap, m.mapAlphaAnisotropy);
        }
        if (m.mapBumpScale) {
          mpars.bumpScale = m.mapBumpScale;
        }
        if (m.mapNormalFactor) {
          mpars.normalScale = new THREE.Vector2(m.mapNormalFactor, m.mapNormalFactor);
        }
        var material = new THREE[mtype](mpars);
        if (m.DbgName !== undefined)
          material.name = m.DbgName;
        return material;
      }
    };
    THREE.Loader.Handlers = {
      handlers: [],
      add: function(regex, loader) {
        this.handlers.push(regex, loader);
      },
      get: function(file) {
        for (var i = 0,
            l = this.handlers.length; i < l; i += 2) {
          var regex = this.handlers[i];
          var loader = this.handlers[i + 1];
          if (regex.test(file)) {
            return loader;
          }
        }
        return null;
      }
    };
    THREE.XHRLoader = function(manager) {
      this.manager = (manager !== undefined) ? manager : THREE.DefaultLoadingManager;
    };
    THREE.XHRLoader.prototype = {
      constructor: THREE.XHRLoader,
      load: function(url, onLoad, onProgress, onError) {
        var scope = this;
        var cached = THREE.Cache.get(url);
        if (cached !== undefined) {
          if (onLoad)
            onLoad(cached);
          return ;
        }
        var request = new XMLHttpRequest();
        request.open('GET', url, true);
        request.addEventListener('load', function(event) {
          THREE.Cache.add(url, this.response);
          if (onLoad)
            onLoad(this.response);
          scope.manager.itemEnd(url);
        }, false);
        if (onProgress !== undefined) {
          request.addEventListener('progress', function(event) {
            onProgress(event);
          }, false);
        }
        if (onError !== undefined) {
          request.addEventListener('error', function(event) {
            onError(event);
          }, false);
        }
        if (this.crossOrigin !== undefined)
          request.crossOrigin = this.crossOrigin;
        if (this.responseType !== undefined)
          request.responseType = this.responseType;
        request.send(null);
        scope.manager.itemStart(url);
      },
      setResponseType: function(value) {
        this.responseType = value;
      },
      setCrossOrigin: function(value) {
        this.crossOrigin = value;
      }
    };
    THREE.ImageLoader = function(manager) {
      this.manager = (manager !== undefined) ? manager : THREE.DefaultLoadingManager;
    };
    THREE.ImageLoader.prototype = {
      constructor: THREE.ImageLoader,
      load: function(url, onLoad, onProgress, onError) {
        var scope = this;
        var cached = THREE.Cache.get(url);
        if (cached !== undefined) {
          onLoad(cached);
          return ;
        }
        var image = document.createElement('img');
        image.addEventListener('load', function(event) {
          THREE.Cache.add(url, this);
          if (onLoad)
            onLoad(this);
          scope.manager.itemEnd(url);
        }, false);
        if (onProgress !== undefined) {
          image.addEventListener('progress', function(event) {
            onProgress(event);
          }, false);
        }
        if (onError !== undefined) {
          image.addEventListener('error', function(event) {
            onError(event);
          }, false);
        }
        if (this.crossOrigin !== undefined)
          image.crossOrigin = this.crossOrigin;
        image.src = url;
        scope.manager.itemStart(url);
        return image;
      },
      setCrossOrigin: function(value) {
        this.crossOrigin = value;
      }
    };
    THREE.JSONLoader = function(showStatus) {
      THREE.Loader.call(this, showStatus);
      this.withCredentials = false;
    };
    THREE.JSONLoader.prototype = Object.create(THREE.Loader.prototype);
    THREE.JSONLoader.prototype.constructor = THREE.JSONLoader;
    THREE.JSONLoader.prototype.load = function(url, callback, texturePath) {
      texturePath = texturePath && (typeof texturePath === 'string') ? texturePath : this.extractUrlBase(url);
      this.onLoadStart();
      this.loadAjaxJSON(this, url, callback, texturePath);
    };
    THREE.JSONLoader.prototype.loadAjaxJSON = function(context, url, callback, texturePath, callbackProgress) {
      var xhr = new XMLHttpRequest();
      var length = 0;
      xhr.onreadystatechange = function() {
        if (xhr.readyState === xhr.DONE) {
          if (xhr.status === 200 || xhr.status === 0) {
            if (xhr.responseText) {
              var json = JSON.parse(xhr.responseText);
              var metadata = json.metadata;
              if (metadata !== undefined) {
                if (metadata.type === 'object') {
                  THREE.error('THREE.JSONLoader: ' + url + ' should be loaded with THREE.ObjectLoader instead.');
                  return ;
                }
                if (metadata.type === 'scene') {
                  THREE.error('THREE.JSONLoader: ' + url + ' seems to be a Scene. Use THREE.SceneLoader instead.');
                  return ;
                }
              }
              var result = context.parse(json, texturePath);
              callback(result.geometry, result.materials);
            } else {
              THREE.error('THREE.JSONLoader: ' + url + ' seems to be unreachable or the file is empty.');
            }
            context.onLoadComplete();
          } else {
            THREE.error('THREE.JSONLoader: Couldn\'t load ' + url + ' (' + xhr.status + ')');
          }
        } else if (xhr.readyState === xhr.LOADING) {
          if (callbackProgress) {
            if (length === 0) {
              length = xhr.getResponseHeader('Content-Length');
            }
            callbackProgress({
              total: length,
              loaded: xhr.responseText.length
            });
          }
        } else if (xhr.readyState === xhr.HEADERS_RECEIVED) {
          if (callbackProgress !== undefined) {
            length = xhr.getResponseHeader('Content-Length');
          }
        }
      };
      xhr.open('GET', url, true);
      xhr.withCredentials = this.withCredentials;
      xhr.send(null);
    };
    THREE.JSONLoader.prototype.parse = function(json, texturePath) {
      var geometry = new THREE.Geometry(),
          scale = (json.scale !== undefined) ? 1.0 / json.scale : 1.0;
      parseModel(scale);
      parseSkin();
      parseMorphing(scale);
      geometry.computeFaceNormals();
      geometry.computeBoundingSphere();
      function parseModel(scale) {
        function isBitSet(value, position) {
          return value & (1 << position);
        }
        var i,
            j,
            fi,
            offset,
            zLength,
            colorIndex,
            normalIndex,
            uvIndex,
            materialIndex,
            type,
            isQuad,
            hasMaterial,
            hasFaceVertexUv,
            hasFaceNormal,
            hasFaceVertexNormal,
            hasFaceColor,
            hasFaceVertexColor,
            vertex,
            face,
            faceA,
            faceB,
            hex,
            normal,
            uvLayer,
            uv,
            u,
            v,
            faces = json.faces,
            vertices = json.vertices,
            normals = json.normals,
            colors = json.colors,
            nUvLayers = 0;
        if (json.uvs !== undefined) {
          for (i = 0; i < json.uvs.length; i++) {
            if (json.uvs[i].length)
              nUvLayers++;
          }
          for (i = 0; i < nUvLayers; i++) {
            geometry.faceVertexUvs[i] = [];
          }
        }
        offset = 0;
        zLength = vertices.length;
        while (offset < zLength) {
          vertex = new THREE.Vector3();
          vertex.x = vertices[offset++] * scale;
          vertex.y = vertices[offset++] * scale;
          vertex.z = vertices[offset++] * scale;
          geometry.vertices.push(vertex);
        }
        offset = 0;
        zLength = faces.length;
        while (offset < zLength) {
          type = faces[offset++];
          isQuad = isBitSet(type, 0);
          hasMaterial = isBitSet(type, 1);
          hasFaceVertexUv = isBitSet(type, 3);
          hasFaceNormal = isBitSet(type, 4);
          hasFaceVertexNormal = isBitSet(type, 5);
          hasFaceColor = isBitSet(type, 6);
          hasFaceVertexColor = isBitSet(type, 7);
          if (isQuad) {
            faceA = new THREE.Face3();
            faceA.a = faces[offset];
            faceA.b = faces[offset + 1];
            faceA.c = faces[offset + 3];
            faceB = new THREE.Face3();
            faceB.a = faces[offset + 1];
            faceB.b = faces[offset + 2];
            faceB.c = faces[offset + 3];
            offset += 4;
            if (hasMaterial) {
              materialIndex = faces[offset++];
              faceA.materialIndex = materialIndex;
              faceB.materialIndex = materialIndex;
            }
            fi = geometry.faces.length;
            if (hasFaceVertexUv) {
              for (i = 0; i < nUvLayers; i++) {
                uvLayer = json.uvs[i];
                geometry.faceVertexUvs[i][fi] = [];
                geometry.faceVertexUvs[i][fi + 1] = [];
                for (j = 0; j < 4; j++) {
                  uvIndex = faces[offset++];
                  u = uvLayer[uvIndex * 2];
                  v = uvLayer[uvIndex * 2 + 1];
                  uv = new THREE.Vector2(u, v);
                  if (j !== 2)
                    geometry.faceVertexUvs[i][fi].push(uv);
                  if (j !== 0)
                    geometry.faceVertexUvs[i][fi + 1].push(uv);
                }
              }
            }
            if (hasFaceNormal) {
              normalIndex = faces[offset++] * 3;
              faceA.normal.set(normals[normalIndex++], normals[normalIndex++], normals[normalIndex]);
              faceB.normal.copy(faceA.normal);
            }
            if (hasFaceVertexNormal) {
              for (i = 0; i < 4; i++) {
                normalIndex = faces[offset++] * 3;
                normal = new THREE.Vector3(normals[normalIndex++], normals[normalIndex++], normals[normalIndex]);
                if (i !== 2)
                  faceA.vertexNormals.push(normal);
                if (i !== 0)
                  faceB.vertexNormals.push(normal);
              }
            }
            if (hasFaceColor) {
              colorIndex = faces[offset++];
              hex = colors[colorIndex];
              faceA.color.setHex(hex);
              faceB.color.setHex(hex);
            }
            if (hasFaceVertexColor) {
              for (i = 0; i < 4; i++) {
                colorIndex = faces[offset++];
                hex = colors[colorIndex];
                if (i !== 2)
                  faceA.vertexColors.push(new THREE.Color(hex));
                if (i !== 0)
                  faceB.vertexColors.push(new THREE.Color(hex));
              }
            }
            geometry.faces.push(faceA);
            geometry.faces.push(faceB);
          } else {
            face = new THREE.Face3();
            face.a = faces[offset++];
            face.b = faces[offset++];
            face.c = faces[offset++];
            if (hasMaterial) {
              materialIndex = faces[offset++];
              face.materialIndex = materialIndex;
            }
            fi = geometry.faces.length;
            if (hasFaceVertexUv) {
              for (i = 0; i < nUvLayers; i++) {
                uvLayer = json.uvs[i];
                geometry.faceVertexUvs[i][fi] = [];
                for (j = 0; j < 3; j++) {
                  uvIndex = faces[offset++];
                  u = uvLayer[uvIndex * 2];
                  v = uvLayer[uvIndex * 2 + 1];
                  uv = new THREE.Vector2(u, v);
                  geometry.faceVertexUvs[i][fi].push(uv);
                }
              }
            }
            if (hasFaceNormal) {
              normalIndex = faces[offset++] * 3;
              face.normal.set(normals[normalIndex++], normals[normalIndex++], normals[normalIndex]);
            }
            if (hasFaceVertexNormal) {
              for (i = 0; i < 3; i++) {
                normalIndex = faces[offset++] * 3;
                normal = new THREE.Vector3(normals[normalIndex++], normals[normalIndex++], normals[normalIndex]);
                face.vertexNormals.push(normal);
              }
            }
            if (hasFaceColor) {
              colorIndex = faces[offset++];
              face.color.setHex(colors[colorIndex]);
            }
            if (hasFaceVertexColor) {
              for (i = 0; i < 3; i++) {
                colorIndex = faces[offset++];
                face.vertexColors.push(new THREE.Color(colors[colorIndex]));
              }
            }
            geometry.faces.push(face);
          }
        }
      }
      ;
      function parseSkin() {
        var influencesPerVertex = (json.influencesPerVertex !== undefined) ? json.influencesPerVertex : 2;
        if (json.skinWeights) {
          for (var i = 0,
              l = json.skinWeights.length; i < l; i += influencesPerVertex) {
            var x = json.skinWeights[i];
            var y = (influencesPerVertex > 1) ? json.skinWeights[i + 1] : 0;
            var z = (influencesPerVertex > 2) ? json.skinWeights[i + 2] : 0;
            var w = (influencesPerVertex > 3) ? json.skinWeights[i + 3] : 0;
            geometry.skinWeights.push(new THREE.Vector4(x, y, z, w));
          }
        }
        if (json.skinIndices) {
          for (var i = 0,
              l = json.skinIndices.length; i < l; i += influencesPerVertex) {
            var a = json.skinIndices[i];
            var b = (influencesPerVertex > 1) ? json.skinIndices[i + 1] : 0;
            var c = (influencesPerVertex > 2) ? json.skinIndices[i + 2] : 0;
            var d = (influencesPerVertex > 3) ? json.skinIndices[i + 3] : 0;
            geometry.skinIndices.push(new THREE.Vector4(a, b, c, d));
          }
        }
        geometry.bones = json.bones;
        if (geometry.bones && geometry.bones.length > 0 && (geometry.skinWeights.length !== geometry.skinIndices.length || geometry.skinIndices.length !== geometry.vertices.length)) {
          THREE.warn('THREE.JSONLoader: When skinning, number of vertices (' + geometry.vertices.length + '), skinIndices (' + geometry.skinIndices.length + '), and skinWeights (' + geometry.skinWeights.length + ') should match.');
        }
        geometry.animation = json.animation;
        geometry.animations = json.animations;
      }
      ;
      function parseMorphing(scale) {
        if (json.morphTargets !== undefined) {
          var i,
              l,
              v,
              vl,
              dstVertices,
              srcVertices;
          for (i = 0, l = json.morphTargets.length; i < l; i++) {
            geometry.morphTargets[i] = {};
            geometry.morphTargets[i].name = json.morphTargets[i].name;
            geometry.morphTargets[i].vertices = [];
            dstVertices = geometry.morphTargets[i].vertices;
            srcVertices = json.morphTargets[i].vertices;
            for (v = 0, vl = srcVertices.length; v < vl; v += 3) {
              var vertex = new THREE.Vector3();
              vertex.x = srcVertices[v] * scale;
              vertex.y = srcVertices[v + 1] * scale;
              vertex.z = srcVertices[v + 2] * scale;
              dstVertices.push(vertex);
            }
          }
        }
        if (json.morphColors !== undefined) {
          var i,
              l,
              c,
              cl,
              dstColors,
              srcColors,
              color;
          for (i = 0, l = json.morphColors.length; i < l; i++) {
            geometry.morphColors[i] = {};
            geometry.morphColors[i].name = json.morphColors[i].name;
            geometry.morphColors[i].colors = [];
            dstColors = geometry.morphColors[i].colors;
            srcColors = json.morphColors[i].colors;
            for (c = 0, cl = srcColors.length; c < cl; c += 3) {
              color = new THREE.Color(0xffaa00);
              color.setRGB(srcColors[c], srcColors[c + 1], srcColors[c + 2]);
              dstColors.push(color);
            }
          }
        }
      }
      ;
      if (json.materials === undefined || json.materials.length === 0) {
        return {geometry: geometry};
      } else {
        var materials = this.initMaterials(json.materials, texturePath);
        if (this.needsTangents(materials)) {
          geometry.computeTangents();
        }
        return {
          geometry: geometry,
          materials: materials
        };
      }
    };
    THREE.LoadingManager = function(onLoad, onProgress, onError) {
      var scope = this;
      var loaded = 0,
          total = 0;
      this.onLoad = onLoad;
      this.onProgress = onProgress;
      this.onError = onError;
      this.itemStart = function(url) {
        total++;
      };
      this.itemEnd = function(url) {
        loaded++;
        if (scope.onProgress !== undefined) {
          scope.onProgress(url, loaded, total);
        }
        if (loaded === total && scope.onLoad !== undefined) {
          scope.onLoad();
        }
      };
    };
    THREE.DefaultLoadingManager = new THREE.LoadingManager();
    THREE.BufferGeometryLoader = function(manager) {
      this.manager = (manager !== undefined) ? manager : THREE.DefaultLoadingManager;
    };
    THREE.BufferGeometryLoader.prototype = {
      constructor: THREE.BufferGeometryLoader,
      load: function(url, onLoad, onProgress, onError) {
        var scope = this;
        var loader = new THREE.XHRLoader(scope.manager);
        loader.setCrossOrigin(this.crossOrigin);
        loader.load(url, function(text) {
          onLoad(scope.parse(JSON.parse(text)));
        }, onProgress, onError);
      },
      setCrossOrigin: function(value) {
        this.crossOrigin = value;
      },
      parse: function(json) {
        var geometry = new THREE.BufferGeometry();
        var attributes = json.data.attributes;
        for (var key in attributes) {
          var attribute = attributes[key];
          var typedArray = new self[attribute.type](attribute.array);
          geometry.addAttribute(key, new THREE.BufferAttribute(typedArray, attribute.itemSize));
        }
        var offsets = json.data.offsets;
        if (offsets !== undefined) {
          geometry.offsets = JSON.parse(JSON.stringify(offsets));
        }
        var boundingSphere = json.data.boundingSphere;
        if (boundingSphere !== undefined) {
          var center = new THREE.Vector3();
          if (boundingSphere.center !== undefined) {
            center.fromArray(boundingSphere.center);
          }
          geometry.boundingSphere = new THREE.Sphere(center, boundingSphere.radius);
        }
        return geometry;
      }
    };
    THREE.MaterialLoader = function(manager) {
      this.manager = (manager !== undefined) ? manager : THREE.DefaultLoadingManager;
    };
    THREE.MaterialLoader.prototype = {
      constructor: THREE.MaterialLoader,
      load: function(url, onLoad, onProgress, onError) {
        var scope = this;
        var loader = new THREE.XHRLoader(scope.manager);
        loader.setCrossOrigin(this.crossOrigin);
        loader.load(url, function(text) {
          onLoad(scope.parse(JSON.parse(text)));
        }, onProgress, onError);
      },
      setCrossOrigin: function(value) {
        this.crossOrigin = value;
      },
      parse: function(json) {
        var material = new THREE[json.type];
        if (json.color !== undefined)
          material.color.setHex(json.color);
        if (json.emissive !== undefined)
          material.emissive.setHex(json.emissive);
        if (json.specular !== undefined)
          material.specular.setHex(json.specular);
        if (json.shininess !== undefined)
          material.shininess = json.shininess;
        if (json.uniforms !== undefined)
          material.uniforms = json.uniforms;
        if (json.vertexShader !== undefined)
          material.vertexShader = json.vertexShader;
        if (json.fragmentShader !== undefined)
          material.fragmentShader = json.fragmentShader;
        if (json.vertexColors !== undefined)
          material.vertexColors = json.vertexColors;
        if (json.shading !== undefined)
          material.shading = json.shading;
        if (json.blending !== undefined)
          material.blending = json.blending;
        if (json.side !== undefined)
          material.side = json.side;
        if (json.opacity !== undefined)
          material.opacity = json.opacity;
        if (json.transparent !== undefined)
          material.transparent = json.transparent;
        if (json.wireframe !== undefined)
          material.wireframe = json.wireframe;
        if (json.size !== undefined)
          material.size = json.size;
        if (json.sizeAttenuation !== undefined)
          material.sizeAttenuation = json.sizeAttenuation;
        if (json.materials !== undefined) {
          for (var i = 0,
              l = json.materials.length; i < l; i++) {
            material.materials.push(this.parse(json.materials[i]));
          }
        }
        return material;
      }
    };
    THREE.ObjectLoader = function(manager) {
      this.manager = (manager !== undefined) ? manager : THREE.DefaultLoadingManager;
      this.texturePath = '';
    };
    THREE.ObjectLoader.prototype = {
      constructor: THREE.ObjectLoader,
      load: function(url, onLoad, onProgress, onError) {
        if (this.texturePath === '') {
          this.texturePath = url.substring(0, url.lastIndexOf('/') + 1);
        }
        var scope = this;
        var loader = new THREE.XHRLoader(scope.manager);
        loader.setCrossOrigin(this.crossOrigin);
        loader.load(url, function(text) {
          scope.parse(JSON.parse(text), onLoad);
        }, onProgress, onError);
      },
      setTexturePath: function(value) {
        this.texturePath = value;
      },
      setCrossOrigin: function(value) {
        this.crossOrigin = value;
      },
      parse: function(json, onLoad) {
        var geometries = this.parseGeometries(json.geometries);
        var images = this.parseImages(json.images, function() {
          if (onLoad !== undefined)
            onLoad(object);
        });
        var textures = this.parseTextures(json.textures, images);
        var materials = this.parseMaterials(json.materials, textures);
        var object = this.parseObject(json.object, geometries, materials);
        if (json.images === undefined || json.images.length === 0) {
          if (onLoad !== undefined)
            onLoad(object);
        }
        return object;
      },
      parseGeometries: function(json) {
        var geometries = {};
        if (json !== undefined) {
          var geometryLoader = new THREE.JSONLoader();
          var bufferGeometryLoader = new THREE.BufferGeometryLoader();
          for (var i = 0,
              l = json.length; i < l; i++) {
            var geometry;
            var data = json[i];
            switch (data.type) {
              case 'PlaneGeometry':
              case 'PlaneBufferGeometry':
                geometry = new THREE[data.type](data.width, data.height, data.widthSegments, data.heightSegments);
                break;
              case 'BoxGeometry':
              case 'CubeGeometry':
                geometry = new THREE.BoxGeometry(data.width, data.height, data.depth, data.widthSegments, data.heightSegments, data.depthSegments);
                break;
              case 'CircleGeometry':
                geometry = new THREE.CircleGeometry(data.radius, data.segments);
                break;
              case 'CylinderGeometry':
                geometry = new THREE.CylinderGeometry(data.radiusTop, data.radiusBottom, data.height, data.radialSegments, data.heightSegments, data.openEnded);
                break;
              case 'SphereGeometry':
                geometry = new THREE.SphereGeometry(data.radius, data.widthSegments, data.heightSegments, data.phiStart, data.phiLength, data.thetaStart, data.thetaLength);
                break;
              case 'IcosahedronGeometry':
                geometry = new THREE.IcosahedronGeometry(data.radius, data.detail);
                break;
              case 'TorusGeometry':
                geometry = new THREE.TorusGeometry(data.radius, data.tube, data.radialSegments, data.tubularSegments, data.arc);
                break;
              case 'TorusKnotGeometry':
                geometry = new THREE.TorusKnotGeometry(data.radius, data.tube, data.radialSegments, data.tubularSegments, data.p, data.q, data.heightScale);
                break;
              case 'BufferGeometry':
                geometry = bufferGeometryLoader.parse(data);
                break;
              case 'Geometry':
                geometry = geometryLoader.parse(data.data).geometry;
                break;
            }
            geometry.uuid = data.uuid;
            if (data.name !== undefined)
              geometry.name = data.name;
            geometries[data.uuid] = geometry;
          }
        }
        return geometries;
      },
      parseMaterials: function(json, textures) {
        var materials = {};
        if (json !== undefined) {
          var getTexture = function(name) {
            if (textures[name] === undefined) {
              THREE.warn('THREE.ObjectLoader: Undefined texture', name);
            }
            return textures[name];
          };
          var loader = new THREE.MaterialLoader();
          for (var i = 0,
              l = json.length; i < l; i++) {
            var data = json[i];
            var material = loader.parse(data);
            material.uuid = data.uuid;
            if (data.name !== undefined)
              material.name = data.name;
            if (data.map !== undefined) {
              material.map = getTexture(data.map);
            }
            if (data.bumpMap !== undefined) {
              material.bumpMap = getTexture(data.bumpMap);
              if (data.bumpScale) {
                material.bumpScale = new THREE.Vector2(data.bumpScale, data.bumpScale);
              }
            }
            if (data.alphaMap !== undefined) {
              material.alphaMap = getTexture(data.alphaMap);
            }
            if (data.envMap !== undefined) {
              material.envMap = getTexture(data.envMap);
            }
            if (data.normalMap !== undefined) {
              material.normalMap = getTexture(data.normalMap);
              if (data.normalScale) {
                material.normalScale = new THREE.Vector2(data.normalScale, data.normalScale);
              }
            }
            if (data.lightMap !== undefined) {
              material.lightMap = getTexture(data.lightMap);
            }
            if (data.specularMap !== undefined) {
              material.specularMap = getTexture(data.specularMap);
            }
            materials[data.uuid] = material;
          }
        }
        return materials;
      },
      parseImages: function(json, onLoad) {
        var scope = this;
        var images = {};
        if (json !== undefined && json.length > 0) {
          var manager = new THREE.LoadingManager(onLoad);
          var loader = new THREE.ImageLoader(manager);
          loader.setCrossOrigin(this.crossOrigin);
          var loadImage = function(url) {
            scope.manager.itemStart(url);
            return loader.load(url, function() {
              scope.manager.itemEnd(url);
            });
          };
          for (var i = 0,
              l = json.length; i < l; i++) {
            var image = json[i];
            var path = /^(\/\/)|([a-z]+:(\/\/)?)/i.test(image.url) ? image.url : scope.texturePath + image.url;
            images[image.uuid] = loadImage(path);
          }
        }
        return images;
      },
      parseTextures: function(json, images) {
        var textures = {};
        if (json !== undefined) {
          for (var i = 0,
              l = json.length; i < l; i++) {
            var data = json[i];
            if (data.image === undefined) {
              THREE.warn('THREE.ObjectLoader: No "image" speficied for', data.uuid);
            }
            if (images[data.image] === undefined) {
              THREE.warn('THREE.ObjectLoader: Undefined image', data.image);
            }
            var texture = new THREE.Texture(images[data.image]);
            texture.needsUpdate = true;
            texture.uuid = data.uuid;
            if (data.name !== undefined)
              texture.name = data.name;
            if (data.repeat !== undefined)
              texture.repeat = new THREE.Vector2(data.repeat[0], data.repeat[1]);
            if (data.minFilter !== undefined)
              texture.minFilter = THREE[data.minFilter];
            if (data.magFilter !== undefined)
              texture.magFilter = THREE[data.magFilter];
            if (data.anisotropy !== undefined)
              texture.anisotropy = data.anisotropy;
            if (data.wrap instanceof Array) {
              texture.wrapS = THREE[data.wrap[0]];
              texture.wrapT = THREE[data.wrap[1]];
            }
            textures[data.uuid] = texture;
          }
        }
        return textures;
      },
      parseObject: function() {
        var matrix = new THREE.Matrix4();
        return function(data, geometries, materials) {
          var object;
          var getGeometry = function(name) {
            if (geometries[name] === undefined) {
              THREE.warn('THREE.ObjectLoader: Undefined geometry', name);
            }
            return geometries[name];
          };
          var getMaterial = function(name) {
            if (materials[name] === undefined) {
              THREE.warn('THREE.ObjectLoader: Undefined material', name);
            }
            return materials[name];
          };
          switch (data.type) {
            case 'Scene':
              object = new THREE.Scene();
              break;
            case 'PerspectiveCamera':
              object = new THREE.PerspectiveCamera(data.fov, data.aspect, data.near, data.far);
              break;
            case 'OrthographicCamera':
              object = new THREE.OrthographicCamera(data.left, data.right, data.top, data.bottom, data.near, data.far);
              break;
            case 'AmbientLight':
              object = new THREE.AmbientLight(data.color);
              break;
            case 'DirectionalLight':
              object = new THREE.DirectionalLight(data.color, data.intensity);
              break;
            case 'PointLight':
              object = new THREE.PointLight(data.color, data.intensity, data.distance, data.decay);
              break;
            case 'SpotLight':
              object = new THREE.SpotLight(data.color, data.intensity, data.distance, data.angle, data.exponent, data.decay);
              break;
            case 'HemisphereLight':
              object = new THREE.HemisphereLight(data.color, data.groundColor, data.intensity);
              break;
            case 'Mesh':
              object = new THREE.Mesh(getGeometry(data.geometry), getMaterial(data.material));
              break;
            case 'Line':
              object = new THREE.Line(getGeometry(data.geometry), getMaterial(data.material), data.mode);
              break;
            case 'PointCloud':
              object = new THREE.PointCloud(getGeometry(data.geometry), getMaterial(data.material));
              break;
            case 'Sprite':
              object = new THREE.Sprite(getMaterial(data.material));
              break;
            case 'Group':
              object = new THREE.Group();
              break;
            default:
              object = new THREE.Object3D();
          }
          object.uuid = data.uuid;
          if (data.name !== undefined)
            object.name = data.name;
          if (data.matrix !== undefined) {
            matrix.fromArray(data.matrix);
            matrix.decompose(object.position, object.quaternion, object.scale);
          } else {
            if (data.position !== undefined)
              object.position.fromArray(data.position);
            if (data.rotation !== undefined)
              object.rotation.fromArray(data.rotation);
            if (data.scale !== undefined)
              object.scale.fromArray(data.scale);
          }
          if (data.visible !== undefined)
            object.visible = data.visible;
          if (data.userData !== undefined)
            object.userData = data.userData;
          if (data.children !== undefined) {
            for (var child in data.children) {
              object.add(this.parseObject(data.children[child], geometries, materials));
            }
          }
          return object;
        };
      }()
    };
    THREE.TextureLoader = function(manager) {
      this.manager = (manager !== undefined) ? manager : THREE.DefaultLoadingManager;
    };
    THREE.TextureLoader.prototype = {
      constructor: THREE.TextureLoader,
      load: function(url, onLoad, onProgress, onError) {
        var scope = this;
        var loader = new THREE.ImageLoader(scope.manager);
        loader.setCrossOrigin(this.crossOrigin);
        loader.load(url, function(image) {
          var texture = new THREE.Texture(image);
          texture.needsUpdate = true;
          if (onLoad !== undefined) {
            onLoad(texture);
          }
        }, onProgress, onError);
      },
      setCrossOrigin: function(value) {
        this.crossOrigin = value;
      }
    };
    THREE.DataTextureLoader = THREE.BinaryTextureLoader = function() {
      this._parser = null;
    };
    THREE.BinaryTextureLoader.prototype = {
      constructor: THREE.BinaryTextureLoader,
      load: function(url, onLoad, onProgress, onError) {
        var scope = this;
        var texture = new THREE.DataTexture();
        var loader = new THREE.XHRLoader();
        loader.setResponseType('arraybuffer');
        loader.load(url, function(buffer) {
          var texData = scope._parser(buffer);
          if (!texData)
            return ;
          if (undefined !== texData.image) {
            texture.image = texData.image;
          } else if (undefined !== texData.data) {
            texture.image.width = texData.width;
            texture.image.height = texData.height;
            texture.image.data = texData.data;
          }
          texture.wrapS = undefined !== texData.wrapS ? texData.wrapS : THREE.ClampToEdgeWrapping;
          texture.wrapT = undefined !== texData.wrapT ? texData.wrapT : THREE.ClampToEdgeWrapping;
          texture.magFilter = undefined !== texData.magFilter ? texData.magFilter : THREE.LinearFilter;
          texture.minFilter = undefined !== texData.minFilter ? texData.minFilter : THREE.LinearMipMapLinearFilter;
          texture.anisotropy = undefined !== texData.anisotropy ? texData.anisotropy : 1;
          if (undefined !== texData.format) {
            texture.format = texData.format;
          }
          if (undefined !== texData.type) {
            texture.type = texData.type;
          }
          if (undefined !== texData.mipmaps) {
            texture.mipmaps = texData.mipmaps;
          }
          if (1 === texData.mipmapCount) {
            texture.minFilter = THREE.LinearFilter;
          }
          texture.needsUpdate = true;
          if (onLoad)
            onLoad(texture, texData);
        }, onProgress, onError);
        return texture;
      }
    };
    THREE.CompressedTextureLoader = function() {
      this._parser = null;
    };
    THREE.CompressedTextureLoader.prototype = {
      constructor: THREE.CompressedTextureLoader,
      load: function(url, onLoad, onError) {
        var scope = this;
        var images = [];
        var texture = new THREE.CompressedTexture();
        texture.image = images;
        var loader = new THREE.XHRLoader();
        loader.setResponseType('arraybuffer');
        if (url instanceof Array) {
          var loaded = 0;
          var loadTexture = function(i) {
            loader.load(url[i], function(buffer) {
              var texDatas = scope._parser(buffer, true);
              images[i] = {
                width: texDatas.width,
                height: texDatas.height,
                format: texDatas.format,
                mipmaps: texDatas.mipmaps
              };
              loaded += 1;
              if (loaded === 6) {
                if (texDatas.mipmapCount == 1)
                  texture.minFilter = THREE.LinearFilter;
                texture.format = texDatas.format;
                texture.needsUpdate = true;
                if (onLoad)
                  onLoad(texture);
              }
            });
          };
          for (var i = 0,
              il = url.length; i < il; ++i) {
            loadTexture(i);
          }
        } else {
          loader.load(url, function(buffer) {
            var texDatas = scope._parser(buffer, true);
            if (texDatas.isCubemap) {
              var faces = texDatas.mipmaps.length / texDatas.mipmapCount;
              for (var f = 0; f < faces; f++) {
                images[f] = {mipmaps: []};
                for (var i = 0; i < texDatas.mipmapCount; i++) {
                  images[f].mipmaps.push(texDatas.mipmaps[f * texDatas.mipmapCount + i]);
                  images[f].format = texDatas.format;
                  images[f].width = texDatas.width;
                  images[f].height = texDatas.height;
                }
              }
            } else {
              texture.image.width = texDatas.width;
              texture.image.height = texDatas.height;
              texture.mipmaps = texDatas.mipmaps;
            }
            if (texDatas.mipmapCount === 1) {
              texture.minFilter = THREE.LinearFilter;
            }
            texture.format = texDatas.format;
            texture.needsUpdate = true;
            if (onLoad)
              onLoad(texture);
          });
        }
        return texture;
      }
    };
    THREE.Material = function() {
      Object.defineProperty(this, 'id', {value: THREE.MaterialIdCount++});
      this.uuid = THREE.Math.generateUUID();
      this.name = '';
      this.type = 'Material';
      this.side = THREE.FrontSide;
      this.opacity = 1;
      this.transparent = false;
      this.blending = THREE.NormalBlending;
      this.blendSrc = THREE.SrcAlphaFactor;
      this.blendDst = THREE.OneMinusSrcAlphaFactor;
      this.blendEquation = THREE.AddEquation;
      this.blendSrcAlpha = null;
      this.blendDstAlpha = null;
      this.blendEquationAlpha = null;
      this.depthTest = true;
      this.depthWrite = true;
      this.colorWrite = true;
      this.polygonOffset = false;
      this.polygonOffsetFactor = 0;
      this.polygonOffsetUnits = 0;
      this.alphaTest = 0;
      this.overdraw = 0;
      this.visible = true;
      this._needsUpdate = true;
    };
    THREE.Material.prototype = {
      constructor: THREE.Material,
      get needsUpdate() {
        return this._needsUpdate;
      },
      set needsUpdate(value) {
        if (value === true)
          this.update();
        this._needsUpdate = value;
      },
      setValues: function(values) {
        if (values === undefined)
          return ;
        for (var key in values) {
          var newValue = values[key];
          if (newValue === undefined) {
            THREE.warn("THREE.Material: '" + key + "' parameter is undefined.");
            continue;
          }
          if (key in this) {
            var currentValue = this[key];
            if (currentValue instanceof THREE.Color) {
              currentValue.set(newValue);
            } else if (currentValue instanceof THREE.Vector3 && newValue instanceof THREE.Vector3) {
              currentValue.copy(newValue);
            } else if (key == 'overdraw') {
              this[key] = Number(newValue);
            } else {
              this[key] = newValue;
            }
          }
        }
      },
      toJSON: function() {
        var output = {
          metadata: {
            version: 4.2,
            type: 'material',
            generator: 'MaterialExporter'
          },
          uuid: this.uuid,
          type: this.type
        };
        if (this.name !== "")
          output.name = this.name;
        if (this instanceof THREE.MeshBasicMaterial) {
          output.color = this.color.getHex();
          if (this.vertexColors !== THREE.NoColors)
            output.vertexColors = this.vertexColors;
          if (this.blending !== THREE.NormalBlending)
            output.blending = this.blending;
          if (this.side !== THREE.FrontSide)
            output.side = this.side;
        } else if (this instanceof THREE.MeshLambertMaterial) {
          output.color = this.color.getHex();
          output.emissive = this.emissive.getHex();
          if (this.vertexColors !== THREE.NoColors)
            output.vertexColors = this.vertexColors;
          if (this.shading !== THREE.SmoothShading)
            output.shading = this.shading;
          if (this.blending !== THREE.NormalBlending)
            output.blending = this.blending;
          if (this.side !== THREE.FrontSide)
            output.side = this.side;
        } else if (this instanceof THREE.MeshPhongMaterial) {
          output.color = this.color.getHex();
          output.emissive = this.emissive.getHex();
          output.specular = this.specular.getHex();
          output.shininess = this.shininess;
          if (this.vertexColors !== THREE.NoColors)
            output.vertexColors = this.vertexColors;
          if (this.shading !== THREE.SmoothShading)
            output.shading = this.shading;
          if (this.blending !== THREE.NormalBlending)
            output.blending = this.blending;
          if (this.side !== THREE.FrontSide)
            output.side = this.side;
        } else if (this instanceof THREE.MeshNormalMaterial) {
          if (this.blending !== THREE.NormalBlending)
            output.blending = this.blending;
          if (this.side !== THREE.FrontSide)
            output.side = this.side;
        } else if (this instanceof THREE.MeshDepthMaterial) {
          if (this.blending !== THREE.NormalBlending)
            output.blending = this.blending;
          if (this.side !== THREE.FrontSide)
            output.side = this.side;
        } else if (this instanceof THREE.PointCloudMaterial) {
          output.size = this.size;
          output.sizeAttenuation = this.sizeAttenuation;
          output.color = this.color.getHex();
          if (this.vertexColors !== THREE.NoColors)
            output.vertexColors = this.vertexColors;
          if (this.blending !== THREE.NormalBlending)
            output.blending = this.blending;
        } else if (this instanceof THREE.ShaderMaterial) {
          output.uniforms = this.uniforms;
          output.vertexShader = this.vertexShader;
          output.fragmentShader = this.fragmentShader;
        } else if (this instanceof THREE.SpriteMaterial) {
          output.color = this.color.getHex();
        }
        if (this.opacity < 1)
          output.opacity = this.opacity;
        if (this.transparent !== false)
          output.transparent = this.transparent;
        if (this.wireframe !== false)
          output.wireframe = this.wireframe;
        return output;
      },
      clone: function(material) {
        if (material === undefined)
          material = new THREE.Material();
        material.name = this.name;
        material.side = this.side;
        material.opacity = this.opacity;
        material.transparent = this.transparent;
        material.blending = this.blending;
        material.blendSrc = this.blendSrc;
        material.blendDst = this.blendDst;
        material.blendEquation = this.blendEquation;
        material.blendSrcAlpha = this.blendSrcAlpha;
        material.blendDstAlpha = this.blendDstAlpha;
        material.blendEquationAlpha = this.blendEquationAlpha;
        material.depthTest = this.depthTest;
        material.depthWrite = this.depthWrite;
        material.polygonOffset = this.polygonOffset;
        material.polygonOffsetFactor = this.polygonOffsetFactor;
        material.polygonOffsetUnits = this.polygonOffsetUnits;
        material.alphaTest = this.alphaTest;
        material.overdraw = this.overdraw;
        material.visible = this.visible;
        return material;
      },
      update: function() {
        this.dispatchEvent({type: 'update'});
      },
      dispose: function() {
        this.dispatchEvent({type: 'dispose'});
      }
    };
    THREE.EventDispatcher.prototype.apply(THREE.Material.prototype);
    THREE.MaterialIdCount = 0;
    THREE.LineBasicMaterial = function(parameters) {
      THREE.Material.call(this);
      this.type = 'LineBasicMaterial';
      this.color = new THREE.Color(0xffffff);
      this.linewidth = 1;
      this.linecap = 'round';
      this.linejoin = 'round';
      this.vertexColors = THREE.NoColors;
      this.fog = true;
      this.setValues(parameters);
    };
    THREE.LineBasicMaterial.prototype = Object.create(THREE.Material.prototype);
    THREE.LineBasicMaterial.prototype.constructor = THREE.LineBasicMaterial;
    THREE.LineBasicMaterial.prototype.clone = function() {
      var material = new THREE.LineBasicMaterial();
      THREE.Material.prototype.clone.call(this, material);
      material.color.copy(this.color);
      material.linewidth = this.linewidth;
      material.linecap = this.linecap;
      material.linejoin = this.linejoin;
      material.vertexColors = this.vertexColors;
      material.fog = this.fog;
      return material;
    };
    THREE.LineDashedMaterial = function(parameters) {
      THREE.Material.call(this);
      this.type = 'LineDashedMaterial';
      this.color = new THREE.Color(0xffffff);
      this.linewidth = 1;
      this.scale = 1;
      this.dashSize = 3;
      this.gapSize = 1;
      this.vertexColors = false;
      this.fog = true;
      this.setValues(parameters);
    };
    THREE.LineDashedMaterial.prototype = Object.create(THREE.Material.prototype);
    THREE.LineDashedMaterial.prototype.constructor = THREE.LineDashedMaterial;
    THREE.LineDashedMaterial.prototype.clone = function() {
      var material = new THREE.LineDashedMaterial();
      THREE.Material.prototype.clone.call(this, material);
      material.color.copy(this.color);
      material.linewidth = this.linewidth;
      material.scale = this.scale;
      material.dashSize = this.dashSize;
      material.gapSize = this.gapSize;
      material.vertexColors = this.vertexColors;
      material.fog = this.fog;
      return material;
    };
    THREE.MeshBasicMaterial = function(parameters) {
      THREE.Material.call(this);
      this.type = 'MeshBasicMaterial';
      this.color = new THREE.Color(0xffffff);
      this.map = null;
      this.lightMap = null;
      this.specularMap = null;
      this.alphaMap = null;
      this.envMap = null;
      this.combine = THREE.MultiplyOperation;
      this.reflectivity = 1;
      this.refractionRatio = 0.98;
      this.fog = true;
      this.shading = THREE.SmoothShading;
      this.wireframe = false;
      this.wireframeLinewidth = 1;
      this.wireframeLinecap = 'round';
      this.wireframeLinejoin = 'round';
      this.vertexColors = THREE.NoColors;
      this.skinning = false;
      this.morphTargets = false;
      this.setValues(parameters);
    };
    THREE.MeshBasicMaterial.prototype = Object.create(THREE.Material.prototype);
    THREE.MeshBasicMaterial.prototype.constructor = THREE.MeshBasicMaterial;
    THREE.MeshBasicMaterial.prototype.clone = function() {
      var material = new THREE.MeshBasicMaterial();
      THREE.Material.prototype.clone.call(this, material);
      material.color.copy(this.color);
      material.map = this.map;
      material.lightMap = this.lightMap;
      material.specularMap = this.specularMap;
      material.alphaMap = this.alphaMap;
      material.envMap = this.envMap;
      material.combine = this.combine;
      material.reflectivity = this.reflectivity;
      material.refractionRatio = this.refractionRatio;
      material.fog = this.fog;
      material.shading = this.shading;
      material.wireframe = this.wireframe;
      material.wireframeLinewidth = this.wireframeLinewidth;
      material.wireframeLinecap = this.wireframeLinecap;
      material.wireframeLinejoin = this.wireframeLinejoin;
      material.vertexColors = this.vertexColors;
      material.skinning = this.skinning;
      material.morphTargets = this.morphTargets;
      return material;
    };
    THREE.MeshLambertMaterial = function(parameters) {
      THREE.Material.call(this);
      this.type = 'MeshLambertMaterial';
      this.color = new THREE.Color(0xffffff);
      this.emissive = new THREE.Color(0x000000);
      this.wrapAround = false;
      this.wrapRGB = new THREE.Vector3(1, 1, 1);
      this.map = null;
      this.lightMap = null;
      this.specularMap = null;
      this.alphaMap = null;
      this.envMap = null;
      this.combine = THREE.MultiplyOperation;
      this.reflectivity = 1;
      this.refractionRatio = 0.98;
      this.fog = true;
      this.shading = THREE.SmoothShading;
      this.wireframe = false;
      this.wireframeLinewidth = 1;
      this.wireframeLinecap = 'round';
      this.wireframeLinejoin = 'round';
      this.vertexColors = THREE.NoColors;
      this.skinning = false;
      this.morphTargets = false;
      this.morphNormals = false;
      this.setValues(parameters);
    };
    THREE.MeshLambertMaterial.prototype = Object.create(THREE.Material.prototype);
    THREE.MeshLambertMaterial.prototype.constructor = THREE.MeshLambertMaterial;
    THREE.MeshLambertMaterial.prototype.clone = function() {
      var material = new THREE.MeshLambertMaterial();
      THREE.Material.prototype.clone.call(this, material);
      material.color.copy(this.color);
      material.emissive.copy(this.emissive);
      material.wrapAround = this.wrapAround;
      material.wrapRGB.copy(this.wrapRGB);
      material.map = this.map;
      material.lightMap = this.lightMap;
      material.specularMap = this.specularMap;
      material.alphaMap = this.alphaMap;
      material.envMap = this.envMap;
      material.combine = this.combine;
      material.reflectivity = this.reflectivity;
      material.refractionRatio = this.refractionRatio;
      material.fog = this.fog;
      material.shading = this.shading;
      material.wireframe = this.wireframe;
      material.wireframeLinewidth = this.wireframeLinewidth;
      material.wireframeLinecap = this.wireframeLinecap;
      material.wireframeLinejoin = this.wireframeLinejoin;
      material.vertexColors = this.vertexColors;
      material.skinning = this.skinning;
      material.morphTargets = this.morphTargets;
      material.morphNormals = this.morphNormals;
      return material;
    };
    THREE.MeshPhongMaterial = function(parameters) {
      THREE.Material.call(this);
      this.type = 'MeshPhongMaterial';
      this.color = new THREE.Color(0xffffff);
      this.emissive = new THREE.Color(0x000000);
      this.specular = new THREE.Color(0x111111);
      this.shininess = 30;
      this.metal = false;
      this.wrapAround = false;
      this.wrapRGB = new THREE.Vector3(1, 1, 1);
      this.map = null;
      this.lightMap = null;
      this.bumpMap = null;
      this.bumpScale = 1;
      this.normalMap = null;
      this.normalScale = new THREE.Vector2(1, 1);
      this.specularMap = null;
      this.alphaMap = null;
      this.envMap = null;
      this.combine = THREE.MultiplyOperation;
      this.reflectivity = 1;
      this.refractionRatio = 0.98;
      this.fog = true;
      this.shading = THREE.SmoothShading;
      this.wireframe = false;
      this.wireframeLinewidth = 1;
      this.wireframeLinecap = 'round';
      this.wireframeLinejoin = 'round';
      this.vertexColors = THREE.NoColors;
      this.skinning = false;
      this.morphTargets = false;
      this.morphNormals = false;
      this.setValues(parameters);
    };
    THREE.MeshPhongMaterial.prototype = Object.create(THREE.Material.prototype);
    THREE.MeshPhongMaterial.prototype.constructor = THREE.MeshPhongMaterial;
    THREE.MeshPhongMaterial.prototype.clone = function() {
      var material = new THREE.MeshPhongMaterial();
      THREE.Material.prototype.clone.call(this, material);
      material.color.copy(this.color);
      material.emissive.copy(this.emissive);
      material.specular.copy(this.specular);
      material.shininess = this.shininess;
      material.metal = this.metal;
      material.wrapAround = this.wrapAround;
      material.wrapRGB.copy(this.wrapRGB);
      material.map = this.map;
      material.lightMap = this.lightMap;
      material.bumpMap = this.bumpMap;
      material.bumpScale = this.bumpScale;
      material.normalMap = this.normalMap;
      material.normalScale.copy(this.normalScale);
      material.specularMap = this.specularMap;
      material.alphaMap = this.alphaMap;
      material.envMap = this.envMap;
      material.combine = this.combine;
      material.reflectivity = this.reflectivity;
      material.refractionRatio = this.refractionRatio;
      material.fog = this.fog;
      material.shading = this.shading;
      material.wireframe = this.wireframe;
      material.wireframeLinewidth = this.wireframeLinewidth;
      material.wireframeLinecap = this.wireframeLinecap;
      material.wireframeLinejoin = this.wireframeLinejoin;
      material.vertexColors = this.vertexColors;
      material.skinning = this.skinning;
      material.morphTargets = this.morphTargets;
      material.morphNormals = this.morphNormals;
      return material;
    };
    THREE.MeshDepthMaterial = function(parameters) {
      THREE.Material.call(this);
      this.type = 'MeshDepthMaterial';
      this.morphTargets = false;
      this.wireframe = false;
      this.wireframeLinewidth = 1;
      this.setValues(parameters);
    };
    THREE.MeshDepthMaterial.prototype = Object.create(THREE.Material.prototype);
    THREE.MeshDepthMaterial.prototype.constructor = THREE.MeshDepthMaterial;
    THREE.MeshDepthMaterial.prototype.clone = function() {
      var material = new THREE.MeshDepthMaterial();
      THREE.Material.prototype.clone.call(this, material);
      material.wireframe = this.wireframe;
      material.wireframeLinewidth = this.wireframeLinewidth;
      return material;
    };
    THREE.MeshNormalMaterial = function(parameters) {
      THREE.Material.call(this, parameters);
      this.type = 'MeshNormalMaterial';
      this.wireframe = false;
      this.wireframeLinewidth = 1;
      this.morphTargets = false;
      this.setValues(parameters);
    };
    THREE.MeshNormalMaterial.prototype = Object.create(THREE.Material.prototype);
    THREE.MeshNormalMaterial.prototype.constructor = THREE.MeshNormalMaterial;
    THREE.MeshNormalMaterial.prototype.clone = function() {
      var material = new THREE.MeshNormalMaterial();
      THREE.Material.prototype.clone.call(this, material);
      material.wireframe = this.wireframe;
      material.wireframeLinewidth = this.wireframeLinewidth;
      return material;
    };
    THREE.MeshFaceMaterial = function(materials) {
      this.uuid = THREE.Math.generateUUID();
      this.type = 'MeshFaceMaterial';
      this.materials = materials instanceof Array ? materials : [];
    };
    THREE.MeshFaceMaterial.prototype = {
      constructor: THREE.MeshFaceMaterial,
      toJSON: function() {
        var output = {
          metadata: {
            version: 4.2,
            type: 'material',
            generator: 'MaterialExporter'
          },
          uuid: this.uuid,
          type: this.type,
          materials: []
        };
        for (var i = 0,
            l = this.materials.length; i < l; i++) {
          output.materials.push(this.materials[i].toJSON());
        }
        return output;
      },
      clone: function() {
        var material = new THREE.MeshFaceMaterial();
        for (var i = 0; i < this.materials.length; i++) {
          material.materials.push(this.materials[i].clone());
        }
        return material;
      }
    };
    THREE.PointCloudMaterial = function(parameters) {
      THREE.Material.call(this);
      this.type = 'PointCloudMaterial';
      this.color = new THREE.Color(0xffffff);
      this.map = null;
      this.size = 1;
      this.sizeAttenuation = true;
      this.vertexColors = THREE.NoColors;
      this.fog = true;
      this.setValues(parameters);
    };
    THREE.PointCloudMaterial.prototype = Object.create(THREE.Material.prototype);
    THREE.PointCloudMaterial.prototype.constructor = THREE.PointCloudMaterial;
    THREE.PointCloudMaterial.prototype.clone = function() {
      var material = new THREE.PointCloudMaterial();
      THREE.Material.prototype.clone.call(this, material);
      material.color.copy(this.color);
      material.map = this.map;
      material.size = this.size;
      material.sizeAttenuation = this.sizeAttenuation;
      material.vertexColors = this.vertexColors;
      material.fog = this.fog;
      return material;
    };
    THREE.ParticleBasicMaterial = function(parameters) {
      THREE.warn('THREE.ParticleBasicMaterial has been renamed to THREE.PointCloudMaterial.');
      return new THREE.PointCloudMaterial(parameters);
    };
    THREE.ParticleSystemMaterial = function(parameters) {
      THREE.warn('THREE.ParticleSystemMaterial has been renamed to THREE.PointCloudMaterial.');
      return new THREE.PointCloudMaterial(parameters);
    };
    THREE.ShaderMaterial = function(parameters) {
      THREE.Material.call(this);
      this.type = 'ShaderMaterial';
      this.defines = {};
      this.uniforms = {};
      this.attributes = null;
      this.vertexShader = 'void main() {\n\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}';
      this.fragmentShader = 'void main() {\n\tgl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );\n}';
      this.shading = THREE.SmoothShading;
      this.linewidth = 1;
      this.wireframe = false;
      this.wireframeLinewidth = 1;
      this.fog = false;
      this.lights = false;
      this.vertexColors = THREE.NoColors;
      this.skinning = false;
      this.morphTargets = false;
      this.morphNormals = false;
      this.defaultAttributeValues = {
        'color': [1, 1, 1],
        'uv': [0, 0],
        'uv2': [0, 0]
      };
      this.index0AttributeName = undefined;
      this.setValues(parameters);
    };
    THREE.ShaderMaterial.prototype = Object.create(THREE.Material.prototype);
    THREE.ShaderMaterial.prototype.constructor = THREE.ShaderMaterial;
    THREE.ShaderMaterial.prototype.clone = function() {
      var material = new THREE.ShaderMaterial();
      THREE.Material.prototype.clone.call(this, material);
      material.fragmentShader = this.fragmentShader;
      material.vertexShader = this.vertexShader;
      material.uniforms = THREE.UniformsUtils.clone(this.uniforms);
      material.attributes = this.attributes;
      material.defines = this.defines;
      material.shading = this.shading;
      material.wireframe = this.wireframe;
      material.wireframeLinewidth = this.wireframeLinewidth;
      material.fog = this.fog;
      material.lights = this.lights;
      material.vertexColors = this.vertexColors;
      material.skinning = this.skinning;
      material.morphTargets = this.morphTargets;
      material.morphNormals = this.morphNormals;
      return material;
    };
    THREE.RawShaderMaterial = function(parameters) {
      THREE.ShaderMaterial.call(this, parameters);
      this.type = 'RawShaderMaterial';
    };
    THREE.RawShaderMaterial.prototype = Object.create(THREE.ShaderMaterial.prototype);
    THREE.RawShaderMaterial.prototype.constructor = THREE.RawShaderMaterial;
    THREE.RawShaderMaterial.prototype.clone = function() {
      var material = new THREE.RawShaderMaterial();
      THREE.ShaderMaterial.prototype.clone.call(this, material);
      return material;
    };
    THREE.SpriteMaterial = function(parameters) {
      THREE.Material.call(this);
      this.type = 'SpriteMaterial';
      this.color = new THREE.Color(0xffffff);
      this.map = null;
      this.rotation = 0;
      this.fog = false;
      this.setValues(parameters);
    };
    THREE.SpriteMaterial.prototype = Object.create(THREE.Material.prototype);
    THREE.SpriteMaterial.prototype.constructor = THREE.SpriteMaterial;
    THREE.SpriteMaterial.prototype.clone = function() {
      var material = new THREE.SpriteMaterial();
      THREE.Material.prototype.clone.call(this, material);
      material.color.copy(this.color);
      material.map = this.map;
      material.rotation = this.rotation;
      material.fog = this.fog;
      return material;
    };
    THREE.Texture = function(image, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy) {
      Object.defineProperty(this, 'id', {value: THREE.TextureIdCount++});
      this.uuid = THREE.Math.generateUUID();
      this.name = '';
      this.sourceFile = '';
      this.image = image !== undefined ? image : THREE.Texture.DEFAULT_IMAGE;
      this.mipmaps = [];
      this.mapping = mapping !== undefined ? mapping : THREE.Texture.DEFAULT_MAPPING;
      this.wrapS = wrapS !== undefined ? wrapS : THREE.ClampToEdgeWrapping;
      this.wrapT = wrapT !== undefined ? wrapT : THREE.ClampToEdgeWrapping;
      this.magFilter = magFilter !== undefined ? magFilter : THREE.LinearFilter;
      this.minFilter = minFilter !== undefined ? minFilter : THREE.LinearMipMapLinearFilter;
      this.anisotropy = anisotropy !== undefined ? anisotropy : 1;
      this.format = format !== undefined ? format : THREE.RGBAFormat;
      this.type = type !== undefined ? type : THREE.UnsignedByteType;
      this.offset = new THREE.Vector2(0, 0);
      this.repeat = new THREE.Vector2(1, 1);
      this.generateMipmaps = true;
      this.premultiplyAlpha = false;
      this.flipY = true;
      this.unpackAlignment = 4;
      this._needsUpdate = false;
      this.onUpdate = null;
    };
    THREE.Texture.DEFAULT_IMAGE = undefined;
    THREE.Texture.DEFAULT_MAPPING = THREE.UVMapping;
    THREE.Texture.prototype = {
      constructor: THREE.Texture,
      get needsUpdate() {
        return this._needsUpdate;
      },
      set needsUpdate(value) {
        if (value === true)
          this.update();
        this._needsUpdate = value;
      },
      clone: function(texture) {
        if (texture === undefined)
          texture = new THREE.Texture();
        texture.image = this.image;
        texture.mipmaps = this.mipmaps.slice(0);
        texture.mapping = this.mapping;
        texture.wrapS = this.wrapS;
        texture.wrapT = this.wrapT;
        texture.magFilter = this.magFilter;
        texture.minFilter = this.minFilter;
        texture.anisotropy = this.anisotropy;
        texture.format = this.format;
        texture.type = this.type;
        texture.offset.copy(this.offset);
        texture.repeat.copy(this.repeat);
        texture.generateMipmaps = this.generateMipmaps;
        texture.premultiplyAlpha = this.premultiplyAlpha;
        texture.flipY = this.flipY;
        texture.unpackAlignment = this.unpackAlignment;
        return texture;
      },
      update: function() {
        this.dispatchEvent({type: 'update'});
      },
      dispose: function() {
        this.dispatchEvent({type: 'dispose'});
      }
    };
    THREE.EventDispatcher.prototype.apply(THREE.Texture.prototype);
    THREE.TextureIdCount = 0;
    THREE.CubeTexture = function(images, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy) {
      mapping = mapping !== undefined ? mapping : THREE.CubeReflectionMapping;
      THREE.Texture.call(this, images, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy);
      this.images = images;
    };
    THREE.CubeTexture.prototype = Object.create(THREE.Texture.prototype);
    THREE.CubeTexture.prototype.constructor = THREE.CubeTexture;
    THREE.CubeTexture.clone = function(texture) {
      if (texture === undefined)
        texture = new THREE.CubeTexture();
      THREE.Texture.prototype.clone.call(this, texture);
      texture.images = this.images;
      return texture;
    };
    THREE.CompressedTexture = function(mipmaps, width, height, format, type, mapping, wrapS, wrapT, magFilter, minFilter, anisotropy) {
      THREE.Texture.call(this, null, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy);
      this.image = {
        width: width,
        height: height
      };
      this.mipmaps = mipmaps;
      this.flipY = false;
      this.generateMipmaps = false;
    };
    THREE.CompressedTexture.prototype = Object.create(THREE.Texture.prototype);
    THREE.CompressedTexture.prototype.constructor = THREE.CompressedTexture;
    THREE.CompressedTexture.prototype.clone = function() {
      var texture = new THREE.CompressedTexture();
      THREE.Texture.prototype.clone.call(this, texture);
      return texture;
    };
    THREE.DataTexture = function(data, width, height, format, type, mapping, wrapS, wrapT, magFilter, minFilter, anisotropy) {
      THREE.Texture.call(this, null, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy);
      this.image = {
        data: data,
        width: width,
        height: height
      };
    };
    THREE.DataTexture.prototype = Object.create(THREE.Texture.prototype);
    THREE.DataTexture.prototype.constructor = THREE.DataTexture;
    THREE.DataTexture.prototype.clone = function() {
      var texture = new THREE.DataTexture();
      THREE.Texture.prototype.clone.call(this, texture);
      return texture;
    };
    THREE.VideoTexture = function(video, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy) {
      THREE.Texture.call(this, video, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy);
      this.generateMipmaps = false;
      var scope = this;
      var update = function() {
        requestAnimationFrame(update);
        if (video.readyState === video.HAVE_ENOUGH_DATA) {
          scope.needsUpdate = true;
        }
      };
      update();
    };
    THREE.VideoTexture.prototype = Object.create(THREE.Texture.prototype);
    THREE.VideoTexture.prototype.constructor = THREE.VideoTexture;
    THREE.Group = function() {
      THREE.Object3D.call(this);
      this.type = 'Group';
    };
    THREE.Group.prototype = Object.create(THREE.Object3D.prototype);
    THREE.Group.prototype.constructor = THREE.Group;
    THREE.PointCloud = function(geometry, material) {
      THREE.Object3D.call(this);
      this.type = 'PointCloud';
      this.geometry = geometry !== undefined ? geometry : new THREE.Geometry();
      this.material = material !== undefined ? material : new THREE.PointCloudMaterial({color: Math.random() * 0xffffff});
    };
    THREE.PointCloud.prototype = Object.create(THREE.Object3D.prototype);
    THREE.PointCloud.prototype.constructor = THREE.PointCloud;
    THREE.PointCloud.prototype.raycast = (function() {
      var inverseMatrix = new THREE.Matrix4();
      var ray = new THREE.Ray();
      return function(raycaster, intersects) {
        var object = this;
        var geometry = object.geometry;
        var threshold = raycaster.params.PointCloud.threshold;
        inverseMatrix.getInverse(this.matrixWorld);
        ray.copy(raycaster.ray).applyMatrix4(inverseMatrix);
        if (geometry.boundingBox !== null) {
          if (ray.isIntersectionBox(geometry.boundingBox) === false) {
            return ;
          }
        }
        var localThreshold = threshold / ((this.scale.x + this.scale.y + this.scale.z) / 3);
        var position = new THREE.Vector3();
        var testPoint = function(point, index) {
          var rayPointDistance = ray.distanceToPoint(point);
          if (rayPointDistance < localThreshold) {
            var intersectPoint = ray.closestPointToPoint(point);
            intersectPoint.applyMatrix4(object.matrixWorld);
            var distance = raycaster.ray.origin.distanceTo(intersectPoint);
            intersects.push({
              distance: distance,
              distanceToRay: rayPointDistance,
              point: intersectPoint.clone(),
              index: index,
              face: null,
              object: object
            });
          }
        };
        if (geometry instanceof THREE.BufferGeometry) {
          var attributes = geometry.attributes;
          var positions = attributes.position.array;
          if (attributes.index !== undefined) {
            var indices = attributes.index.array;
            var offsets = geometry.offsets;
            if (offsets.length === 0) {
              var offset = {
                start: 0,
                count: indices.length,
                index: 0
              };
              offsets = [offset];
            }
            for (var oi = 0,
                ol = offsets.length; oi < ol; ++oi) {
              var start = offsets[oi].start;
              var count = offsets[oi].count;
              var index = offsets[oi].index;
              for (var i = start,
                  il = start + count; i < il; i++) {
                var a = index + indices[i];
                position.fromArray(positions, a * 3);
                testPoint(position, a);
              }
            }
          } else {
            var pointCount = positions.length / 3;
            for (var i = 0; i < pointCount; i++) {
              position.set(positions[3 * i], positions[3 * i + 1], positions[3 * i + 2]);
              testPoint(position, i);
            }
          }
        } else {
          var vertices = this.geometry.vertices;
          for (var i = 0; i < vertices.length; i++) {
            testPoint(vertices[i], i);
          }
        }
      };
    }());
    THREE.PointCloud.prototype.clone = function(object) {
      if (object === undefined)
        object = new THREE.PointCloud(this.geometry, this.material);
      THREE.Object3D.prototype.clone.call(this, object);
      return object;
    };
    THREE.ParticleSystem = function(geometry, material) {
      THREE.warn('THREE.ParticleSystem has been renamed to THREE.PointCloud.');
      return new THREE.PointCloud(geometry, material);
    };
    THREE.Line = function(geometry, material, mode) {
      THREE.Object3D.call(this);
      this.type = 'Line';
      this.geometry = geometry !== undefined ? geometry : new THREE.Geometry();
      this.material = material !== undefined ? material : new THREE.LineBasicMaterial({color: Math.random() * 0xffffff});
      this.mode = mode !== undefined ? mode : THREE.LineStrip;
    };
    THREE.LineStrip = 0;
    THREE.LinePieces = 1;
    THREE.Line.prototype = Object.create(THREE.Object3D.prototype);
    THREE.Line.prototype.constructor = THREE.Line;
    THREE.Line.prototype.raycast = (function() {
      var inverseMatrix = new THREE.Matrix4();
      var ray = new THREE.Ray();
      var sphere = new THREE.Sphere();
      return function(raycaster, intersects) {
        var precision = raycaster.linePrecision;
        var precisionSq = precision * precision;
        var geometry = this.geometry;
        if (geometry.boundingSphere === null)
          geometry.computeBoundingSphere();
        sphere.copy(geometry.boundingSphere);
        sphere.applyMatrix4(this.matrixWorld);
        if (raycaster.ray.isIntersectionSphere(sphere) === false) {
          return ;
        }
        inverseMatrix.getInverse(this.matrixWorld);
        ray.copy(raycaster.ray).applyMatrix4(inverseMatrix);
        var vStart = new THREE.Vector3();
        var vEnd = new THREE.Vector3();
        var interSegment = new THREE.Vector3();
        var interRay = new THREE.Vector3();
        var step = this.mode === THREE.LineStrip ? 1 : 2;
        if (geometry instanceof THREE.BufferGeometry) {
          var attributes = geometry.attributes;
          if (attributes.index !== undefined) {
            var indices = attributes.index.array;
            var positions = attributes.position.array;
            var offsets = geometry.offsets;
            if (offsets.length === 0) {
              offsets = [{
                start: 0,
                count: indices.length,
                index: 0
              }];
            }
            for (var oi = 0; oi < offsets.length; oi++) {
              var start = offsets[oi].start;
              var count = offsets[oi].count;
              var index = offsets[oi].index;
              for (var i = start; i < start + count - 1; i += step) {
                var a = index + indices[i];
                var b = index + indices[i + 1];
                vStart.fromArray(positions, a * 3);
                vEnd.fromArray(positions, b * 3);
                var distSq = ray.distanceSqToSegment(vStart, vEnd, interRay, interSegment);
                if (distSq > precisionSq)
                  continue;
                var distance = ray.origin.distanceTo(interRay);
                if (distance < raycaster.near || distance > raycaster.far)
                  continue;
                intersects.push({
                  distance: distance,
                  point: interSegment.clone().applyMatrix4(this.matrixWorld),
                  index: i,
                  offsetIndex: oi,
                  face: null,
                  faceIndex: null,
                  object: this
                });
              }
            }
          } else {
            var positions = attributes.position.array;
            for (var i = 0; i < positions.length / 3 - 1; i += step) {
              vStart.fromArray(positions, 3 * i);
              vEnd.fromArray(positions, 3 * i + 3);
              var distSq = ray.distanceSqToSegment(vStart, vEnd, interRay, interSegment);
              if (distSq > precisionSq)
                continue;
              var distance = ray.origin.distanceTo(interRay);
              if (distance < raycaster.near || distance > raycaster.far)
                continue;
              intersects.push({
                distance: distance,
                point: interSegment.clone().applyMatrix4(this.matrixWorld),
                index: i,
                face: null,
                faceIndex: null,
                object: this
              });
            }
          }
        } else if (geometry instanceof THREE.Geometry) {
          var vertices = geometry.vertices;
          var nbVertices = vertices.length;
          for (var i = 0; i < nbVertices - 1; i += step) {
            var distSq = ray.distanceSqToSegment(vertices[i], vertices[i + 1], interRay, interSegment);
            if (distSq > precisionSq)
              continue;
            var distance = ray.origin.distanceTo(interRay);
            if (distance < raycaster.near || distance > raycaster.far)
              continue;
            intersects.push({
              distance: distance,
              point: interSegment.clone().applyMatrix4(this.matrixWorld),
              index: i,
              face: null,
              faceIndex: null,
              object: this
            });
          }
        }
      };
    }());
    THREE.Line.prototype.clone = function(object) {
      if (object === undefined)
        object = new THREE.Line(this.geometry, this.material, this.mode);
      THREE.Object3D.prototype.clone.call(this, object);
      return object;
    };
    THREE.Mesh = function(geometry, material) {
      THREE.Object3D.call(this);
      this.type = 'Mesh';
      this.geometry = geometry !== undefined ? geometry : new THREE.Geometry();
      this.material = material !== undefined ? material : new THREE.MeshBasicMaterial({color: Math.random() * 0xffffff});
      this.updateMorphTargets();
    };
    THREE.Mesh.prototype = Object.create(THREE.Object3D.prototype);
    THREE.Mesh.prototype.constructor = THREE.Mesh;
    THREE.Mesh.prototype.updateMorphTargets = function() {
      if (this.geometry.morphTargets !== undefined && this.geometry.morphTargets.length > 0) {
        this.morphTargetBase = -1;
        this.morphTargetForcedOrder = [];
        this.morphTargetInfluences = [];
        this.morphTargetDictionary = {};
        for (var m = 0,
            ml = this.geometry.morphTargets.length; m < ml; m++) {
          this.morphTargetInfluences.push(0);
          this.morphTargetDictionary[this.geometry.morphTargets[m].name] = m;
        }
      }
    };
    THREE.Mesh.prototype.getMorphTargetIndexByName = function(name) {
      if (this.morphTargetDictionary[name] !== undefined) {
        return this.morphTargetDictionary[name];
      }
      THREE.warn('THREE.Mesh.getMorphTargetIndexByName: morph target ' + name + ' does not exist. Returning 0.');
      return 0;
    };
    THREE.Mesh.prototype.raycast = (function() {
      var inverseMatrix = new THREE.Matrix4();
      var ray = new THREE.Ray();
      var sphere = new THREE.Sphere();
      var vA = new THREE.Vector3();
      var vB = new THREE.Vector3();
      var vC = new THREE.Vector3();
      return function(raycaster, intersects) {
        var geometry = this.geometry;
        if (geometry.boundingSphere === null)
          geometry.computeBoundingSphere();
        sphere.copy(geometry.boundingSphere);
        sphere.applyMatrix4(this.matrixWorld);
        if (raycaster.ray.isIntersectionSphere(sphere) === false) {
          return ;
        }
        inverseMatrix.getInverse(this.matrixWorld);
        ray.copy(raycaster.ray).applyMatrix4(inverseMatrix);
        if (geometry.boundingBox !== null) {
          if (ray.isIntersectionBox(geometry.boundingBox) === false) {
            return ;
          }
        }
        if (geometry instanceof THREE.BufferGeometry) {
          var material = this.material;
          if (material === undefined)
            return ;
          var attributes = geometry.attributes;
          var a,
              b,
              c;
          var precision = raycaster.precision;
          if (attributes.index !== undefined) {
            var indices = attributes.index.array;
            var positions = attributes.position.array;
            var offsets = geometry.offsets;
            if (offsets.length === 0) {
              offsets = [{
                start: 0,
                count: indices.length,
                index: 0
              }];
            }
            for (var oi = 0,
                ol = offsets.length; oi < ol; ++oi) {
              var start = offsets[oi].start;
              var count = offsets[oi].count;
              var index = offsets[oi].index;
              for (var i = start,
                  il = start + count; i < il; i += 3) {
                a = index + indices[i];
                b = index + indices[i + 1];
                c = index + indices[i + 2];
                vA.fromArray(positions, a * 3);
                vB.fromArray(positions, b * 3);
                vC.fromArray(positions, c * 3);
                if (material.side === THREE.BackSide) {
                  var intersectionPoint = ray.intersectTriangle(vC, vB, vA, true);
                } else {
                  var intersectionPoint = ray.intersectTriangle(vA, vB, vC, material.side !== THREE.DoubleSide);
                }
                if (intersectionPoint === null)
                  continue;
                intersectionPoint.applyMatrix4(this.matrixWorld);
                var distance = raycaster.ray.origin.distanceTo(intersectionPoint);
                if (distance < precision || distance < raycaster.near || distance > raycaster.far)
                  continue;
                intersects.push({
                  distance: distance,
                  point: intersectionPoint,
                  face: new THREE.Face3(a, b, c, THREE.Triangle.normal(vA, vB, vC)),
                  faceIndex: null,
                  object: this
                });
              }
            }
          } else {
            var positions = attributes.position.array;
            for (var i = 0,
                j = 0,
                il = positions.length; i < il; i += 3, j += 9) {
              a = i;
              b = i + 1;
              c = i + 2;
              vA.fromArray(positions, j);
              vB.fromArray(positions, j + 3);
              vC.fromArray(positions, j + 6);
              if (material.side === THREE.BackSide) {
                var intersectionPoint = ray.intersectTriangle(vC, vB, vA, true);
              } else {
                var intersectionPoint = ray.intersectTriangle(vA, vB, vC, material.side !== THREE.DoubleSide);
              }
              if (intersectionPoint === null)
                continue;
              intersectionPoint.applyMatrix4(this.matrixWorld);
              var distance = raycaster.ray.origin.distanceTo(intersectionPoint);
              if (distance < precision || distance < raycaster.near || distance > raycaster.far)
                continue;
              intersects.push({
                distance: distance,
                point: intersectionPoint,
                face: new THREE.Face3(a, b, c, THREE.Triangle.normal(vA, vB, vC)),
                faceIndex: null,
                object: this
              });
            }
          }
        } else if (geometry instanceof THREE.Geometry) {
          var isFaceMaterial = this.material instanceof THREE.MeshFaceMaterial;
          var objectMaterials = isFaceMaterial === true ? this.material.materials : null;
          var a,
              b,
              c;
          var precision = raycaster.precision;
          var vertices = geometry.vertices;
          for (var f = 0,
              fl = geometry.faces.length; f < fl; f++) {
            var face = geometry.faces[f];
            var material = isFaceMaterial === true ? objectMaterials[face.materialIndex] : this.material;
            if (material === undefined)
              continue;
            a = vertices[face.a];
            b = vertices[face.b];
            c = vertices[face.c];
            if (material.morphTargets === true) {
              var morphTargets = geometry.morphTargets;
              var morphInfluences = this.morphTargetInfluences;
              vA.set(0, 0, 0);
              vB.set(0, 0, 0);
              vC.set(0, 0, 0);
              for (var t = 0,
                  tl = morphTargets.length; t < tl; t++) {
                var influence = morphInfluences[t];
                if (influence === 0)
                  continue;
                var targets = morphTargets[t].vertices;
                vA.x += (targets[face.a].x - a.x) * influence;
                vA.y += (targets[face.a].y - a.y) * influence;
                vA.z += (targets[face.a].z - a.z) * influence;
                vB.x += (targets[face.b].x - b.x) * influence;
                vB.y += (targets[face.b].y - b.y) * influence;
                vB.z += (targets[face.b].z - b.z) * influence;
                vC.x += (targets[face.c].x - c.x) * influence;
                vC.y += (targets[face.c].y - c.y) * influence;
                vC.z += (targets[face.c].z - c.z) * influence;
              }
              vA.add(a);
              vB.add(b);
              vC.add(c);
              a = vA;
              b = vB;
              c = vC;
            }
            if (material.side === THREE.BackSide) {
              var intersectionPoint = ray.intersectTriangle(c, b, a, true);
            } else {
              var intersectionPoint = ray.intersectTriangle(a, b, c, material.side !== THREE.DoubleSide);
            }
            if (intersectionPoint === null)
              continue;
            intersectionPoint.applyMatrix4(this.matrixWorld);
            var distance = raycaster.ray.origin.distanceTo(intersectionPoint);
            if (distance < precision || distance < raycaster.near || distance > raycaster.far)
              continue;
            intersects.push({
              distance: distance,
              point: intersectionPoint,
              face: face,
              faceIndex: f,
              object: this
            });
          }
        }
      };
    }());
    THREE.Mesh.prototype.clone = function(object, recursive) {
      if (object === undefined)
        object = new THREE.Mesh(this.geometry, this.material);
      THREE.Object3D.prototype.clone.call(this, object, recursive);
      return object;
    };
    THREE.Bone = function(skin) {
      THREE.Object3D.call(this);
      this.type = 'Bone';
      this.skin = skin;
    };
    THREE.Bone.prototype = Object.create(THREE.Object3D.prototype);
    THREE.Bone.prototype.constructor = THREE.Bone;
    THREE.Skeleton = function(bones, boneInverses, useVertexTexture) {
      this.useVertexTexture = useVertexTexture !== undefined ? useVertexTexture : true;
      this.identityMatrix = new THREE.Matrix4();
      bones = bones || [];
      this.bones = bones.slice(0);
      if (this.useVertexTexture) {
        var size;
        if (this.bones.length > 256)
          size = 64;
        else if (this.bones.length > 64)
          size = 32;
        else if (this.bones.length > 16)
          size = 16;
        else
          size = 8;
        this.boneTextureWidth = size;
        this.boneTextureHeight = size;
        this.boneMatrices = new Float32Array(this.boneTextureWidth * this.boneTextureHeight * 4);
        this.boneTexture = new THREE.DataTexture(this.boneMatrices, this.boneTextureWidth, this.boneTextureHeight, THREE.RGBAFormat, THREE.FloatType);
        this.boneTexture.minFilter = THREE.NearestFilter;
        this.boneTexture.magFilter = THREE.NearestFilter;
        this.boneTexture.generateMipmaps = false;
        this.boneTexture.flipY = false;
      } else {
        this.boneMatrices = new Float32Array(16 * this.bones.length);
      }
      if (boneInverses === undefined) {
        this.calculateInverses();
      } else {
        if (this.bones.length === boneInverses.length) {
          this.boneInverses = boneInverses.slice(0);
        } else {
          THREE.warn('THREE.Skeleton bonInverses is the wrong length.');
          this.boneInverses = [];
          for (var b = 0,
              bl = this.bones.length; b < bl; b++) {
            this.boneInverses.push(new THREE.Matrix4());
          }
        }
      }
    };
    THREE.Skeleton.prototype.calculateInverses = function() {
      this.boneInverses = [];
      for (var b = 0,
          bl = this.bones.length; b < bl; b++) {
        var inverse = new THREE.Matrix4();
        if (this.bones[b]) {
          inverse.getInverse(this.bones[b].matrixWorld);
        }
        this.boneInverses.push(inverse);
      }
    };
    THREE.Skeleton.prototype.pose = function() {
      var bone;
      for (var b = 0,
          bl = this.bones.length; b < bl; b++) {
        bone = this.bones[b];
        if (bone) {
          bone.matrixWorld.getInverse(this.boneInverses[b]);
        }
      }
      for (var b = 0,
          bl = this.bones.length; b < bl; b++) {
        bone = this.bones[b];
        if (bone) {
          if (bone.parent) {
            bone.matrix.getInverse(bone.parent.matrixWorld);
            bone.matrix.multiply(bone.matrixWorld);
          } else {
            bone.matrix.copy(bone.matrixWorld);
          }
          bone.matrix.decompose(bone.position, bone.quaternion, bone.scale);
        }
      }
    };
    THREE.Skeleton.prototype.update = (function() {
      var offsetMatrix = new THREE.Matrix4();
      return function() {
        for (var b = 0,
            bl = this.bones.length; b < bl; b++) {
          var matrix = this.bones[b] ? this.bones[b].matrixWorld : this.identityMatrix;
          offsetMatrix.multiplyMatrices(matrix, this.boneInverses[b]);
          offsetMatrix.flattenToArrayOffset(this.boneMatrices, b * 16);
        }
        if (this.useVertexTexture) {
          this.boneTexture.needsUpdate = true;
        }
      };
    })();
    THREE.SkinnedMesh = function(geometry, material, useVertexTexture) {
      THREE.Mesh.call(this, geometry, material);
      this.type = 'SkinnedMesh';
      this.bindMode = "attached";
      this.bindMatrix = new THREE.Matrix4();
      this.bindMatrixInverse = new THREE.Matrix4();
      var bones = [];
      if (this.geometry && this.geometry.bones !== undefined) {
        var bone,
            gbone,
            p,
            q,
            s;
        for (var b = 0,
            bl = this.geometry.bones.length; b < bl; ++b) {
          gbone = this.geometry.bones[b];
          p = gbone.pos;
          q = gbone.rotq;
          s = gbone.scl;
          bone = new THREE.Bone(this);
          bones.push(bone);
          bone.name = gbone.name;
          bone.position.set(p[0], p[1], p[2]);
          bone.quaternion.set(q[0], q[1], q[2], q[3]);
          if (s !== undefined) {
            bone.scale.set(s[0], s[1], s[2]);
          } else {
            bone.scale.set(1, 1, 1);
          }
        }
        for (var b = 0,
            bl = this.geometry.bones.length; b < bl; ++b) {
          gbone = this.geometry.bones[b];
          if (gbone.parent !== -1) {
            bones[gbone.parent].add(bones[b]);
          } else {
            this.add(bones[b]);
          }
        }
      }
      this.normalizeSkinWeights();
      this.updateMatrixWorld(true);
      this.bind(new THREE.Skeleton(bones, undefined, useVertexTexture));
    };
    THREE.SkinnedMesh.prototype = Object.create(THREE.Mesh.prototype);
    THREE.SkinnedMesh.prototype.constructor = THREE.SkinnedMesh;
    THREE.SkinnedMesh.prototype.bind = function(skeleton, bindMatrix) {
      this.skeleton = skeleton;
      if (bindMatrix === undefined) {
        this.updateMatrixWorld(true);
        bindMatrix = this.matrixWorld;
      }
      this.bindMatrix.copy(bindMatrix);
      this.bindMatrixInverse.getInverse(bindMatrix);
    };
    THREE.SkinnedMesh.prototype.pose = function() {
      this.skeleton.pose();
    };
    THREE.SkinnedMesh.prototype.normalizeSkinWeights = function() {
      if (this.geometry instanceof THREE.Geometry) {
        for (var i = 0; i < this.geometry.skinIndices.length; i++) {
          var sw = this.geometry.skinWeights[i];
          var scale = 1.0 / sw.lengthManhattan();
          if (scale !== Infinity) {
            sw.multiplyScalar(scale);
          } else {
            sw.set(1);
          }
        }
      } else {}
    };
    THREE.SkinnedMesh.prototype.updateMatrixWorld = function(force) {
      THREE.Mesh.prototype.updateMatrixWorld.call(this, true);
      if (this.bindMode === "attached") {
        this.bindMatrixInverse.getInverse(this.matrixWorld);
      } else if (this.bindMode === "detached") {
        this.bindMatrixInverse.getInverse(this.bindMatrix);
      } else {
        THREE.warn('THREE.SkinnedMesh unreckognized bindMode: ' + this.bindMode);
      }
    };
    THREE.SkinnedMesh.prototype.clone = function(object) {
      if (object === undefined) {
        object = new THREE.SkinnedMesh(this.geometry, this.material, this.useVertexTexture);
      }
      THREE.Mesh.prototype.clone.call(this, object);
      return object;
    };
    THREE.MorphAnimMesh = function(geometry, material) {
      THREE.Mesh.call(this, geometry, material);
      this.type = 'MorphAnimMesh';
      this.duration = 1000;
      this.mirroredLoop = false;
      this.time = 0;
      this.lastKeyframe = 0;
      this.currentKeyframe = 0;
      this.direction = 1;
      this.directionBackwards = false;
      this.setFrameRange(0, this.geometry.morphTargets.length - 1);
    };
    THREE.MorphAnimMesh.prototype = Object.create(THREE.Mesh.prototype);
    THREE.MorphAnimMesh.prototype.constructor = THREE.MorphAnimMesh;
    THREE.MorphAnimMesh.prototype.setFrameRange = function(start, end) {
      this.startKeyframe = start;
      this.endKeyframe = end;
      this.length = this.endKeyframe - this.startKeyframe + 1;
    };
    THREE.MorphAnimMesh.prototype.setDirectionForward = function() {
      this.direction = 1;
      this.directionBackwards = false;
    };
    THREE.MorphAnimMesh.prototype.setDirectionBackward = function() {
      this.direction = -1;
      this.directionBackwards = true;
    };
    THREE.MorphAnimMesh.prototype.parseAnimations = function() {
      var geometry = this.geometry;
      if (!geometry.animations)
        geometry.animations = {};
      var firstAnimation,
          animations = geometry.animations;
      var pattern = /([a-z]+)_?(\d+)/;
      for (var i = 0,
          il = geometry.morphTargets.length; i < il; i++) {
        var morph = geometry.morphTargets[i];
        var parts = morph.name.match(pattern);
        if (parts && parts.length > 1) {
          var label = parts[1];
          if (!animations[label])
            animations[label] = {
              start: Infinity,
              end: -Infinity
            };
          var animation = animations[label];
          if (i < animation.start)
            animation.start = i;
          if (i > animation.end)
            animation.end = i;
          if (!firstAnimation)
            firstAnimation = label;
        }
      }
      geometry.firstAnimation = firstAnimation;
    };
    THREE.MorphAnimMesh.prototype.setAnimationLabel = function(label, start, end) {
      if (!this.geometry.animations)
        this.geometry.animations = {};
      this.geometry.animations[label] = {
        start: start,
        end: end
      };
    };
    THREE.MorphAnimMesh.prototype.playAnimation = function(label, fps) {
      var animation = this.geometry.animations[label];
      if (animation) {
        this.setFrameRange(animation.start, animation.end);
        this.duration = 1000 * ((animation.end - animation.start) / fps);
        this.time = 0;
      } else {
        THREE.warn('THREE.MorphAnimMesh: animation[' + label + '] undefined in .playAnimation()');
      }
    };
    THREE.MorphAnimMesh.prototype.updateAnimation = function(delta) {
      var frameTime = this.duration / this.length;
      this.time += this.direction * delta;
      if (this.mirroredLoop) {
        if (this.time > this.duration || this.time < 0) {
          this.direction *= -1;
          if (this.time > this.duration) {
            this.time = this.duration;
            this.directionBackwards = true;
          }
          if (this.time < 0) {
            this.time = 0;
            this.directionBackwards = false;
          }
        }
      } else {
        this.time = this.time % this.duration;
        if (this.time < 0)
          this.time += this.duration;
      }
      var keyframe = this.startKeyframe + THREE.Math.clamp(Math.floor(this.time / frameTime), 0, this.length - 1);
      if (keyframe !== this.currentKeyframe) {
        this.morphTargetInfluences[this.lastKeyframe] = 0;
        this.morphTargetInfluences[this.currentKeyframe] = 1;
        this.morphTargetInfluences[keyframe] = 0;
        this.lastKeyframe = this.currentKeyframe;
        this.currentKeyframe = keyframe;
      }
      var mix = (this.time % frameTime) / frameTime;
      if (this.directionBackwards) {
        mix = 1 - mix;
      }
      this.morphTargetInfluences[this.currentKeyframe] = mix;
      this.morphTargetInfluences[this.lastKeyframe] = 1 - mix;
    };
    THREE.MorphAnimMesh.prototype.interpolateTargets = function(a, b, t) {
      var influences = this.morphTargetInfluences;
      for (var i = 0,
          l = influences.length; i < l; i++) {
        influences[i] = 0;
      }
      if (a > -1)
        influences[a] = 1 - t;
      if (b > -1)
        influences[b] = t;
    };
    THREE.MorphAnimMesh.prototype.clone = function(object) {
      if (object === undefined)
        object = new THREE.MorphAnimMesh(this.geometry, this.material);
      object.duration = this.duration;
      object.mirroredLoop = this.mirroredLoop;
      object.time = this.time;
      object.lastKeyframe = this.lastKeyframe;
      object.currentKeyframe = this.currentKeyframe;
      object.direction = this.direction;
      object.directionBackwards = this.directionBackwards;
      THREE.Mesh.prototype.clone.call(this, object);
      return object;
    };
    THREE.LOD = function() {
      THREE.Object3D.call(this);
      this.objects = [];
    };
    THREE.LOD.prototype = Object.create(THREE.Object3D.prototype);
    THREE.LOD.prototype.constructor = THREE.LOD;
    THREE.LOD.prototype.addLevel = function(object, distance) {
      if (distance === undefined)
        distance = 0;
      distance = Math.abs(distance);
      for (var l = 0; l < this.objects.length; l++) {
        if (distance < this.objects[l].distance) {
          break;
        }
      }
      this.objects.splice(l, 0, {
        distance: distance,
        object: object
      });
      this.add(object);
    };
    THREE.LOD.prototype.getObjectForDistance = function(distance) {
      for (var i = 1,
          l = this.objects.length; i < l; i++) {
        if (distance < this.objects[i].distance) {
          break;
        }
      }
      return this.objects[i - 1].object;
    };
    THREE.LOD.prototype.raycast = (function() {
      var matrixPosition = new THREE.Vector3();
      return function(raycaster, intersects) {
        matrixPosition.setFromMatrixPosition(this.matrixWorld);
        var distance = raycaster.ray.origin.distanceTo(matrixPosition);
        this.getObjectForDistance(distance).raycast(raycaster, intersects);
      };
    }());
    THREE.LOD.prototype.update = function() {
      var v1 = new THREE.Vector3();
      var v2 = new THREE.Vector3();
      return function(camera) {
        if (this.objects.length > 1) {
          v1.setFromMatrixPosition(camera.matrixWorld);
          v2.setFromMatrixPosition(this.matrixWorld);
          var distance = v1.distanceTo(v2);
          this.objects[0].object.visible = true;
          for (var i = 1,
              l = this.objects.length; i < l; i++) {
            if (distance >= this.objects[i].distance) {
              this.objects[i - 1].object.visible = false;
              this.objects[i].object.visible = true;
            } else {
              break;
            }
          }
          for (; i < l; i++) {
            this.objects[i].object.visible = false;
          }
        }
      };
    }();
    THREE.LOD.prototype.clone = function(object) {
      if (object === undefined)
        object = new THREE.LOD();
      THREE.Object3D.prototype.clone.call(this, object);
      for (var i = 0,
          l = this.objects.length; i < l; i++) {
        var x = this.objects[i].object.clone();
        x.visible = i === 0;
        object.addLevel(x, this.objects[i].distance);
      }
      return object;
    };
    THREE.Sprite = (function() {
      var indices = new Uint16Array([0, 1, 2, 0, 2, 3]);
      var vertices = new Float32Array([-0.5, -0.5, 0, 0.5, -0.5, 0, 0.5, 0.5, 0, -0.5, 0.5, 0]);
      var uvs = new Float32Array([0, 0, 1, 0, 1, 1, 0, 1]);
      var geometry = new THREE.BufferGeometry();
      geometry.addAttribute('index', new THREE.BufferAttribute(indices, 1));
      geometry.addAttribute('position', new THREE.BufferAttribute(vertices, 3));
      geometry.addAttribute('uv', new THREE.BufferAttribute(uvs, 2));
      return function(material) {
        THREE.Object3D.call(this);
        this.type = 'Sprite';
        this.geometry = geometry;
        this.material = (material !== undefined) ? material : new THREE.SpriteMaterial();
      };
    })();
    THREE.Sprite.prototype = Object.create(THREE.Object3D.prototype);
    THREE.Sprite.prototype.constructor = THREE.Sprite;
    THREE.Sprite.prototype.raycast = (function() {
      var matrixPosition = new THREE.Vector3();
      return function(raycaster, intersects) {
        matrixPosition.setFromMatrixPosition(this.matrixWorld);
        var distance = raycaster.ray.distanceToPoint(matrixPosition);
        if (distance > this.scale.x) {
          return ;
        }
        intersects.push({
          distance: distance,
          point: this.position,
          face: null,
          object: this
        });
      };
    }());
    THREE.Sprite.prototype.clone = function(object) {
      if (object === undefined)
        object = new THREE.Sprite(this.material);
      THREE.Object3D.prototype.clone.call(this, object);
      return object;
    };
    THREE.Particle = THREE.Sprite;
    THREE.LensFlare = function(texture, size, distance, blending, color) {
      THREE.Object3D.call(this);
      this.lensFlares = [];
      this.positionScreen = new THREE.Vector3();
      this.customUpdateCallback = undefined;
      if (texture !== undefined) {
        this.add(texture, size, distance, blending, color);
      }
    };
    THREE.LensFlare.prototype = Object.create(THREE.Object3D.prototype);
    THREE.LensFlare.prototype.constructor = THREE.LensFlare;
    THREE.LensFlare.prototype.add = function(texture, size, distance, blending, color, opacity) {
      if (size === undefined)
        size = -1;
      if (distance === undefined)
        distance = 0;
      if (opacity === undefined)
        opacity = 1;
      if (color === undefined)
        color = new THREE.Color(0xffffff);
      if (blending === undefined)
        blending = THREE.NormalBlending;
      distance = Math.min(distance, Math.max(0, distance));
      this.lensFlares.push({
        texture: texture,
        size: size,
        distance: distance,
        x: 0,
        y: 0,
        z: 0,
        scale: 1,
        rotation: 1,
        opacity: opacity,
        color: color,
        blending: blending
      });
    };
    THREE.LensFlare.prototype.updateLensFlares = function() {
      var f,
          fl = this.lensFlares.length;
      var flare;
      var vecX = -this.positionScreen.x * 2;
      var vecY = -this.positionScreen.y * 2;
      for (f = 0; f < fl; f++) {
        flare = this.lensFlares[f];
        flare.x = this.positionScreen.x + vecX * flare.distance;
        flare.y = this.positionScreen.y + vecY * flare.distance;
        flare.wantedRotation = flare.x * Math.PI * 0.25;
        flare.rotation += (flare.wantedRotation - flare.rotation) * 0.25;
      }
    };
    THREE.Scene = function() {
      THREE.Object3D.call(this);
      this.type = 'Scene';
      this.fog = null;
      this.overrideMaterial = null;
      this.autoUpdate = true;
    };
    THREE.Scene.prototype = Object.create(THREE.Object3D.prototype);
    THREE.Scene.prototype.constructor = THREE.Scene;
    THREE.Scene.prototype.clone = function(object) {
      if (object === undefined)
        object = new THREE.Scene();
      THREE.Object3D.prototype.clone.call(this, object);
      if (this.fog !== null)
        object.fog = this.fog.clone();
      if (this.overrideMaterial !== null)
        object.overrideMaterial = this.overrideMaterial.clone();
      object.autoUpdate = this.autoUpdate;
      object.matrixAutoUpdate = this.matrixAutoUpdate;
      return object;
    };
    THREE.Fog = function(color, near, far) {
      this.name = '';
      this.color = new THREE.Color(color);
      this.near = (near !== undefined) ? near : 1;
      this.far = (far !== undefined) ? far : 1000;
    };
    THREE.Fog.prototype.clone = function() {
      return new THREE.Fog(this.color.getHex(), this.near, this.far);
    };
    THREE.FogExp2 = function(color, density) {
      this.name = '';
      this.color = new THREE.Color(color);
      this.density = (density !== undefined) ? density : 0.00025;
    };
    THREE.FogExp2.prototype.clone = function() {
      return new THREE.FogExp2(this.color.getHex(), this.density);
    };
    THREE.ShaderChunk = {};
    THREE.ShaderChunk['common'] = "#define PI 3.14159\n#define PI2 6.28318\n#define RECIPROCAL_PI2 0.15915494\n#define LOG2 1.442695\n#define EPSILON 1e-6\n\nfloat square( in float a ) { return a*a; }\nvec2  square( in vec2 a )  { return vec2( a.x*a.x, a.y*a.y ); }\nvec3  square( in vec3 a )  { return vec3( a.x*a.x, a.y*a.y, a.z*a.z ); }\nvec4  square( in vec4 a )  { return vec4( a.x*a.x, a.y*a.y, a.z*a.z, a.w*a.w ); }\nfloat saturate( in float a ) { return clamp( a, 0.0, 1.0 ); }\nvec2  saturate( in vec2 a )  { return clamp( a, 0.0, 1.0 ); }\nvec3  saturate( in vec3 a )  { return clamp( a, 0.0, 1.0 ); }\nvec4  saturate( in vec4 a )  { return clamp( a, 0.0, 1.0 ); }\nfloat average( in float a ) { return a; }\nfloat average( in vec2 a )  { return ( a.x + a.y) * 0.5; }\nfloat average( in vec3 a )  { return ( a.x + a.y + a.z) / 3.0; }\nfloat average( in vec4 a )  { return ( a.x + a.y + a.z + a.w) * 0.25; }\nfloat whiteCompliment( in float a ) { return saturate( 1.0 - a ); }\nvec2  whiteCompliment( in vec2 a )  { return saturate( vec2(1.0) - a ); }\nvec3  whiteCompliment( in vec3 a )  { return saturate( vec3(1.0) - a ); }\nvec4  whiteCompliment( in vec4 a )  { return saturate( vec4(1.0) - a ); }\nvec3 transformDirection( in vec3 normal, in mat4 matrix ) {\n	return normalize( ( matrix * vec4( normal, 0.0 ) ).xyz );\n}\n// http://en.wikibooks.org/wiki/GLSL_Programming/Applying_Matrix_Transformations\nvec3 inverseTransformDirection( in vec3 normal, in mat4 matrix ) {\n	return normalize( ( vec4( normal, 0.0 ) * matrix ).xyz );\n}\nvec3 projectOnPlane(in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal) {\n	float distance = dot( planeNormal, point-pointOnPlane );\n	return point - distance * planeNormal;\n}\nfloat sideOfPlane( in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {\n	return sign( dot( point - pointOnPlane, planeNormal ) );\n}\nvec3 linePlaneIntersect( in vec3 pointOnLine, in vec3 lineDirection, in vec3 pointOnPlane, in vec3 planeNormal ) {\n	return pointOnLine + lineDirection * ( dot( planeNormal, pointOnPlane - pointOnLine ) / dot( planeNormal, lineDirection ) );\n}\nfloat calcLightAttenuation( float lightDistance, float cutoffDistance, float decayExponent ) {\n	if ( decayExponent > 0.0 ) {\n	  return pow( saturate( 1.0 - lightDistance / cutoffDistance ), decayExponent );\n	}\n	return 1.0;\n}\n\nvec3 inputToLinear( in vec3 a ) {\n#ifdef GAMMA_INPUT\n	return pow( a, vec3( float( GAMMA_FACTOR ) ) );\n#else\n	return a;\n#endif\n}\nvec3 linearToOutput( in vec3 a ) {\n#ifdef GAMMA_OUTPUT\n	return pow( a, vec3( 1.0 / float( GAMMA_FACTOR ) ) );\n#else\n	return a;\n#endif\n}\n";
    THREE.ShaderChunk['alphatest_fragment'] = "#ifdef ALPHATEST\n\n	if ( diffuseColor.a < ALPHATEST ) discard;\n\n#endif\n";
    THREE.ShaderChunk['lights_lambert_vertex'] = "vLightFront = vec3( 0.0 );\n\n#ifdef DOUBLE_SIDED\n\n	vLightBack = vec3( 0.0 );\n\n#endif\n\ntransformedNormal = normalize( transformedNormal );\n\n#if MAX_DIR_LIGHTS > 0\n\nfor( int i = 0; i < MAX_DIR_LIGHTS; i ++ ) {\n\n	vec3 dirVector = transformDirection( directionalLightDirection[ i ], viewMatrix );\n\n	float dotProduct = dot( transformedNormal, dirVector );\n	vec3 directionalLightWeighting = vec3( max( dotProduct, 0.0 ) );\n\n	#ifdef DOUBLE_SIDED\n\n		vec3 directionalLightWeightingBack = vec3( max( -dotProduct, 0.0 ) );\n\n		#ifdef WRAP_AROUND\n\n			vec3 directionalLightWeightingHalfBack = vec3( max( -0.5 * dotProduct + 0.5, 0.0 ) );\n\n		#endif\n\n	#endif\n\n	#ifdef WRAP_AROUND\n\n		vec3 directionalLightWeightingHalf = vec3( max( 0.5 * dotProduct + 0.5, 0.0 ) );\n		directionalLightWeighting = mix( directionalLightWeighting, directionalLightWeightingHalf, wrapRGB );\n\n		#ifdef DOUBLE_SIDED\n\n			directionalLightWeightingBack = mix( directionalLightWeightingBack, directionalLightWeightingHalfBack, wrapRGB );\n\n		#endif\n\n	#endif\n\n	vLightFront += directionalLightColor[ i ] * directionalLightWeighting;\n\n	#ifdef DOUBLE_SIDED\n\n		vLightBack += directionalLightColor[ i ] * directionalLightWeightingBack;\n\n	#endif\n\n}\n\n#endif\n\n#if MAX_POINT_LIGHTS > 0\n\n	for( int i = 0; i < MAX_POINT_LIGHTS; i ++ ) {\n\n		vec4 lPosition = viewMatrix * vec4( pointLightPosition[ i ], 1.0 );\n		vec3 lVector = lPosition.xyz - mvPosition.xyz;\n\n		float attenuation = calcLightAttenuation( length( lVector ), pointLightDistance[ i ], pointLightDecay[ i ] );\n\n		lVector = normalize( lVector );\n		float dotProduct = dot( transformedNormal, lVector );\n\n		vec3 pointLightWeighting = vec3( max( dotProduct, 0.0 ) );\n\n		#ifdef DOUBLE_SIDED\n\n			vec3 pointLightWeightingBack = vec3( max( -dotProduct, 0.0 ) );\n\n			#ifdef WRAP_AROUND\n\n				vec3 pointLightWeightingHalfBack = vec3( max( -0.5 * dotProduct + 0.5, 0.0 ) );\n\n			#endif\n\n		#endif\n\n		#ifdef WRAP_AROUND\n\n			vec3 pointLightWeightingHalf = vec3( max( 0.5 * dotProduct + 0.5, 0.0 ) );\n			pointLightWeighting = mix( pointLightWeighting, pointLightWeightingHalf, wrapRGB );\n\n			#ifdef DOUBLE_SIDED\n\n				pointLightWeightingBack = mix( pointLightWeightingBack, pointLightWeightingHalfBack, wrapRGB );\n\n			#endif\n\n		#endif\n\n		vLightFront += pointLightColor[ i ] * pointLightWeighting * attenuation;\n\n		#ifdef DOUBLE_SIDED\n\n			vLightBack += pointLightColor[ i ] * pointLightWeightingBack * attenuation;\n\n		#endif\n\n	}\n\n#endif\n\n#if MAX_SPOT_LIGHTS > 0\n\n	for( int i = 0; i < MAX_SPOT_LIGHTS; i ++ ) {\n\n		vec4 lPosition = viewMatrix * vec4( spotLightPosition[ i ], 1.0 );\n		vec3 lVector = lPosition.xyz - mvPosition.xyz;\n\n		float spotEffect = dot( spotLightDirection[ i ], normalize( spotLightPosition[ i ] - worldPosition.xyz ) );\n\n		if ( spotEffect > spotLightAngleCos[ i ] ) {\n\n			spotEffect = max( pow( max( spotEffect, 0.0 ), spotLightExponent[ i ] ), 0.0 );\n\n			float attenuation = calcLightAttenuation( length( lVector ), spotLightDistance[ i ], spotLightDecay[ i ] );\n\n			lVector = normalize( lVector );\n\n			float dotProduct = dot( transformedNormal, lVector );\n			vec3 spotLightWeighting = vec3( max( dotProduct, 0.0 ) );\n\n			#ifdef DOUBLE_SIDED\n\n				vec3 spotLightWeightingBack = vec3( max( -dotProduct, 0.0 ) );\n\n				#ifdef WRAP_AROUND\n\n					vec3 spotLightWeightingHalfBack = vec3( max( -0.5 * dotProduct + 0.5, 0.0 ) );\n\n				#endif\n\n			#endif\n\n			#ifdef WRAP_AROUND\n\n				vec3 spotLightWeightingHalf = vec3( max( 0.5 * dotProduct + 0.5, 0.0 ) );\n				spotLightWeighting = mix( spotLightWeighting, spotLightWeightingHalf, wrapRGB );\n\n				#ifdef DOUBLE_SIDED\n\n					spotLightWeightingBack = mix( spotLightWeightingBack, spotLightWeightingHalfBack, wrapRGB );\n\n				#endif\n\n			#endif\n\n			vLightFront += spotLightColor[ i ] * spotLightWeighting * attenuation * spotEffect;\n\n			#ifdef DOUBLE_SIDED\n\n				vLightBack += spotLightColor[ i ] * spotLightWeightingBack * attenuation * spotEffect;\n\n			#endif\n\n		}\n\n	}\n\n#endif\n\n#if MAX_HEMI_LIGHTS > 0\n\n	for( int i = 0; i < MAX_HEMI_LIGHTS; i ++ ) {\n\n		vec3 lVector = transformDirection( hemisphereLightDirection[ i ], viewMatrix );\n\n		float dotProduct = dot( transformedNormal, lVector );\n\n		float hemiDiffuseWeight = 0.5 * dotProduct + 0.5;\n		float hemiDiffuseWeightBack = -0.5 * dotProduct + 0.5;\n\n		vLightFront += mix( hemisphereLightGroundColor[ i ], hemisphereLightSkyColor[ i ], hemiDiffuseWeight );\n\n		#ifdef DOUBLE_SIDED\n\n			vLightBack += mix( hemisphereLightGroundColor[ i ], hemisphereLightSkyColor[ i ], hemiDiffuseWeightBack );\n\n		#endif\n\n	}\n\n#endif\n\nvLightFront += ambientLightColor;\n\n#ifdef DOUBLE_SIDED\n\n	vLightBack += ambientLightColor;\n\n#endif\n";
    THREE.ShaderChunk['map_particle_pars_fragment'] = "#ifdef USE_MAP\n\n	uniform vec4 offsetRepeat;\n	uniform sampler2D map;\n\n#endif\n";
    THREE.ShaderChunk['default_vertex'] = "#ifdef USE_SKINNING\n\n	vec4 mvPosition = modelViewMatrix * skinned;\n\n#elif defined( USE_MORPHTARGETS )\n\n	vec4 mvPosition = modelViewMatrix * vec4( morphed, 1.0 );\n\n#else\n\n	vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );\n\n#endif\n\ngl_Position = projectionMatrix * mvPosition;\n";
    THREE.ShaderChunk['map_pars_fragment'] = "#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP )\n\n	varying vec2 vUv;\n\n#endif\n\n#ifdef USE_MAP\n\n	uniform sampler2D map;\n\n#endif";
    THREE.ShaderChunk['skinnormal_vertex'] = "#ifdef USE_SKINNING\n\n	mat4 skinMatrix = mat4( 0.0 );\n	skinMatrix += skinWeight.x * boneMatX;\n	skinMatrix += skinWeight.y * boneMatY;\n	skinMatrix += skinWeight.z * boneMatZ;\n	skinMatrix += skinWeight.w * boneMatW;\n	skinMatrix  = bindMatrixInverse * skinMatrix * bindMatrix;\n\n	#ifdef USE_MORPHNORMALS\n\n	vec4 skinnedNormal = skinMatrix * vec4( morphedNormal, 0.0 );\n\n	#else\n\n	vec4 skinnedNormal = skinMatrix * vec4( normal, 0.0 );\n\n	#endif\n\n#endif\n";
    THREE.ShaderChunk['logdepthbuf_pars_vertex'] = "#ifdef USE_LOGDEPTHBUF\n\n	#ifdef USE_LOGDEPTHBUF_EXT\n\n		varying float vFragDepth;\n\n	#endif\n\n	uniform float logDepthBufFC;\n\n#endif";
    THREE.ShaderChunk['lightmap_pars_vertex'] = "#ifdef USE_LIGHTMAP\n\n	varying vec2 vUv2;\n\n#endif";
    THREE.ShaderChunk['lights_phong_fragment'] = "#ifndef FLAT_SHADED\n\n	vec3 normal = normalize( vNormal );\n\n	#ifdef DOUBLE_SIDED\n\n		normal = normal * ( -1.0 + 2.0 * float( gl_FrontFacing ) );\n\n	#endif\n\n#else\n\n	vec3 fdx = dFdx( vViewPosition );\n	vec3 fdy = dFdy( vViewPosition );\n	vec3 normal = normalize( cross( fdx, fdy ) );\n\n#endif\n\nvec3 viewPosition = normalize( vViewPosition );\n\n#ifdef USE_NORMALMAP\n\n	normal = perturbNormal2Arb( -vViewPosition, normal );\n\n#elif defined( USE_BUMPMAP )\n\n	normal = perturbNormalArb( -vViewPosition, normal, dHdxy_fwd() );\n\n#endif\n\nvec3 totalDiffuseLight = vec3( 0.0 );\nvec3 totalSpecularLight = vec3( 0.0 );\n\n#if MAX_POINT_LIGHTS > 0\n\n	for ( int i = 0; i < MAX_POINT_LIGHTS; i ++ ) {\n\n		vec4 lPosition = viewMatrix * vec4( pointLightPosition[ i ], 1.0 );\n		vec3 lVector = lPosition.xyz + vViewPosition.xyz;\n\n		float attenuation = calcLightAttenuation( length( lVector ), pointLightDistance[ i ], pointLightDecay[ i ] );\n\n		lVector = normalize( lVector );\n\n		// diffuse\n\n		float dotProduct = dot( normal, lVector );\n\n		#ifdef WRAP_AROUND\n\n			float pointDiffuseWeightFull = max( dotProduct, 0.0 );\n			float pointDiffuseWeightHalf = max( 0.5 * dotProduct + 0.5, 0.0 );\n\n			vec3 pointDiffuseWeight = mix( vec3( pointDiffuseWeightFull ), vec3( pointDiffuseWeightHalf ), wrapRGB );\n\n		#else\n\n			float pointDiffuseWeight = max( dotProduct, 0.0 );\n\n		#endif\n\n		totalDiffuseLight += pointLightColor[ i ] * pointDiffuseWeight * attenuation;\n\n				// specular\n\n		vec3 pointHalfVector = normalize( lVector + viewPosition );\n		float pointDotNormalHalf = max( dot( normal, pointHalfVector ), 0.0 );\n		float pointSpecularWeight = specularStrength * max( pow( pointDotNormalHalf, shininess ), 0.0 );\n\n		float specularNormalization = ( shininess + 2.0 ) / 8.0;\n\n		vec3 schlick = specular + vec3( 1.0 - specular ) * pow( max( 1.0 - dot( lVector, pointHalfVector ), 0.0 ), 5.0 );\n		totalSpecularLight += schlick * pointLightColor[ i ] * pointSpecularWeight * pointDiffuseWeight * attenuation * specularNormalization;\n\n	}\n\n#endif\n\n#if MAX_SPOT_LIGHTS > 0\n\n	for ( int i = 0; i < MAX_SPOT_LIGHTS; i ++ ) {\n\n		vec4 lPosition = viewMatrix * vec4( spotLightPosition[ i ], 1.0 );\n		vec3 lVector = lPosition.xyz + vViewPosition.xyz;\n\n		float attenuation = calcLightAttenuation( length( lVector ), spotLightDistance[ i ], spotLightDecay[ i ] );\n\n		lVector = normalize( lVector );\n\n		float spotEffect = dot( spotLightDirection[ i ], normalize( spotLightPosition[ i ] - vWorldPosition ) );\n\n		if ( spotEffect > spotLightAngleCos[ i ] ) {\n\n			spotEffect = max( pow( max( spotEffect, 0.0 ), spotLightExponent[ i ] ), 0.0 );\n\n			// diffuse\n\n			float dotProduct = dot( normal, lVector );\n\n			#ifdef WRAP_AROUND\n\n				float spotDiffuseWeightFull = max( dotProduct, 0.0 );\n				float spotDiffuseWeightHalf = max( 0.5 * dotProduct + 0.5, 0.0 );\n\n				vec3 spotDiffuseWeight = mix( vec3( spotDiffuseWeightFull ), vec3( spotDiffuseWeightHalf ), wrapRGB );\n\n			#else\n\n				float spotDiffuseWeight = max( dotProduct, 0.0 );\n\n			#endif\n\n			totalDiffuseLight += spotLightColor[ i ] * spotDiffuseWeight * attenuation * spotEffect;\n\n			// specular\n\n			vec3 spotHalfVector = normalize( lVector + viewPosition );\n			float spotDotNormalHalf = max( dot( normal, spotHalfVector ), 0.0 );\n			float spotSpecularWeight = specularStrength * max( pow( spotDotNormalHalf, shininess ), 0.0 );\n\n			float specularNormalization = ( shininess + 2.0 ) / 8.0;\n\n			vec3 schlick = specular + vec3( 1.0 - specular ) * pow( max( 1.0 - dot( lVector, spotHalfVector ), 0.0 ), 5.0 );\n			totalSpecularLight += schlick * spotLightColor[ i ] * spotSpecularWeight * spotDiffuseWeight * attenuation * specularNormalization * spotEffect;\n\n		}\n\n	}\n\n#endif\n\n#if MAX_DIR_LIGHTS > 0\n\n	for( int i = 0; i < MAX_DIR_LIGHTS; i ++ ) {\n\n		vec3 dirVector = transformDirection( directionalLightDirection[ i ], viewMatrix );\n\n		// diffuse\n\n		float dotProduct = dot( normal, dirVector );\n\n		#ifdef WRAP_AROUND\n\n			float dirDiffuseWeightFull = max( dotProduct, 0.0 );\n			float dirDiffuseWeightHalf = max( 0.5 * dotProduct + 0.5, 0.0 );\n\n			vec3 dirDiffuseWeight = mix( vec3( dirDiffuseWeightFull ), vec3( dirDiffuseWeightHalf ), wrapRGB );\n\n		#else\n\n			float dirDiffuseWeight = max( dotProduct, 0.0 );\n\n		#endif\n\n		totalDiffuseLight += directionalLightColor[ i ] * dirDiffuseWeight;\n\n		// specular\n\n		vec3 dirHalfVector = normalize( dirVector + viewPosition );\n		float dirDotNormalHalf = max( dot( normal, dirHalfVector ), 0.0 );\n		float dirSpecularWeight = specularStrength * max( pow( dirDotNormalHalf, shininess ), 0.0 );\n\n		/*\n		// fresnel term from skin shader\n		const float F0 = 0.128;\n\n		float base = 1.0 - dot( viewPosition, dirHalfVector );\n		float exponential = pow( base, 5.0 );\n\n		float fresnel = exponential + F0 * ( 1.0 - exponential );\n		*/\n\n		/*\n		// fresnel term from fresnel shader\n		const float mFresnelBias = 0.08;\n		const float mFresnelScale = 0.3;\n		const float mFresnelPower = 5.0;\n\n		float fresnel = mFresnelBias + mFresnelScale * pow( 1.0 + dot( normalize( -viewPosition ), normal ), mFresnelPower );\n		*/\n\n		float specularNormalization = ( shininess + 2.0 ) / 8.0;\n\n		// 		dirSpecular += specular * directionalLightColor[ i ] * dirSpecularWeight * dirDiffuseWeight * specularNormalization * fresnel;\n\n		vec3 schlick = specular + vec3( 1.0 - specular ) * pow( max( 1.0 - dot( dirVector, dirHalfVector ), 0.0 ), 5.0 );\n		totalSpecularLight += schlick * directionalLightColor[ i ] * dirSpecularWeight * dirDiffuseWeight * specularNormalization;\n\n\n	}\n\n#endif\n\n#if MAX_HEMI_LIGHTS > 0\n\n	for( int i = 0; i < MAX_HEMI_LIGHTS; i ++ ) {\n\n		vec3 lVector = transformDirection( hemisphereLightDirection[ i ], viewMatrix );\n\n		// diffuse\n\n		float dotProduct = dot( normal, lVector );\n		float hemiDiffuseWeight = 0.5 * dotProduct + 0.5;\n\n		vec3 hemiColor = mix( hemisphereLightGroundColor[ i ], hemisphereLightSkyColor[ i ], hemiDiffuseWeight );\n\n		totalDiffuseLight += hemiColor;\n\n		// specular (sky light)\n\n		vec3 hemiHalfVectorSky = normalize( lVector + viewPosition );\n		float hemiDotNormalHalfSky = 0.5 * dot( normal, hemiHalfVectorSky ) + 0.5;\n		float hemiSpecularWeightSky = specularStrength * max( pow( max( hemiDotNormalHalfSky, 0.0 ), shininess ), 0.0 );\n\n		// specular (ground light)\n\n		vec3 lVectorGround = -lVector;\n\n		vec3 hemiHalfVectorGround = normalize( lVectorGround + viewPosition );\n		float hemiDotNormalHalfGround = 0.5 * dot( normal, hemiHalfVectorGround ) + 0.5;\n		float hemiSpecularWeightGround = specularStrength * max( pow( max( hemiDotNormalHalfGround, 0.0 ), shininess ), 0.0 );\n\n		float dotProductGround = dot( normal, lVectorGround );\n\n		float specularNormalization = ( shininess + 2.0 ) / 8.0;\n\n		vec3 schlickSky = specular + vec3( 1.0 - specular ) * pow( max( 1.0 - dot( lVector, hemiHalfVectorSky ), 0.0 ), 5.0 );\n		vec3 schlickGround = specular + vec3( 1.0 - specular ) * pow( max( 1.0 - dot( lVectorGround, hemiHalfVectorGround ), 0.0 ), 5.0 );\n		totalSpecularLight += hemiColor * specularNormalization * ( schlickSky * hemiSpecularWeightSky * max( dotProduct, 0.0 ) + schlickGround * hemiSpecularWeightGround * max( dotProductGround, 0.0 ) );\n\n	}\n\n#endif\n\n#ifdef METAL\n\n	outgoingLight += diffuseColor.rgb * ( totalDiffuseLight + ambientLightColor ) * specular + totalSpecularLight + emissive;\n\n#else\n\n	outgoingLight += diffuseColor.rgb * ( totalDiffuseLight + ambientLightColor ) + totalSpecularLight + emissive;\n\n#endif\n";
    THREE.ShaderChunk['fog_pars_fragment'] = "#ifdef USE_FOG\n\n	uniform vec3 fogColor;\n\n	#ifdef FOG_EXP2\n\n		uniform float fogDensity;\n\n	#else\n\n		uniform float fogNear;\n		uniform float fogFar;\n	#endif\n\n#endif";
    THREE.ShaderChunk['morphnormal_vertex'] = "#ifdef USE_MORPHNORMALS\n\n	vec3 morphedNormal = vec3( 0.0 );\n\n	morphedNormal += ( morphNormal0 - normal ) * morphTargetInfluences[ 0 ];\n	morphedNormal += ( morphNormal1 - normal ) * morphTargetInfluences[ 1 ];\n	morphedNormal += ( morphNormal2 - normal ) * morphTargetInfluences[ 2 ];\n	morphedNormal += ( morphNormal3 - normal ) * morphTargetInfluences[ 3 ];\n\n	morphedNormal += normal;\n\n#endif";
    THREE.ShaderChunk['envmap_pars_fragment'] = "#ifdef USE_ENVMAP\n\n	uniform float reflectivity;\n	#ifdef ENVMAP_TYPE_CUBE\n		uniform samplerCube envMap;\n	#else\n		uniform sampler2D envMap;\n	#endif\n	uniform float flipEnvMap;\n\n	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\n\n		uniform float refractionRatio;\n\n	#else\n\n		varying vec3 vReflect;\n\n	#endif\n\n#endif\n";
    THREE.ShaderChunk['logdepthbuf_fragment'] = "#if defined(USE_LOGDEPTHBUF) && defined(USE_LOGDEPTHBUF_EXT)\n\n	gl_FragDepthEXT = log2(vFragDepth) * logDepthBufFC * 0.5;\n\n#endif";
    THREE.ShaderChunk['normalmap_pars_fragment'] = "#ifdef USE_NORMALMAP\n\n	uniform sampler2D normalMap;\n	uniform vec2 normalScale;\n\n	// Per-Pixel Tangent Space Normal Mapping\n	// http://hacksoflife.blogspot.ch/2009/11/per-pixel-tangent-space-normal-mapping.html\n\n	vec3 perturbNormal2Arb( vec3 eye_pos, vec3 surf_norm ) {\n\n		vec3 q0 = dFdx( eye_pos.xyz );\n		vec3 q1 = dFdy( eye_pos.xyz );\n		vec2 st0 = dFdx( vUv.st );\n		vec2 st1 = dFdy( vUv.st );\n\n		vec3 S = normalize( q0 * st1.t - q1 * st0.t );\n		vec3 T = normalize( -q0 * st1.s + q1 * st0.s );\n		vec3 N = normalize( surf_norm );\n\n		vec3 mapN = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n		mapN.xy = normalScale * mapN.xy;\n		mat3 tsn = mat3( S, T, N );\n		return normalize( tsn * mapN );\n\n	}\n\n#endif\n";
    THREE.ShaderChunk['lights_phong_pars_vertex'] = "#if MAX_SPOT_LIGHTS > 0 || defined( USE_BUMPMAP ) || defined( USE_ENVMAP )\n\n	varying vec3 vWorldPosition;\n\n#endif\n";
    THREE.ShaderChunk['lightmap_pars_fragment'] = "#ifdef USE_LIGHTMAP\n\n	varying vec2 vUv2;\n	uniform sampler2D lightMap;\n\n#endif";
    THREE.ShaderChunk['shadowmap_vertex'] = "#ifdef USE_SHADOWMAP\n\n	for( int i = 0; i < MAX_SHADOWS; i ++ ) {\n\n		vShadowCoord[ i ] = shadowMatrix[ i ] * worldPosition;\n\n	}\n\n#endif";
    THREE.ShaderChunk['lights_phong_vertex'] = "#if MAX_SPOT_LIGHTS > 0 || defined( USE_BUMPMAP ) || defined( USE_ENVMAP )\n\n	vWorldPosition = worldPosition.xyz;\n\n#endif";
    THREE.ShaderChunk['map_fragment'] = "#ifdef USE_MAP\n\n	vec4 texelColor = texture2D( map, vUv );\n\n	texelColor.xyz = inputToLinear( texelColor.xyz );\n\n	diffuseColor *= texelColor;\n\n#endif";
    THREE.ShaderChunk['lightmap_vertex'] = "#ifdef USE_LIGHTMAP\n\n	vUv2 = uv2;\n\n#endif";
    THREE.ShaderChunk['map_particle_fragment'] = "#ifdef USE_MAP\n\n	diffuseColor *= texture2D( map, vec2( gl_PointCoord.x, 1.0 - gl_PointCoord.y ) * offsetRepeat.zw + offsetRepeat.xy );\n\n#endif\n";
    THREE.ShaderChunk['color_pars_fragment'] = "#ifdef USE_COLOR\n\n	varying vec3 vColor;\n\n#endif\n";
    THREE.ShaderChunk['color_vertex'] = "#ifdef USE_COLOR\n\n	vColor.xyz = inputToLinear( color.xyz );\n\n#endif";
    THREE.ShaderChunk['skinning_vertex'] = "#ifdef USE_SKINNING\n\n	#ifdef USE_MORPHTARGETS\n\n	vec4 skinVertex = bindMatrix * vec4( morphed, 1.0 );\n\n	#else\n\n	vec4 skinVertex = bindMatrix * vec4( position, 1.0 );\n\n	#endif\n\n	vec4 skinned = vec4( 0.0 );\n	skinned += boneMatX * skinVertex * skinWeight.x;\n	skinned += boneMatY * skinVertex * skinWeight.y;\n	skinned += boneMatZ * skinVertex * skinWeight.z;\n	skinned += boneMatW * skinVertex * skinWeight.w;\n	skinned  = bindMatrixInverse * skinned;\n\n#endif\n";
    THREE.ShaderChunk['envmap_pars_vertex'] = "#if defined( USE_ENVMAP ) && ! defined( USE_BUMPMAP ) && ! defined( USE_NORMALMAP ) && ! defined( PHONG )\n\n	varying vec3 vReflect;\n\n	uniform float refractionRatio;\n\n#endif\n";
    THREE.ShaderChunk['linear_to_gamma_fragment'] = "\n	outgoingLight = linearToOutput( outgoingLight );\n";
    THREE.ShaderChunk['color_pars_vertex'] = "#ifdef USE_COLOR\n\n	varying vec3 vColor;\n\n#endif";
    THREE.ShaderChunk['lights_lambert_pars_vertex'] = "uniform vec3 ambientLightColor;\n\n#if MAX_DIR_LIGHTS > 0\n\n	uniform vec3 directionalLightColor[ MAX_DIR_LIGHTS ];\n	uniform vec3 directionalLightDirection[ MAX_DIR_LIGHTS ];\n\n#endif\n\n#if MAX_HEMI_LIGHTS > 0\n\n	uniform vec3 hemisphereLightSkyColor[ MAX_HEMI_LIGHTS ];\n	uniform vec3 hemisphereLightGroundColor[ MAX_HEMI_LIGHTS ];\n	uniform vec3 hemisphereLightDirection[ MAX_HEMI_LIGHTS ];\n\n#endif\n\n#if MAX_POINT_LIGHTS > 0\n\n	uniform vec3 pointLightColor[ MAX_POINT_LIGHTS ];\n	uniform vec3 pointLightPosition[ MAX_POINT_LIGHTS ];\n	uniform float pointLightDistance[ MAX_POINT_LIGHTS ];\n	uniform float pointLightDecay[ MAX_POINT_LIGHTS ];\n\n#endif\n\n#if MAX_SPOT_LIGHTS > 0\n\n	uniform vec3 spotLightColor[ MAX_SPOT_LIGHTS ];\n	uniform vec3 spotLightPosition[ MAX_SPOT_LIGHTS ];\n	uniform vec3 spotLightDirection[ MAX_SPOT_LIGHTS ];\n	uniform float spotLightDistance[ MAX_SPOT_LIGHTS ];\n	uniform float spotLightAngleCos[ MAX_SPOT_LIGHTS ];\n	uniform float spotLightExponent[ MAX_SPOT_LIGHTS ];\n	uniform float spotLightDecay[ MAX_SPOT_LIGHTS ];\n\n#endif\n\n#ifdef WRAP_AROUND\n\n	uniform vec3 wrapRGB;\n\n#endif\n";
    THREE.ShaderChunk['map_pars_vertex'] = "#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP )\n\n	varying vec2 vUv;\n	uniform vec4 offsetRepeat;\n\n#endif\n";
    THREE.ShaderChunk['envmap_fragment'] = "#ifdef USE_ENVMAP\n\n	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\n\n		vec3 cameraToVertex = normalize( vWorldPosition - cameraPosition );\n\n		// Transforming Normal Vectors with the Inverse Transformation\n		vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n\n		#ifdef ENVMAP_MODE_REFLECTION\n\n			vec3 reflectVec = reflect( cameraToVertex, worldNormal );\n\n		#else\n\n			vec3 reflectVec = refract( cameraToVertex, worldNormal, refractionRatio );\n\n		#endif\n\n	#else\n\n		vec3 reflectVec = vReflect;\n\n	#endif\n\n	#ifdef DOUBLE_SIDED\n		float flipNormal = ( -1.0 + 2.0 * float( gl_FrontFacing ) );\n	#else\n		float flipNormal = 1.0;\n	#endif\n\n	#ifdef ENVMAP_TYPE_CUBE\n		vec4 envColor = textureCube( envMap, flipNormal * vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );\n\n	#elif defined( ENVMAP_TYPE_EQUIREC )\n		vec2 sampleUV;\n		sampleUV.y = saturate( flipNormal * reflectVec.y * 0.5 + 0.5 );\n		sampleUV.x = atan( flipNormal * reflectVec.z, flipNormal * reflectVec.x ) * RECIPROCAL_PI2 + 0.5;\n		vec4 envColor = texture2D( envMap, sampleUV );\n\n	#elif defined( ENVMAP_TYPE_SPHERE )\n		vec3 reflectView = flipNormal * normalize((viewMatrix * vec4( reflectVec, 0.0 )).xyz + vec3(0.0,0.0,1.0));\n		vec4 envColor = texture2D( envMap, reflectView.xy * 0.5 + 0.5 );\n	#endif\n\n	envColor.xyz = inputToLinear( envColor.xyz );\n\n	#ifdef ENVMAP_BLENDING_MULTIPLY\n\n		outgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );\n\n	#elif defined( ENVMAP_BLENDING_MIX )\n\n		outgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );\n\n	#elif defined( ENVMAP_BLENDING_ADD )\n\n		outgoingLight += envColor.xyz * specularStrength * reflectivity;\n\n	#endif\n\n#endif\n";
    THREE.ShaderChunk['specularmap_pars_fragment'] = "#ifdef USE_SPECULARMAP\n\n	uniform sampler2D specularMap;\n\n#endif";
    THREE.ShaderChunk['logdepthbuf_vertex'] = "#ifdef USE_LOGDEPTHBUF\n\n	gl_Position.z = log2(max( EPSILON, gl_Position.w + 1.0 )) * logDepthBufFC;\n\n	#ifdef USE_LOGDEPTHBUF_EXT\n\n		vFragDepth = 1.0 + gl_Position.w;\n\n#else\n\n		gl_Position.z = (gl_Position.z - 1.0) * gl_Position.w;\n\n	#endif\n\n#endif";
    THREE.ShaderChunk['morphtarget_pars_vertex'] = "#ifdef USE_MORPHTARGETS\n\n	#ifndef USE_MORPHNORMALS\n\n	uniform float morphTargetInfluences[ 8 ];\n\n	#else\n\n	uniform float morphTargetInfluences[ 4 ];\n\n	#endif\n\n#endif";
    THREE.ShaderChunk['specularmap_fragment'] = "float specularStrength;\n\n#ifdef USE_SPECULARMAP\n\n	vec4 texelSpecular = texture2D( specularMap, vUv );\n	specularStrength = texelSpecular.r;\n\n#else\n\n	specularStrength = 1.0;\n\n#endif";
    THREE.ShaderChunk['fog_fragment'] = "#ifdef USE_FOG\n\n	#ifdef USE_LOGDEPTHBUF_EXT\n\n		float depth = gl_FragDepthEXT / gl_FragCoord.w;\n\n	#else\n\n		float depth = gl_FragCoord.z / gl_FragCoord.w;\n\n	#endif\n\n	#ifdef FOG_EXP2\n\n		float fogFactor = exp2( - square( fogDensity ) * square( depth ) * LOG2 );\n		fogFactor = whiteCompliment( fogFactor );\n\n	#else\n\n		float fogFactor = smoothstep( fogNear, fogFar, depth );\n\n	#endif\n	\n	outgoingLight = mix( outgoingLight, fogColor, fogFactor );\n\n#endif";
    THREE.ShaderChunk['bumpmap_pars_fragment'] = "#ifdef USE_BUMPMAP\n\n	uniform sampler2D bumpMap;\n	uniform float bumpScale;\n\n	// Derivative maps - bump mapping unparametrized surfaces by Morten Mikkelsen\n	// http://mmikkelsen3d.blogspot.sk/2011/07/derivative-maps.html\n\n	// Evaluate the derivative of the height w.r.t. screen-space using forward differencing (listing 2)\n\n	vec2 dHdxy_fwd() {\n\n		vec2 dSTdx = dFdx( vUv );\n		vec2 dSTdy = dFdy( vUv );\n\n		float Hll = bumpScale * texture2D( bumpMap, vUv ).x;\n		float dBx = bumpScale * texture2D( bumpMap, vUv + dSTdx ).x - Hll;\n		float dBy = bumpScale * texture2D( bumpMap, vUv + dSTdy ).x - Hll;\n\n		return vec2( dBx, dBy );\n\n	}\n\n	vec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy ) {\n\n		vec3 vSigmaX = dFdx( surf_pos );\n		vec3 vSigmaY = dFdy( surf_pos );\n		vec3 vN = surf_norm;		// normalized\n\n		vec3 R1 = cross( vSigmaY, vN );\n		vec3 R2 = cross( vN, vSigmaX );\n\n		float fDet = dot( vSigmaX, R1 );\n\n		vec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );\n		return normalize( abs( fDet ) * surf_norm - vGrad );\n\n	}\n\n#endif\n";
    THREE.ShaderChunk['defaultnormal_vertex'] = "#ifdef USE_SKINNING\n\n	vec3 objectNormal = skinnedNormal.xyz;\n\n#elif defined( USE_MORPHNORMALS )\n\n	vec3 objectNormal = morphedNormal;\n\n#else\n\n	vec3 objectNormal = normal;\n\n#endif\n\n#ifdef FLIP_SIDED\n\n	objectNormal = -objectNormal;\n\n#endif\n\nvec3 transformedNormal = normalMatrix * objectNormal;\n";
    THREE.ShaderChunk['lights_phong_pars_fragment'] = "uniform vec3 ambientLightColor;\n\n#if MAX_DIR_LIGHTS > 0\n\n	uniform vec3 directionalLightColor[ MAX_DIR_LIGHTS ];\n	uniform vec3 directionalLightDirection[ MAX_DIR_LIGHTS ];\n\n#endif\n\n#if MAX_HEMI_LIGHTS > 0\n\n	uniform vec3 hemisphereLightSkyColor[ MAX_HEMI_LIGHTS ];\n	uniform vec3 hemisphereLightGroundColor[ MAX_HEMI_LIGHTS ];\n	uniform vec3 hemisphereLightDirection[ MAX_HEMI_LIGHTS ];\n\n#endif\n\n#if MAX_POINT_LIGHTS > 0\n\n	uniform vec3 pointLightColor[ MAX_POINT_LIGHTS ];\n\n	uniform vec3 pointLightPosition[ MAX_POINT_LIGHTS ];\n	uniform float pointLightDistance[ MAX_POINT_LIGHTS ];\n	uniform float pointLightDecay[ MAX_POINT_LIGHTS ];\n\n#endif\n\n#if MAX_SPOT_LIGHTS > 0\n\n	uniform vec3 spotLightColor[ MAX_SPOT_LIGHTS ];\n	uniform vec3 spotLightPosition[ MAX_SPOT_LIGHTS ];\n	uniform vec3 spotLightDirection[ MAX_SPOT_LIGHTS ];\n	uniform float spotLightAngleCos[ MAX_SPOT_LIGHTS ];\n	uniform float spotLightExponent[ MAX_SPOT_LIGHTS ];\n	uniform float spotLightDistance[ MAX_SPOT_LIGHTS ];\n	uniform float spotLightDecay[ MAX_SPOT_LIGHTS ];\n\n#endif\n\n#if MAX_SPOT_LIGHTS > 0 || defined( USE_BUMPMAP ) || defined( USE_ENVMAP )\n\n	varying vec3 vWorldPosition;\n\n#endif\n\n#ifdef WRAP_AROUND\n\n	uniform vec3 wrapRGB;\n\n#endif\n\nvarying vec3 vViewPosition;\n\n#ifndef FLAT_SHADED\n\n	varying vec3 vNormal;\n\n#endif\n";
    THREE.ShaderChunk['skinbase_vertex'] = "#ifdef USE_SKINNING\n\n	mat4 boneMatX = getBoneMatrix( skinIndex.x );\n	mat4 boneMatY = getBoneMatrix( skinIndex.y );\n	mat4 boneMatZ = getBoneMatrix( skinIndex.z );\n	mat4 boneMatW = getBoneMatrix( skinIndex.w );\n\n#endif";
    THREE.ShaderChunk['map_vertex'] = "#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP )\n\n	vUv = uv * offsetRepeat.zw + offsetRepeat.xy;\n\n#endif";
    THREE.ShaderChunk['lightmap_fragment'] = "#ifdef USE_LIGHTMAP\n\n	outgoingLight *= diffuseColor.xyz * texture2D( lightMap, vUv2 ).xyz;\n\n#endif";
    THREE.ShaderChunk['shadowmap_pars_vertex'] = "#ifdef USE_SHADOWMAP\n\n	varying vec4 vShadowCoord[ MAX_SHADOWS ];\n	uniform mat4 shadowMatrix[ MAX_SHADOWS ];\n\n#endif";
    THREE.ShaderChunk['color_fragment'] = "#ifdef USE_COLOR\n\n	diffuseColor.rgb *= vColor;\n\n#endif";
    THREE.ShaderChunk['morphtarget_vertex'] = "#ifdef USE_MORPHTARGETS\n\n	vec3 morphed = vec3( 0.0 );\n	morphed += ( morphTarget0 - position ) * morphTargetInfluences[ 0 ];\n	morphed += ( morphTarget1 - position ) * morphTargetInfluences[ 1 ];\n	morphed += ( morphTarget2 - position ) * morphTargetInfluences[ 2 ];\n	morphed += ( morphTarget3 - position ) * morphTargetInfluences[ 3 ];\n\n	#ifndef USE_MORPHNORMALS\n\n	morphed += ( morphTarget4 - position ) * morphTargetInfluences[ 4 ];\n	morphed += ( morphTarget5 - position ) * morphTargetInfluences[ 5 ];\n	morphed += ( morphTarget6 - position ) * morphTargetInfluences[ 6 ];\n	morphed += ( morphTarget7 - position ) * morphTargetInfluences[ 7 ];\n\n	#endif\n\n	morphed += position;\n\n#endif";
    THREE.ShaderChunk['envmap_vertex'] = "#if defined( USE_ENVMAP ) && ! defined( USE_BUMPMAP ) && ! defined( USE_NORMALMAP ) && ! defined( PHONG )\n\n	vec3 worldNormal = transformDirection( objectNormal, modelMatrix );\n\n	vec3 cameraToVertex = normalize( worldPosition.xyz - cameraPosition );\n\n	#ifdef ENVMAP_MODE_REFLECTION\n\n		vReflect = reflect( cameraToVertex, worldNormal );\n\n	#else\n\n		vReflect = refract( cameraToVertex, worldNormal, refractionRatio );\n\n	#endif\n\n#endif\n";
    THREE.ShaderChunk['shadowmap_fragment'] = "#ifdef USE_SHADOWMAP\n\n	#ifdef SHADOWMAP_DEBUG\n\n		vec3 frustumColors[3];\n		frustumColors[0] = vec3( 1.0, 0.5, 0.0 );\n		frustumColors[1] = vec3( 0.0, 1.0, 0.8 );\n		frustumColors[2] = vec3( 0.0, 0.5, 1.0 );\n\n	#endif\n\n	#ifdef SHADOWMAP_CASCADE\n\n		int inFrustumCount = 0;\n\n	#endif\n\n	float fDepth;\n	vec3 shadowColor = vec3( 1.0 );\n\n	for( int i = 0; i < MAX_SHADOWS; i ++ ) {\n\n		vec3 shadowCoord = vShadowCoord[ i ].xyz / vShadowCoord[ i ].w;\n\n				// if ( something && something ) breaks ATI OpenGL shader compiler\n				// if ( all( something, something ) ) using this instead\n\n		bvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\n		bool inFrustum = all( inFrustumVec );\n\n				// don't shadow pixels outside of light frustum\n				// use just first frustum (for cascades)\n				// don't shadow pixels behind far plane of light frustum\n\n		#ifdef SHADOWMAP_CASCADE\n\n			inFrustumCount += int( inFrustum );\n			bvec3 frustumTestVec = bvec3( inFrustum, inFrustumCount == 1, shadowCoord.z <= 1.0 );\n\n		#else\n\n			bvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );\n\n		#endif\n\n		bool frustumTest = all( frustumTestVec );\n\n		if ( frustumTest ) {\n\n			shadowCoord.z += shadowBias[ i ];\n\n			#if defined( SHADOWMAP_TYPE_PCF )\n\n						// Percentage-close filtering\n						// (9 pixel kernel)\n						// http://fabiensanglard.net/shadowmappingPCF/\n\n				float shadow = 0.0;\n\n		/*\n						// nested loops breaks shader compiler / validator on some ATI cards when using OpenGL\n						// must enroll loop manually\n\n				for ( float y = -1.25; y <= 1.25; y += 1.25 )\n					for ( float x = -1.25; x <= 1.25; x += 1.25 ) {\n\n						vec4 rgbaDepth = texture2D( shadowMap[ i ], vec2( x * xPixelOffset, y * yPixelOffset ) + shadowCoord.xy );\n\n								// doesn't seem to produce any noticeable visual difference compared to simple texture2D lookup\n								//vec4 rgbaDepth = texture2DProj( shadowMap[ i ], vec4( vShadowCoord[ i ].w * ( vec2( x * xPixelOffset, y * yPixelOffset ) + shadowCoord.xy ), 0.05, vShadowCoord[ i ].w ) );\n\n						float fDepth = unpackDepth( rgbaDepth );\n\n						if ( fDepth < shadowCoord.z )\n							shadow += 1.0;\n\n				}\n\n				shadow /= 9.0;\n\n		*/\n\n				const float shadowDelta = 1.0 / 9.0;\n\n				float xPixelOffset = 1.0 / shadowMapSize[ i ].x;\n				float yPixelOffset = 1.0 / shadowMapSize[ i ].y;\n\n				float dx0 = -1.25 * xPixelOffset;\n				float dy0 = -1.25 * yPixelOffset;\n				float dx1 = 1.25 * xPixelOffset;\n				float dy1 = 1.25 * yPixelOffset;\n\n				fDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx0, dy0 ) ) );\n				if ( fDepth < shadowCoord.z ) shadow += shadowDelta;\n\n				fDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( 0.0, dy0 ) ) );\n				if ( fDepth < shadowCoord.z ) shadow += shadowDelta;\n\n				fDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx1, dy0 ) ) );\n				if ( fDepth < shadowCoord.z ) shadow += shadowDelta;\n\n				fDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx0, 0.0 ) ) );\n				if ( fDepth < shadowCoord.z ) shadow += shadowDelta;\n\n				fDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy ) );\n				if ( fDepth < shadowCoord.z ) shadow += shadowDelta;\n\n				fDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx1, 0.0 ) ) );\n				if ( fDepth < shadowCoord.z ) shadow += shadowDelta;\n\n				fDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx0, dy1 ) ) );\n				if ( fDepth < shadowCoord.z ) shadow += shadowDelta;\n\n				fDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( 0.0, dy1 ) ) );\n				if ( fDepth < shadowCoord.z ) shadow += shadowDelta;\n\n				fDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx1, dy1 ) ) );\n				if ( fDepth < shadowCoord.z ) shadow += shadowDelta;\n\n				shadowColor = shadowColor * vec3( ( 1.0 - shadowDarkness[ i ] * shadow ) );\n\n			#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\n\n						// Percentage-close filtering\n						// (9 pixel kernel)\n						// http://fabiensanglard.net/shadowmappingPCF/\n\n				float shadow = 0.0;\n\n				float xPixelOffset = 1.0 / shadowMapSize[ i ].x;\n				float yPixelOffset = 1.0 / shadowMapSize[ i ].y;\n\n				float dx0 = -1.0 * xPixelOffset;\n				float dy0 = -1.0 * yPixelOffset;\n				float dx1 = 1.0 * xPixelOffset;\n				float dy1 = 1.0 * yPixelOffset;\n\n				mat3 shadowKernel;\n				mat3 depthKernel;\n\n				depthKernel[0][0] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx0, dy0 ) ) );\n				depthKernel[0][1] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx0, 0.0 ) ) );\n				depthKernel[0][2] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx0, dy1 ) ) );\n				depthKernel[1][0] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( 0.0, dy0 ) ) );\n				depthKernel[1][1] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy ) );\n				depthKernel[1][2] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( 0.0, dy1 ) ) );\n				depthKernel[2][0] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx1, dy0 ) ) );\n				depthKernel[2][1] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx1, 0.0 ) ) );\n				depthKernel[2][2] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx1, dy1 ) ) );\n\n				vec3 shadowZ = vec3( shadowCoord.z );\n				shadowKernel[0] = vec3(lessThan(depthKernel[0], shadowZ ));\n				shadowKernel[0] *= vec3(0.25);\n\n				shadowKernel[1] = vec3(lessThan(depthKernel[1], shadowZ ));\n				shadowKernel[1] *= vec3(0.25);\n\n				shadowKernel[2] = vec3(lessThan(depthKernel[2], shadowZ ));\n				shadowKernel[2] *= vec3(0.25);\n\n				vec2 fractionalCoord = 1.0 - fract( shadowCoord.xy * shadowMapSize[i].xy );\n\n				shadowKernel[0] = mix( shadowKernel[1], shadowKernel[0], fractionalCoord.x );\n				shadowKernel[1] = mix( shadowKernel[2], shadowKernel[1], fractionalCoord.x );\n\n				vec4 shadowValues;\n				shadowValues.x = mix( shadowKernel[0][1], shadowKernel[0][0], fractionalCoord.y );\n				shadowValues.y = mix( shadowKernel[0][2], shadowKernel[0][1], fractionalCoord.y );\n				shadowValues.z = mix( shadowKernel[1][1], shadowKernel[1][0], fractionalCoord.y );\n				shadowValues.w = mix( shadowKernel[1][2], shadowKernel[1][1], fractionalCoord.y );\n\n				shadow = dot( shadowValues, vec4( 1.0 ) );\n\n				shadowColor = shadowColor * vec3( ( 1.0 - shadowDarkness[ i ] * shadow ) );\n\n			#else\n\n				vec4 rgbaDepth = texture2D( shadowMap[ i ], shadowCoord.xy );\n				float fDepth = unpackDepth( rgbaDepth );\n\n				if ( fDepth < shadowCoord.z )\n\n		// spot with multiple shadows is darker\n\n					shadowColor = shadowColor * vec3( 1.0 - shadowDarkness[ i ] );\n\n		// spot with multiple shadows has the same color as single shadow spot\n\n		// 					shadowColor = min( shadowColor, vec3( shadowDarkness[ i ] ) );\n\n			#endif\n\n		}\n\n\n		#ifdef SHADOWMAP_DEBUG\n\n			#ifdef SHADOWMAP_CASCADE\n\n				if ( inFrustum && inFrustumCount == 1 ) outgoingLight *= frustumColors[ i ];\n\n			#else\n\n				if ( inFrustum ) outgoingLight *= frustumColors[ i ];\n\n			#endif\n\n		#endif\n\n	}\n\n	// NOTE: I am unsure if this is correct in linear space.  -bhouston, Dec 29, 2014\n	shadowColor = inputToLinear( shadowColor );\n\n	outgoingLight = outgoingLight * shadowColor;\n\n#endif\n";
    THREE.ShaderChunk['worldpos_vertex'] = "#if defined( USE_ENVMAP ) || defined( PHONG ) || defined( LAMBERT ) || defined ( USE_SHADOWMAP )\n\n	#ifdef USE_SKINNING\n\n		vec4 worldPosition = modelMatrix * skinned;\n\n	#elif defined( USE_MORPHTARGETS )\n\n		vec4 worldPosition = modelMatrix * vec4( morphed, 1.0 );\n\n	#else\n\n		vec4 worldPosition = modelMatrix * vec4( position, 1.0 );\n\n	#endif\n\n#endif\n";
    THREE.ShaderChunk['shadowmap_pars_fragment'] = "#ifdef USE_SHADOWMAP\n\n	uniform sampler2D shadowMap[ MAX_SHADOWS ];\n	uniform vec2 shadowMapSize[ MAX_SHADOWS ];\n\n	uniform float shadowDarkness[ MAX_SHADOWS ];\n	uniform float shadowBias[ MAX_SHADOWS ];\n\n	varying vec4 vShadowCoord[ MAX_SHADOWS ];\n\n	float unpackDepth( const in vec4 rgba_depth ) {\n\n		const vec4 bit_shift = vec4( 1.0 / ( 256.0 * 256.0 * 256.0 ), 1.0 / ( 256.0 * 256.0 ), 1.0 / 256.0, 1.0 );\n		float depth = dot( rgba_depth, bit_shift );\n		return depth;\n\n	}\n\n#endif";
    THREE.ShaderChunk['skinning_pars_vertex'] = "#ifdef USE_SKINNING\n\n	uniform mat4 bindMatrix;\n	uniform mat4 bindMatrixInverse;\n\n	#ifdef BONE_TEXTURE\n\n		uniform sampler2D boneTexture;\n		uniform int boneTextureWidth;\n		uniform int boneTextureHeight;\n\n		mat4 getBoneMatrix( const in float i ) {\n\n			float j = i * 4.0;\n			float x = mod( j, float( boneTextureWidth ) );\n			float y = floor( j / float( boneTextureWidth ) );\n\n			float dx = 1.0 / float( boneTextureWidth );\n			float dy = 1.0 / float( boneTextureHeight );\n\n			y = dy * ( y + 0.5 );\n\n			vec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );\n			vec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );\n			vec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );\n			vec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );\n\n			mat4 bone = mat4( v1, v2, v3, v4 );\n\n			return bone;\n\n		}\n\n	#else\n\n		uniform mat4 boneGlobalMatrices[ MAX_BONES ];\n\n		mat4 getBoneMatrix( const in float i ) {\n\n			mat4 bone = boneGlobalMatrices[ int(i) ];\n			return bone;\n\n		}\n\n	#endif\n\n#endif\n";
    THREE.ShaderChunk['logdepthbuf_pars_fragment'] = "#ifdef USE_LOGDEPTHBUF\n\n	uniform float logDepthBufFC;\n\n	#ifdef USE_LOGDEPTHBUF_EXT\n\n		#extension GL_EXT_frag_depth : enable\n		varying float vFragDepth;\n\n	#endif\n\n#endif";
    THREE.ShaderChunk['alphamap_fragment'] = "#ifdef USE_ALPHAMAP\n\n	diffuseColor.a *= texture2D( alphaMap, vUv ).g;\n\n#endif\n";
    THREE.ShaderChunk['alphamap_pars_fragment'] = "#ifdef USE_ALPHAMAP\n\n	uniform sampler2D alphaMap;\n\n#endif\n";
    THREE.UniformsUtils = {
      merge: function(uniforms) {
        var merged = {};
        for (var u = 0; u < uniforms.length; u++) {
          var tmp = this.clone(uniforms[u]);
          for (var p in tmp) {
            merged[p] = tmp[p];
          }
        }
        return merged;
      },
      clone: function(uniforms_src) {
        var uniforms_dst = {};
        for (var u in uniforms_src) {
          uniforms_dst[u] = {};
          for (var p in uniforms_src[u]) {
            var parameter_src = uniforms_src[u][p];
            if (parameter_src instanceof THREE.Color || parameter_src instanceof THREE.Vector2 || parameter_src instanceof THREE.Vector3 || parameter_src instanceof THREE.Vector4 || parameter_src instanceof THREE.Matrix4 || parameter_src instanceof THREE.Texture) {
              uniforms_dst[u][p] = parameter_src.clone();
            } else if (parameter_src instanceof Array) {
              uniforms_dst[u][p] = parameter_src.slice();
            } else {
              uniforms_dst[u][p] = parameter_src;
            }
          }
        }
        return uniforms_dst;
      }
    };
    THREE.UniformsLib = {
      common: {
        "diffuse": {
          type: "c",
          value: new THREE.Color(0xeeeeee)
        },
        "opacity": {
          type: "f",
          value: 1.0
        },
        "map": {
          type: "t",
          value: null
        },
        "offsetRepeat": {
          type: "v4",
          value: new THREE.Vector4(0, 0, 1, 1)
        },
        "lightMap": {
          type: "t",
          value: null
        },
        "specularMap": {
          type: "t",
          value: null
        },
        "alphaMap": {
          type: "t",
          value: null
        },
        "envMap": {
          type: "t",
          value: null
        },
        "flipEnvMap": {
          type: "f",
          value: -1
        },
        "reflectivity": {
          type: "f",
          value: 1.0
        },
        "refractionRatio": {
          type: "f",
          value: 0.98
        },
        "morphTargetInfluences": {
          type: "f",
          value: 0
        }
      },
      bump: {
        "bumpMap": {
          type: "t",
          value: null
        },
        "bumpScale": {
          type: "f",
          value: 1
        }
      },
      normalmap: {
        "normalMap": {
          type: "t",
          value: null
        },
        "normalScale": {
          type: "v2",
          value: new THREE.Vector2(1, 1)
        }
      },
      fog: {
        "fogDensity": {
          type: "f",
          value: 0.00025
        },
        "fogNear": {
          type: "f",
          value: 1
        },
        "fogFar": {
          type: "f",
          value: 2000
        },
        "fogColor": {
          type: "c",
          value: new THREE.Color(0xffffff)
        }
      },
      lights: {
        "ambientLightColor": {
          type: "fv",
          value: []
        },
        "directionalLightDirection": {
          type: "fv",
          value: []
        },
        "directionalLightColor": {
          type: "fv",
          value: []
        },
        "hemisphereLightDirection": {
          type: "fv",
          value: []
        },
        "hemisphereLightSkyColor": {
          type: "fv",
          value: []
        },
        "hemisphereLightGroundColor": {
          type: "fv",
          value: []
        },
        "pointLightColor": {
          type: "fv",
          value: []
        },
        "pointLightPosition": {
          type: "fv",
          value: []
        },
        "pointLightDistance": {
          type: "fv1",
          value: []
        },
        "pointLightDecay": {
          type: "fv1",
          value: []
        },
        "spotLightColor": {
          type: "fv",
          value: []
        },
        "spotLightPosition": {
          type: "fv",
          value: []
        },
        "spotLightDirection": {
          type: "fv",
          value: []
        },
        "spotLightDistance": {
          type: "fv1",
          value: []
        },
        "spotLightAngleCos": {
          type: "fv1",
          value: []
        },
        "spotLightExponent": {
          type: "fv1",
          value: []
        },
        "spotLightDecay": {
          type: "fv1",
          value: []
        }
      },
      particle: {
        "psColor": {
          type: "c",
          value: new THREE.Color(0xeeeeee)
        },
        "opacity": {
          type: "f",
          value: 1.0
        },
        "size": {
          type: "f",
          value: 1.0
        },
        "scale": {
          type: "f",
          value: 1.0
        },
        "map": {
          type: "t",
          value: null
        },
        "offsetRepeat": {
          type: "v4",
          value: new THREE.Vector4(0, 0, 1, 1)
        },
        "fogDensity": {
          type: "f",
          value: 0.00025
        },
        "fogNear": {
          type: "f",
          value: 1
        },
        "fogFar": {
          type: "f",
          value: 2000
        },
        "fogColor": {
          type: "c",
          value: new THREE.Color(0xffffff)
        }
      },
      shadowmap: {
        "shadowMap": {
          type: "tv",
          value: []
        },
        "shadowMapSize": {
          type: "v2v",
          value: []
        },
        "shadowBias": {
          type: "fv1",
          value: []
        },
        "shadowDarkness": {
          type: "fv1",
          value: []
        },
        "shadowMatrix": {
          type: "m4v",
          value: []
        }
      }
    };
    THREE.ShaderLib = {
      'basic': {
        uniforms: THREE.UniformsUtils.merge([THREE.UniformsLib["common"], THREE.UniformsLib["fog"], THREE.UniformsLib["shadowmap"]]),
        vertexShader: [THREE.ShaderChunk["common"], THREE.ShaderChunk["map_pars_vertex"], THREE.ShaderChunk["lightmap_pars_vertex"], THREE.ShaderChunk["envmap_pars_vertex"], THREE.ShaderChunk["color_pars_vertex"], THREE.ShaderChunk["morphtarget_pars_vertex"], THREE.ShaderChunk["skinning_pars_vertex"], THREE.ShaderChunk["shadowmap_pars_vertex"], THREE.ShaderChunk["logdepthbuf_pars_vertex"], "void main() {", THREE.ShaderChunk["map_vertex"], THREE.ShaderChunk["lightmap_vertex"], THREE.ShaderChunk["color_vertex"], THREE.ShaderChunk["skinbase_vertex"], "	#ifdef USE_ENVMAP", THREE.ShaderChunk["morphnormal_vertex"], THREE.ShaderChunk["skinnormal_vertex"], THREE.ShaderChunk["defaultnormal_vertex"], "	#endif", THREE.ShaderChunk["morphtarget_vertex"], THREE.ShaderChunk["skinning_vertex"], THREE.ShaderChunk["default_vertex"], THREE.ShaderChunk["logdepthbuf_vertex"], THREE.ShaderChunk["worldpos_vertex"], THREE.ShaderChunk["envmap_vertex"], THREE.ShaderChunk["shadowmap_vertex"], "}"].join("\n"),
        fragmentShader: ["uniform vec3 diffuse;", "uniform float opacity;", THREE.ShaderChunk["common"], THREE.ShaderChunk["color_pars_fragment"], THREE.ShaderChunk["map_pars_fragment"], THREE.ShaderChunk["alphamap_pars_fragment"], THREE.ShaderChunk["lightmap_pars_fragment"], THREE.ShaderChunk["envmap_pars_fragment"], THREE.ShaderChunk["fog_pars_fragment"], THREE.ShaderChunk["shadowmap_pars_fragment"], THREE.ShaderChunk["specularmap_pars_fragment"], THREE.ShaderChunk["logdepthbuf_pars_fragment"], "void main() {", "	vec3 outgoingLight = vec3( 0.0 );", "	vec4 diffuseColor = vec4( diffuse, opacity );", THREE.ShaderChunk["logdepthbuf_fragment"], THREE.ShaderChunk["map_fragment"], THREE.ShaderChunk["color_fragment"], THREE.ShaderChunk["alphamap_fragment"], THREE.ShaderChunk["alphatest_fragment"], THREE.ShaderChunk["specularmap_fragment"], "	outgoingLight = diffuseColor.rgb;", THREE.ShaderChunk["lightmap_fragment"], THREE.ShaderChunk["envmap_fragment"], THREE.ShaderChunk["shadowmap_fragment"], THREE.ShaderChunk["linear_to_gamma_fragment"], THREE.ShaderChunk["fog_fragment"], "	gl_FragColor = vec4( outgoingLight, diffuseColor.a );", "}"].join("\n")
      },
      'lambert': {
        uniforms: THREE.UniformsUtils.merge([THREE.UniformsLib["common"], THREE.UniformsLib["fog"], THREE.UniformsLib["lights"], THREE.UniformsLib["shadowmap"], {
          "emissive": {
            type: "c",
            value: new THREE.Color(0x000000)
          },
          "wrapRGB": {
            type: "v3",
            value: new THREE.Vector3(1, 1, 1)
          }
        }]),
        vertexShader: ["#define LAMBERT", "varying vec3 vLightFront;", "#ifdef DOUBLE_SIDED", "	varying vec3 vLightBack;", "#endif", THREE.ShaderChunk["common"], THREE.ShaderChunk["map_pars_vertex"], THREE.ShaderChunk["lightmap_pars_vertex"], THREE.ShaderChunk["envmap_pars_vertex"], THREE.ShaderChunk["lights_lambert_pars_vertex"], THREE.ShaderChunk["color_pars_vertex"], THREE.ShaderChunk["morphtarget_pars_vertex"], THREE.ShaderChunk["skinning_pars_vertex"], THREE.ShaderChunk["shadowmap_pars_vertex"], THREE.ShaderChunk["logdepthbuf_pars_vertex"], "void main() {", THREE.ShaderChunk["map_vertex"], THREE.ShaderChunk["lightmap_vertex"], THREE.ShaderChunk["color_vertex"], THREE.ShaderChunk["morphnormal_vertex"], THREE.ShaderChunk["skinbase_vertex"], THREE.ShaderChunk["skinnormal_vertex"], THREE.ShaderChunk["defaultnormal_vertex"], THREE.ShaderChunk["morphtarget_vertex"], THREE.ShaderChunk["skinning_vertex"], THREE.ShaderChunk["default_vertex"], THREE.ShaderChunk["logdepthbuf_vertex"], THREE.ShaderChunk["worldpos_vertex"], THREE.ShaderChunk["envmap_vertex"], THREE.ShaderChunk["lights_lambert_vertex"], THREE.ShaderChunk["shadowmap_vertex"], "}"].join("\n"),
        fragmentShader: ["uniform vec3 diffuse;", "uniform vec3 emissive;", "uniform float opacity;", "varying vec3 vLightFront;", "#ifdef DOUBLE_SIDED", "	varying vec3 vLightBack;", "#endif", THREE.ShaderChunk["common"], THREE.ShaderChunk["color_pars_fragment"], THREE.ShaderChunk["map_pars_fragment"], THREE.ShaderChunk["alphamap_pars_fragment"], THREE.ShaderChunk["lightmap_pars_fragment"], THREE.ShaderChunk["envmap_pars_fragment"], THREE.ShaderChunk["fog_pars_fragment"], THREE.ShaderChunk["shadowmap_pars_fragment"], THREE.ShaderChunk["specularmap_pars_fragment"], THREE.ShaderChunk["logdepthbuf_pars_fragment"], "void main() {", "	vec3 outgoingLight = vec3( 0.0 );", "	vec4 diffuseColor = vec4( diffuse, opacity );", THREE.ShaderChunk["logdepthbuf_fragment"], THREE.ShaderChunk["map_fragment"], THREE.ShaderChunk["color_fragment"], THREE.ShaderChunk["alphamap_fragment"], THREE.ShaderChunk["alphatest_fragment"], THREE.ShaderChunk["specularmap_fragment"], "	#ifdef DOUBLE_SIDED", "		if ( gl_FrontFacing )", "			outgoingLight += diffuseColor.rgb * vLightFront + emissive;", "		else", "			outgoingLight += diffuseColor.rgb * vLightBack + emissive;", "	#else", "		outgoingLight += diffuseColor.rgb * vLightFront + emissive;", "	#endif", THREE.ShaderChunk["lightmap_fragment"], THREE.ShaderChunk["envmap_fragment"], THREE.ShaderChunk["shadowmap_fragment"], THREE.ShaderChunk["linear_to_gamma_fragment"], THREE.ShaderChunk["fog_fragment"], "	gl_FragColor = vec4( outgoingLight, diffuseColor.a );", "}"].join("\n")
      },
      'phong': {
        uniforms: THREE.UniformsUtils.merge([THREE.UniformsLib["common"], THREE.UniformsLib["bump"], THREE.UniformsLib["normalmap"], THREE.UniformsLib["fog"], THREE.UniformsLib["lights"], THREE.UniformsLib["shadowmap"], {
          "emissive": {
            type: "c",
            value: new THREE.Color(0x000000)
          },
          "specular": {
            type: "c",
            value: new THREE.Color(0x111111)
          },
          "shininess": {
            type: "f",
            value: 30
          },
          "wrapRGB": {
            type: "v3",
            value: new THREE.Vector3(1, 1, 1)
          }
        }]),
        vertexShader: ["#define PHONG", "varying vec3 vViewPosition;", "#ifndef FLAT_SHADED", "	varying vec3 vNormal;", "#endif", THREE.ShaderChunk["common"], THREE.ShaderChunk["map_pars_vertex"], THREE.ShaderChunk["lightmap_pars_vertex"], THREE.ShaderChunk["envmap_pars_vertex"], THREE.ShaderChunk["lights_phong_pars_vertex"], THREE.ShaderChunk["color_pars_vertex"], THREE.ShaderChunk["morphtarget_pars_vertex"], THREE.ShaderChunk["skinning_pars_vertex"], THREE.ShaderChunk["shadowmap_pars_vertex"], THREE.ShaderChunk["logdepthbuf_pars_vertex"], "void main() {", THREE.ShaderChunk["map_vertex"], THREE.ShaderChunk["lightmap_vertex"], THREE.ShaderChunk["color_vertex"], THREE.ShaderChunk["morphnormal_vertex"], THREE.ShaderChunk["skinbase_vertex"], THREE.ShaderChunk["skinnormal_vertex"], THREE.ShaderChunk["defaultnormal_vertex"], "#ifndef FLAT_SHADED", "	vNormal = normalize( transformedNormal );", "#endif", THREE.ShaderChunk["morphtarget_vertex"], THREE.ShaderChunk["skinning_vertex"], THREE.ShaderChunk["default_vertex"], THREE.ShaderChunk["logdepthbuf_vertex"], "	vViewPosition = -mvPosition.xyz;", THREE.ShaderChunk["worldpos_vertex"], THREE.ShaderChunk["envmap_vertex"], THREE.ShaderChunk["lights_phong_vertex"], THREE.ShaderChunk["shadowmap_vertex"], "}"].join("\n"),
        fragmentShader: ["#define PHONG", "uniform vec3 diffuse;", "uniform vec3 emissive;", "uniform vec3 specular;", "uniform float shininess;", "uniform float opacity;", THREE.ShaderChunk["common"], THREE.ShaderChunk["color_pars_fragment"], THREE.ShaderChunk["map_pars_fragment"], THREE.ShaderChunk["alphamap_pars_fragment"], THREE.ShaderChunk["lightmap_pars_fragment"], THREE.ShaderChunk["envmap_pars_fragment"], THREE.ShaderChunk["fog_pars_fragment"], THREE.ShaderChunk["lights_phong_pars_fragment"], THREE.ShaderChunk["shadowmap_pars_fragment"], THREE.ShaderChunk["bumpmap_pars_fragment"], THREE.ShaderChunk["normalmap_pars_fragment"], THREE.ShaderChunk["specularmap_pars_fragment"], THREE.ShaderChunk["logdepthbuf_pars_fragment"], "void main() {", "	vec3 outgoingLight = vec3( 0.0 );", "	vec4 diffuseColor = vec4( diffuse, opacity );", THREE.ShaderChunk["logdepthbuf_fragment"], THREE.ShaderChunk["map_fragment"], THREE.ShaderChunk["color_fragment"], THREE.ShaderChunk["alphamap_fragment"], THREE.ShaderChunk["alphatest_fragment"], THREE.ShaderChunk["specularmap_fragment"], THREE.ShaderChunk["lights_phong_fragment"], THREE.ShaderChunk["lightmap_fragment"], THREE.ShaderChunk["envmap_fragment"], THREE.ShaderChunk["shadowmap_fragment"], THREE.ShaderChunk["linear_to_gamma_fragment"], THREE.ShaderChunk["fog_fragment"], "	gl_FragColor = vec4( outgoingLight, diffuseColor.a );", "}"].join("\n")
      },
      'particle_basic': {
        uniforms: THREE.UniformsUtils.merge([THREE.UniformsLib["particle"], THREE.UniformsLib["shadowmap"]]),
        vertexShader: ["uniform float size;", "uniform float scale;", THREE.ShaderChunk["common"], THREE.ShaderChunk["color_pars_vertex"], THREE.ShaderChunk["shadowmap_pars_vertex"], THREE.ShaderChunk["logdepthbuf_pars_vertex"], "void main() {", THREE.ShaderChunk["color_vertex"], "	vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );", "	#ifdef USE_SIZEATTENUATION", "		gl_PointSize = size * ( scale / length( mvPosition.xyz ) );", "	#else", "		gl_PointSize = size;", "	#endif", "	gl_Position = projectionMatrix * mvPosition;", THREE.ShaderChunk["logdepthbuf_vertex"], THREE.ShaderChunk["worldpos_vertex"], THREE.ShaderChunk["shadowmap_vertex"], "}"].join("\n"),
        fragmentShader: ["uniform vec3 psColor;", "uniform float opacity;", THREE.ShaderChunk["common"], THREE.ShaderChunk["color_pars_fragment"], THREE.ShaderChunk["map_particle_pars_fragment"], THREE.ShaderChunk["fog_pars_fragment"], THREE.ShaderChunk["shadowmap_pars_fragment"], THREE.ShaderChunk["logdepthbuf_pars_fragment"], "void main() {", "	vec3 outgoingLight = vec3( 0.0 );", "	vec4 diffuseColor = vec4( psColor, opacity );", THREE.ShaderChunk["logdepthbuf_fragment"], THREE.ShaderChunk["map_particle_fragment"], THREE.ShaderChunk["color_fragment"], THREE.ShaderChunk["alphatest_fragment"], "	outgoingLight = diffuseColor.rgb;", THREE.ShaderChunk["shadowmap_fragment"], THREE.ShaderChunk["fog_fragment"], "	gl_FragColor = vec4( outgoingLight, diffuseColor.a );", "}"].join("\n")
      },
      'dashed': {
        uniforms: THREE.UniformsUtils.merge([THREE.UniformsLib["common"], THREE.UniformsLib["fog"], {
          "scale": {
            type: "f",
            value: 1
          },
          "dashSize": {
            type: "f",
            value: 1
          },
          "totalSize": {
            type: "f",
            value: 2
          }
        }]),
        vertexShader: ["uniform float scale;", "attribute float lineDistance;", "varying float vLineDistance;", THREE.ShaderChunk["common"], THREE.ShaderChunk["color_pars_vertex"], THREE.ShaderChunk["logdepthbuf_pars_vertex"], "void main() {", THREE.ShaderChunk["color_vertex"], "	vLineDistance = scale * lineDistance;", "	vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );", "	gl_Position = projectionMatrix * mvPosition;", THREE.ShaderChunk["logdepthbuf_vertex"], "}"].join("\n"),
        fragmentShader: ["uniform vec3 diffuse;", "uniform float opacity;", "uniform float dashSize;", "uniform float totalSize;", "varying float vLineDistance;", THREE.ShaderChunk["common"], THREE.ShaderChunk["color_pars_fragment"], THREE.ShaderChunk["fog_pars_fragment"], THREE.ShaderChunk["logdepthbuf_pars_fragment"], "void main() {", "	if ( mod( vLineDistance, totalSize ) > dashSize ) {", "		discard;", "	}", "	vec3 outgoingLight = vec3( 0.0 );", "	vec4 diffuseColor = vec4( diffuse, opacity );", THREE.ShaderChunk["logdepthbuf_fragment"], THREE.ShaderChunk["color_fragment"], "	outgoingLight = diffuseColor.rgb;", THREE.ShaderChunk["fog_fragment"], "	gl_FragColor = vec4( outgoingLight, diffuseColor.a );", "}"].join("\n")
      },
      'depth': {
        uniforms: {
          "mNear": {
            type: "f",
            value: 1.0
          },
          "mFar": {
            type: "f",
            value: 2000.0
          },
          "opacity": {
            type: "f",
            value: 1.0
          }
        },
        vertexShader: [THREE.ShaderChunk["common"], THREE.ShaderChunk["morphtarget_pars_vertex"], THREE.ShaderChunk["logdepthbuf_pars_vertex"], "void main() {", THREE.ShaderChunk["morphtarget_vertex"], THREE.ShaderChunk["default_vertex"], THREE.ShaderChunk["logdepthbuf_vertex"], "}"].join("\n"),
        fragmentShader: ["uniform float mNear;", "uniform float mFar;", "uniform float opacity;", THREE.ShaderChunk["common"], THREE.ShaderChunk["logdepthbuf_pars_fragment"], "void main() {", THREE.ShaderChunk["logdepthbuf_fragment"], "	#ifdef USE_LOGDEPTHBUF_EXT", "		float depth = gl_FragDepthEXT / gl_FragCoord.w;", "	#else", "		float depth = gl_FragCoord.z / gl_FragCoord.w;", "	#endif", "	float color = 1.0 - smoothstep( mNear, mFar, depth );", "	gl_FragColor = vec4( vec3( color ), opacity );", "}"].join("\n")
      },
      'normal': {
        uniforms: {"opacity": {
            type: "f",
            value: 1.0
          }},
        vertexShader: ["varying vec3 vNormal;", THREE.ShaderChunk["common"], THREE.ShaderChunk["morphtarget_pars_vertex"], THREE.ShaderChunk["logdepthbuf_pars_vertex"], "void main() {", "	vNormal = normalize( normalMatrix * normal );", THREE.ShaderChunk["morphtarget_vertex"], THREE.ShaderChunk["default_vertex"], THREE.ShaderChunk["logdepthbuf_vertex"], "}"].join("\n"),
        fragmentShader: ["uniform float opacity;", "varying vec3 vNormal;", THREE.ShaderChunk["common"], THREE.ShaderChunk["logdepthbuf_pars_fragment"], "void main() {", "	gl_FragColor = vec4( 0.5 * normalize( vNormal ) + 0.5, opacity );", THREE.ShaderChunk["logdepthbuf_fragment"], "}"].join("\n")
      },
      'cube': {
        uniforms: {
          "tCube": {
            type: "t",
            value: null
          },
          "tFlip": {
            type: "f",
            value: -1
          }
        },
        vertexShader: ["varying vec3 vWorldPosition;", THREE.ShaderChunk["common"], THREE.ShaderChunk["logdepthbuf_pars_vertex"], "void main() {", "	vWorldPosition = transformDirection( position, modelMatrix );", "	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );", THREE.ShaderChunk["logdepthbuf_vertex"], "}"].join("\n"),
        fragmentShader: ["uniform samplerCube tCube;", "uniform float tFlip;", "varying vec3 vWorldPosition;", THREE.ShaderChunk["common"], THREE.ShaderChunk["logdepthbuf_pars_fragment"], "void main() {", "	gl_FragColor = textureCube( tCube, vec3( tFlip * vWorldPosition.x, vWorldPosition.yz ) );", THREE.ShaderChunk["logdepthbuf_fragment"], "}"].join("\n")
      },
      'equirect': {
        uniforms: {
          "tEquirect": {
            type: "t",
            value: null
          },
          "tFlip": {
            type: "f",
            value: -1
          }
        },
        vertexShader: ["varying vec3 vWorldPosition;", THREE.ShaderChunk["common"], THREE.ShaderChunk["logdepthbuf_pars_vertex"], "void main() {", "	vWorldPosition = transformDirection( position, modelMatrix );", "	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );", THREE.ShaderChunk["logdepthbuf_vertex"], "}"].join("\n"),
        fragmentShader: ["uniform sampler2D tEquirect;", "uniform float tFlip;", "varying vec3 vWorldPosition;", THREE.ShaderChunk["common"], THREE.ShaderChunk["logdepthbuf_pars_fragment"], "void main() {", "vec3 direction = normalize( vWorldPosition );", "vec2 sampleUV;", "sampleUV.y = saturate( tFlip * direction.y * -0.5 + 0.5 );", "sampleUV.x = atan( direction.z, direction.x ) * RECIPROCAL_PI2 + 0.5;", "gl_FragColor = texture2D( tEquirect, sampleUV );", THREE.ShaderChunk["logdepthbuf_fragment"], "}"].join("\n")
      },
      'depthRGBA': {
        uniforms: {},
        vertexShader: [THREE.ShaderChunk["common"], THREE.ShaderChunk["morphtarget_pars_vertex"], THREE.ShaderChunk["skinning_pars_vertex"], THREE.ShaderChunk["logdepthbuf_pars_vertex"], "void main() {", THREE.ShaderChunk["skinbase_vertex"], THREE.ShaderChunk["morphtarget_vertex"], THREE.ShaderChunk["skinning_vertex"], THREE.ShaderChunk["default_vertex"], THREE.ShaderChunk["logdepthbuf_vertex"], "}"].join("\n"),
        fragmentShader: [THREE.ShaderChunk["common"], THREE.ShaderChunk["logdepthbuf_pars_fragment"], "vec4 pack_depth( const in float depth ) {", "	const vec4 bit_shift = vec4( 256.0 * 256.0 * 256.0, 256.0 * 256.0, 256.0, 1.0 );", "	const vec4 bit_mask = vec4( 0.0, 1.0 / 256.0, 1.0 / 256.0, 1.0 / 256.0 );", "	vec4 res = mod( depth * bit_shift * vec4( 255 ), vec4( 256 ) ) / vec4( 255 );", "	res -= res.xxyz * bit_mask;", "	return res;", "}", "void main() {", THREE.ShaderChunk["logdepthbuf_fragment"], "	#ifdef USE_LOGDEPTHBUF_EXT", "		gl_FragData[ 0 ] = pack_depth( gl_FragDepthEXT );", "	#else", "		gl_FragData[ 0 ] = pack_depth( gl_FragCoord.z );", "	#endif", "}"].join("\n")
      }
    };
    THREE.WebGLRenderer = function(parameters) {
      console.log('THREE.WebGLRenderer', THREE.REVISION);
      parameters = parameters || {};
      var _canvas = parameters.canvas !== undefined ? parameters.canvas : document.createElement('canvas'),
          _context = parameters.context !== undefined ? parameters.context : null,
          pixelRatio = 1,
          _precision = parameters.precision !== undefined ? parameters.precision : 'highp',
          _alpha = parameters.alpha !== undefined ? parameters.alpha : false,
          _depth = parameters.depth !== undefined ? parameters.depth : true,
          _stencil = parameters.stencil !== undefined ? parameters.stencil : true,
          _antialias = parameters.antialias !== undefined ? parameters.antialias : false,
          _premultipliedAlpha = parameters.premultipliedAlpha !== undefined ? parameters.premultipliedAlpha : true,
          _preserveDrawingBuffer = parameters.preserveDrawingBuffer !== undefined ? parameters.preserveDrawingBuffer : false,
          _logarithmicDepthBuffer = parameters.logarithmicDepthBuffer !== undefined ? parameters.logarithmicDepthBuffer : false,
          _clearColor = new THREE.Color(0x000000),
          _clearAlpha = 0;
      var lights = [];
      var _webglObjects = {};
      var _webglObjectsImmediate = [];
      var opaqueObjects = [];
      var transparentObjects = [];
      var sprites = [];
      var lensFlares = [];
      this.domElement = _canvas;
      this.context = null;
      this.autoClear = true;
      this.autoClearColor = true;
      this.autoClearDepth = true;
      this.autoClearStencil = true;
      this.sortObjects = true;
      this.gammaFactor = 2.0;
      this.gammaInput = false;
      this.gammaOutput = false;
      this.shadowMapEnabled = false;
      this.shadowMapType = THREE.PCFShadowMap;
      this.shadowMapCullFace = THREE.CullFaceFront;
      this.shadowMapDebug = false;
      this.shadowMapCascade = false;
      this.maxMorphTargets = 8;
      this.maxMorphNormals = 4;
      this.autoScaleCubemaps = true;
      this.info = {
        memory: {
          programs: 0,
          geometries: 0,
          textures: 0
        },
        render: {
          calls: 0,
          vertices: 0,
          faces: 0,
          points: 0
        }
      };
      var _this = this,
          _programs = [],
          _currentProgram = null,
          _currentFramebuffer = null,
          _currentMaterialId = -1,
          _currentGeometryProgram = '',
          _currentCamera = null,
          _usedTextureUnits = 0,
          _viewportX = 0,
          _viewportY = 0,
          _viewportWidth = _canvas.width,
          _viewportHeight = _canvas.height,
          _currentWidth = 0,
          _currentHeight = 0,
          _frustum = new THREE.Frustum(),
          _projScreenMatrix = new THREE.Matrix4(),
          _vector3 = new THREE.Vector3(),
          _direction = new THREE.Vector3(),
          _lightsNeedUpdate = true,
          _lights = {
            ambient: [0, 0, 0],
            directional: {
              length: 0,
              colors: [],
              positions: []
            },
            point: {
              length: 0,
              colors: [],
              positions: [],
              distances: [],
              decays: []
            },
            spot: {
              length: 0,
              colors: [],
              positions: [],
              distances: [],
              directions: [],
              anglesCos: [],
              exponents: [],
              decays: []
            },
            hemi: {
              length: 0,
              skyColors: [],
              groundColors: [],
              positions: []
            }
          };
      var _gl;
      try {
        var attributes = {
          alpha: _alpha,
          depth: _depth,
          stencil: _stencil,
          antialias: _antialias,
          premultipliedAlpha: _premultipliedAlpha,
          preserveDrawingBuffer: _preserveDrawingBuffer
        };
        _gl = _context || _canvas.getContext('webgl', attributes) || _canvas.getContext('experimental-webgl', attributes);
        if (_gl === null) {
          if (_canvas.getContext('webgl') !== null) {
            throw 'Error creating WebGL context with your selected attributes.';
          } else {
            throw 'Error creating WebGL context.';
          }
        }
        _canvas.addEventListener('webglcontextlost', function(event) {
          event.preventDefault();
          resetGLState();
          setDefaultGLState();
          _webglObjects = {};
        }, false);
      } catch (error) {
        THREE.error('THREE.WebGLRenderer: ' + error);
      }
      var state = new THREE.WebGLState(_gl, paramThreeToGL);
      if (_gl.getShaderPrecisionFormat === undefined) {
        _gl.getShaderPrecisionFormat = function() {
          return {
            'rangeMin': 1,
            'rangeMax': 1,
            'precision': 1
          };
        };
      }
      var extensions = new THREE.WebGLExtensions(_gl);
      extensions.get('OES_texture_float');
      extensions.get('OES_texture_float_linear');
      extensions.get('OES_texture_half_float');
      extensions.get('OES_texture_half_float_linear');
      extensions.get('OES_standard_derivatives');
      if (_logarithmicDepthBuffer) {
        extensions.get('EXT_frag_depth');
      }
      var glClearColor = function(r, g, b, a) {
        if (_premultipliedAlpha === true) {
          r *= a;
          g *= a;
          b *= a;
        }
        _gl.clearColor(r, g, b, a);
      };
      var setDefaultGLState = function() {
        _gl.clearColor(0, 0, 0, 1);
        _gl.clearDepth(1);
        _gl.clearStencil(0);
        _gl.enable(_gl.DEPTH_TEST);
        _gl.depthFunc(_gl.LEQUAL);
        _gl.frontFace(_gl.CCW);
        _gl.cullFace(_gl.BACK);
        _gl.enable(_gl.CULL_FACE);
        _gl.enable(_gl.BLEND);
        _gl.blendEquation(_gl.FUNC_ADD);
        _gl.blendFunc(_gl.SRC_ALPHA, _gl.ONE_MINUS_SRC_ALPHA);
        _gl.viewport(_viewportX, _viewportY, _viewportWidth, _viewportHeight);
        glClearColor(_clearColor.r, _clearColor.g, _clearColor.b, _clearAlpha);
      };
      var resetGLState = function() {
        _currentProgram = null;
        _currentCamera = null;
        _currentGeometryProgram = '';
        _currentMaterialId = -1;
        _lightsNeedUpdate = true;
        state.reset();
      };
      setDefaultGLState();
      this.context = _gl;
      this.state = state;
      var _maxTextures = _gl.getParameter(_gl.MAX_TEXTURE_IMAGE_UNITS);
      var _maxVertexTextures = _gl.getParameter(_gl.MAX_VERTEX_TEXTURE_IMAGE_UNITS);
      var _maxTextureSize = _gl.getParameter(_gl.MAX_TEXTURE_SIZE);
      var _maxCubemapSize = _gl.getParameter(_gl.MAX_CUBE_MAP_TEXTURE_SIZE);
      var _supportsVertexTextures = _maxVertexTextures > 0;
      var _supportsBoneTextures = _supportsVertexTextures && extensions.get('OES_texture_float');
      var _vertexShaderPrecisionHighpFloat = _gl.getShaderPrecisionFormat(_gl.VERTEX_SHADER, _gl.HIGH_FLOAT);
      var _vertexShaderPrecisionMediumpFloat = _gl.getShaderPrecisionFormat(_gl.VERTEX_SHADER, _gl.MEDIUM_FLOAT);
      var _fragmentShaderPrecisionHighpFloat = _gl.getShaderPrecisionFormat(_gl.FRAGMENT_SHADER, _gl.HIGH_FLOAT);
      var _fragmentShaderPrecisionMediumpFloat = _gl.getShaderPrecisionFormat(_gl.FRAGMENT_SHADER, _gl.MEDIUM_FLOAT);
      var getCompressedTextureFormats = (function() {
        var array;
        return function() {
          if (array !== undefined) {
            return array;
          }
          array = [];
          if (extensions.get('WEBGL_compressed_texture_pvrtc') || extensions.get('WEBGL_compressed_texture_s3tc')) {
            var formats = _gl.getParameter(_gl.COMPRESSED_TEXTURE_FORMATS);
            for (var i = 0; i < formats.length; i++) {
              array.push(formats[i]);
            }
          }
          return array;
        };
      })();
      var highpAvailable = _vertexShaderPrecisionHighpFloat.precision > 0 && _fragmentShaderPrecisionHighpFloat.precision > 0;
      var mediumpAvailable = _vertexShaderPrecisionMediumpFloat.precision > 0 && _fragmentShaderPrecisionMediumpFloat.precision > 0;
      if (_precision === 'highp' && !highpAvailable) {
        if (mediumpAvailable) {
          _precision = 'mediump';
          THREE.warn('THREE.WebGLRenderer: highp not supported, using mediump.');
        } else {
          _precision = 'lowp';
          THREE.warn('THREE.WebGLRenderer: highp and mediump not supported, using lowp.');
        }
      }
      if (_precision === 'mediump' && !mediumpAvailable) {
        _precision = 'lowp';
        THREE.warn('THREE.WebGLRenderer: mediump not supported, using lowp.');
      }
      var shadowMapPlugin = new THREE.ShadowMapPlugin(this, lights, _webglObjects, _webglObjectsImmediate);
      var spritePlugin = new THREE.SpritePlugin(this, sprites);
      var lensFlarePlugin = new THREE.LensFlarePlugin(this, lensFlares);
      this.getContext = function() {
        return _gl;
      };
      this.forceContextLoss = function() {
        extensions.get('WEBGL_lose_context').loseContext();
      };
      this.supportsVertexTextures = function() {
        return _supportsVertexTextures;
      };
      this.supportsFloatTextures = function() {
        return extensions.get('OES_texture_float');
      };
      this.supportsHalfFloatTextures = function() {
        return extensions.get('OES_texture_half_float');
      };
      this.supportsStandardDerivatives = function() {
        return extensions.get('OES_standard_derivatives');
      };
      this.supportsCompressedTextureS3TC = function() {
        return extensions.get('WEBGL_compressed_texture_s3tc');
      };
      this.supportsCompressedTexturePVRTC = function() {
        return extensions.get('WEBGL_compressed_texture_pvrtc');
      };
      this.supportsBlendMinMax = function() {
        return extensions.get('EXT_blend_minmax');
      };
      this.getMaxAnisotropy = (function() {
        var value;
        return function() {
          if (value !== undefined) {
            return value;
          }
          var extension = extensions.get('EXT_texture_filter_anisotropic');
          value = extension !== null ? _gl.getParameter(extension.MAX_TEXTURE_MAX_ANISOTROPY_EXT) : 0;
          return value;
        };
      })();
      this.getPrecision = function() {
        return _precision;
      };
      this.getPixelRatio = function() {
        return pixelRatio;
      };
      this.setPixelRatio = function(value) {
        pixelRatio = value;
      };
      this.setSize = function(width, height, updateStyle) {
        _canvas.width = width * pixelRatio;
        _canvas.height = height * pixelRatio;
        if (updateStyle !== false) {
          _canvas.style.width = width + 'px';
          _canvas.style.height = height + 'px';
        }
        this.setViewport(0, 0, width, height);
      };
      this.setViewport = function(x, y, width, height) {
        _viewportX = x * pixelRatio;
        _viewportY = y * pixelRatio;
        _viewportWidth = width * pixelRatio;
        _viewportHeight = height * pixelRatio;
        _gl.viewport(_viewportX, _viewportY, _viewportWidth, _viewportHeight);
      };
      this.setScissor = function(x, y, width, height) {
        _gl.scissor(x * pixelRatio, y * pixelRatio, width * pixelRatio, height * pixelRatio);
      };
      this.enableScissorTest = function(enable) {
        enable ? _gl.enable(_gl.SCISSOR_TEST) : _gl.disable(_gl.SCISSOR_TEST);
      };
      this.getClearColor = function() {
        return _clearColor;
      };
      this.setClearColor = function(color, alpha) {
        _clearColor.set(color);
        _clearAlpha = alpha !== undefined ? alpha : 1;
        glClearColor(_clearColor.r, _clearColor.g, _clearColor.b, _clearAlpha);
      };
      this.getClearAlpha = function() {
        return _clearAlpha;
      };
      this.setClearAlpha = function(alpha) {
        _clearAlpha = alpha;
        glClearColor(_clearColor.r, _clearColor.g, _clearColor.b, _clearAlpha);
      };
      this.clear = function(color, depth, stencil) {
        var bits = 0;
        if (color === undefined || color)
          bits |= _gl.COLOR_BUFFER_BIT;
        if (depth === undefined || depth)
          bits |= _gl.DEPTH_BUFFER_BIT;
        if (stencil === undefined || stencil)
          bits |= _gl.STENCIL_BUFFER_BIT;
        _gl.clear(bits);
      };
      this.clearColor = function() {
        _gl.clear(_gl.COLOR_BUFFER_BIT);
      };
      this.clearDepth = function() {
        _gl.clear(_gl.DEPTH_BUFFER_BIT);
      };
      this.clearStencil = function() {
        _gl.clear(_gl.STENCIL_BUFFER_BIT);
      };
      this.clearTarget = function(renderTarget, color, depth, stencil) {
        this.setRenderTarget(renderTarget);
        this.clear(color, depth, stencil);
      };
      this.resetGLState = resetGLState;
      function createParticleBuffers(geometry) {
        geometry.__webglVertexBuffer = _gl.createBuffer();
        geometry.__webglColorBuffer = _gl.createBuffer();
        _this.info.memory.geometries++;
      }
      ;
      function createLineBuffers(geometry) {
        geometry.__webglVertexBuffer = _gl.createBuffer();
        geometry.__webglColorBuffer = _gl.createBuffer();
        geometry.__webglLineDistanceBuffer = _gl.createBuffer();
        _this.info.memory.geometries++;
      }
      ;
      function createMeshBuffers(geometryGroup) {
        geometryGroup.__webglVertexBuffer = _gl.createBuffer();
        geometryGroup.__webglNormalBuffer = _gl.createBuffer();
        geometryGroup.__webglTangentBuffer = _gl.createBuffer();
        geometryGroup.__webglColorBuffer = _gl.createBuffer();
        geometryGroup.__webglUVBuffer = _gl.createBuffer();
        geometryGroup.__webglUV2Buffer = _gl.createBuffer();
        geometryGroup.__webglSkinIndicesBuffer = _gl.createBuffer();
        geometryGroup.__webglSkinWeightsBuffer = _gl.createBuffer();
        geometryGroup.__webglFaceBuffer = _gl.createBuffer();
        geometryGroup.__webglLineBuffer = _gl.createBuffer();
        var numMorphTargets = geometryGroup.numMorphTargets;
        if (numMorphTargets) {
          geometryGroup.__webglMorphTargetsBuffers = [];
          for (var m = 0,
              ml = numMorphTargets; m < ml; m++) {
            geometryGroup.__webglMorphTargetsBuffers.push(_gl.createBuffer());
          }
        }
        var numMorphNormals = geometryGroup.numMorphNormals;
        if (numMorphNormals) {
          geometryGroup.__webglMorphNormalsBuffers = [];
          for (var m = 0,
              ml = numMorphNormals; m < ml; m++) {
            geometryGroup.__webglMorphNormalsBuffers.push(_gl.createBuffer());
          }
        }
        _this.info.memory.geometries++;
      }
      ;
      var onObjectRemoved = function(event) {
        var object = event.target;
        object.traverse(function(child) {
          child.removeEventListener('remove', onObjectRemoved);
          removeObject(child);
        });
      };
      var onGeometryDispose = function(event) {
        var geometry = event.target;
        geometry.removeEventListener('dispose', onGeometryDispose);
        deallocateGeometry(geometry);
      };
      var onTextureDispose = function(event) {
        var texture = event.target;
        texture.removeEventListener('dispose', onTextureDispose);
        deallocateTexture(texture);
        _this.info.memory.textures--;
      };
      var onRenderTargetDispose = function(event) {
        var renderTarget = event.target;
        renderTarget.removeEventListener('dispose', onRenderTargetDispose);
        deallocateRenderTarget(renderTarget);
        _this.info.memory.textures--;
      };
      var onMaterialDispose = function(event) {
        var material = event.target;
        material.removeEventListener('dispose', onMaterialDispose);
        deallocateMaterial(material);
      };
      var deleteBuffers = function(geometry) {
        var buffers = ['__webglVertexBuffer', '__webglNormalBuffer', '__webglTangentBuffer', '__webglColorBuffer', '__webglUVBuffer', '__webglUV2Buffer', '__webglSkinIndicesBuffer', '__webglSkinWeightsBuffer', '__webglFaceBuffer', '__webglLineBuffer', '__webglLineDistanceBuffer'];
        for (var i = 0,
            l = buffers.length; i < l; i++) {
          var name = buffers[i];
          if (geometry[name] !== undefined) {
            _gl.deleteBuffer(geometry[name]);
            delete geometry[name];
          }
        }
        if (geometry.__webglCustomAttributesList !== undefined) {
          for (var name in geometry.__webglCustomAttributesList) {
            _gl.deleteBuffer(geometry.__webglCustomAttributesList[name].buffer);
          }
          delete geometry.__webglCustomAttributesList;
        }
        _this.info.memory.geometries--;
      };
      var deallocateGeometry = function(geometry) {
        delete geometry.__webglInit;
        if (geometry instanceof THREE.BufferGeometry) {
          for (var name in geometry.attributes) {
            var attribute = geometry.attributes[name];
            if (attribute.buffer !== undefined) {
              _gl.deleteBuffer(attribute.buffer);
              delete attribute.buffer;
            }
          }
          _this.info.memory.geometries--;
        } else {
          var geometryGroupsList = geometryGroups[geometry.id];
          if (geometryGroupsList !== undefined) {
            for (var i = 0,
                l = geometryGroupsList.length; i < l; i++) {
              var geometryGroup = geometryGroupsList[i];
              if (geometryGroup.numMorphTargets !== undefined) {
                for (var m = 0,
                    ml = geometryGroup.numMorphTargets; m < ml; m++) {
                  _gl.deleteBuffer(geometryGroup.__webglMorphTargetsBuffers[m]);
                }
                delete geometryGroup.__webglMorphTargetsBuffers;
              }
              if (geometryGroup.numMorphNormals !== undefined) {
                for (var m = 0,
                    ml = geometryGroup.numMorphNormals; m < ml; m++) {
                  _gl.deleteBuffer(geometryGroup.__webglMorphNormalsBuffers[m]);
                }
                delete geometryGroup.__webglMorphNormalsBuffers;
              }
              deleteBuffers(geometryGroup);
            }
            delete geometryGroups[geometry.id];
          } else {
            deleteBuffers(geometry);
          }
        }
        _currentGeometryProgram = '';
      };
      var deallocateTexture = function(texture) {
        if (texture.image && texture.image.__webglTextureCube) {
          _gl.deleteTexture(texture.image.__webglTextureCube);
          delete texture.image.__webglTextureCube;
        } else {
          if (texture.__webglInit === undefined)
            return ;
          _gl.deleteTexture(texture.__webglTexture);
          delete texture.__webglTexture;
          delete texture.__webglInit;
        }
      };
      var deallocateRenderTarget = function(renderTarget) {
        if (!renderTarget || renderTarget.__webglTexture === undefined)
          return ;
        _gl.deleteTexture(renderTarget.__webglTexture);
        delete renderTarget.__webglTexture;
        if (renderTarget instanceof THREE.WebGLRenderTargetCube) {
          for (var i = 0; i < 6; i++) {
            _gl.deleteFramebuffer(renderTarget.__webglFramebuffer[i]);
            _gl.deleteRenderbuffer(renderTarget.__webglRenderbuffer[i]);
          }
        } else {
          _gl.deleteFramebuffer(renderTarget.__webglFramebuffer);
          _gl.deleteRenderbuffer(renderTarget.__webglRenderbuffer);
        }
        delete renderTarget.__webglFramebuffer;
        delete renderTarget.__webglRenderbuffer;
      };
      var deallocateMaterial = function(material) {
        var program = material.program.program;
        if (program === undefined)
          return ;
        material.program = undefined;
        var i,
            il,
            programInfo;
        var deleteProgram = false;
        for (i = 0, il = _programs.length; i < il; i++) {
          programInfo = _programs[i];
          if (programInfo.program === program) {
            programInfo.usedTimes--;
            if (programInfo.usedTimes === 0) {
              deleteProgram = true;
            }
            break;
          }
        }
        if (deleteProgram === true) {
          var newPrograms = [];
          for (i = 0, il = _programs.length; i < il; i++) {
            programInfo = _programs[i];
            if (programInfo.program !== program) {
              newPrograms.push(programInfo);
            }
          }
          _programs = newPrograms;
          _gl.deleteProgram(program);
          _this.info.memory.programs--;
        }
      };
      function initCustomAttributes(object) {
        var geometry = object.geometry;
        var material = object.material;
        var nvertices = geometry.vertices.length;
        if (material.attributes) {
          if (geometry.__webglCustomAttributesList === undefined) {
            geometry.__webglCustomAttributesList = [];
          }
          for (var name in material.attributes) {
            var attribute = material.attributes[name];
            if (!attribute.__webglInitialized || attribute.createUniqueBuffers) {
              attribute.__webglInitialized = true;
              var size = 1;
              if (attribute.type === 'v2')
                size = 2;
              else if (attribute.type === 'v3')
                size = 3;
              else if (attribute.type === 'v4')
                size = 4;
              else if (attribute.type === 'c')
                size = 3;
              attribute.size = size;
              attribute.array = new Float32Array(nvertices * size);
              attribute.buffer = _gl.createBuffer();
              attribute.buffer.belongsToAttribute = name;
              attribute.needsUpdate = true;
            }
            geometry.__webglCustomAttributesList.push(attribute);
          }
        }
      }
      ;
      function initParticleBuffers(geometry, object) {
        var nvertices = geometry.vertices.length;
        geometry.__vertexArray = new Float32Array(nvertices * 3);
        geometry.__colorArray = new Float32Array(nvertices * 3);
        geometry.__webglParticleCount = nvertices;
        initCustomAttributes(object);
      }
      ;
      function initLineBuffers(geometry, object) {
        var nvertices = geometry.vertices.length;
        geometry.__vertexArray = new Float32Array(nvertices * 3);
        geometry.__colorArray = new Float32Array(nvertices * 3);
        geometry.__lineDistanceArray = new Float32Array(nvertices * 1);
        geometry.__webglLineCount = nvertices;
        initCustomAttributes(object);
      }
      ;
      function initMeshBuffers(geometryGroup, object) {
        var geometry = object.geometry,
            faces3 = geometryGroup.faces3,
            nvertices = faces3.length * 3,
            ntris = faces3.length * 1,
            nlines = faces3.length * 3,
            material = getBufferMaterial(object, geometryGroup);
        geometryGroup.__vertexArray = new Float32Array(nvertices * 3);
        geometryGroup.__normalArray = new Float32Array(nvertices * 3);
        geometryGroup.__colorArray = new Float32Array(nvertices * 3);
        geometryGroup.__uvArray = new Float32Array(nvertices * 2);
        if (geometry.faceVertexUvs.length > 1) {
          geometryGroup.__uv2Array = new Float32Array(nvertices * 2);
        }
        if (geometry.hasTangents) {
          geometryGroup.__tangentArray = new Float32Array(nvertices * 4);
        }
        if (object.geometry.skinWeights.length && object.geometry.skinIndices.length) {
          geometryGroup.__skinIndexArray = new Float32Array(nvertices * 4);
          geometryGroup.__skinWeightArray = new Float32Array(nvertices * 4);
        }
        var UintArray = extensions.get('OES_element_index_uint') !== null && ntris > 21845 ? Uint32Array : Uint16Array;
        geometryGroup.__typeArray = UintArray;
        geometryGroup.__faceArray = new UintArray(ntris * 3);
        geometryGroup.__lineArray = new UintArray(nlines * 2);
        var numMorphTargets = geometryGroup.numMorphTargets;
        if (numMorphTargets) {
          geometryGroup.__morphTargetsArrays = [];
          for (var m = 0,
              ml = numMorphTargets; m < ml; m++) {
            geometryGroup.__morphTargetsArrays.push(new Float32Array(nvertices * 3));
          }
        }
        var numMorphNormals = geometryGroup.numMorphNormals;
        if (numMorphNormals) {
          geometryGroup.__morphNormalsArrays = [];
          for (var m = 0,
              ml = numMorphNormals; m < ml; m++) {
            geometryGroup.__morphNormalsArrays.push(new Float32Array(nvertices * 3));
          }
        }
        geometryGroup.__webglFaceCount = ntris * 3;
        geometryGroup.__webglLineCount = nlines * 2;
        if (material.attributes) {
          if (geometryGroup.__webglCustomAttributesList === undefined) {
            geometryGroup.__webglCustomAttributesList = [];
          }
          for (var name in material.attributes) {
            var originalAttribute = material.attributes[name];
            var attribute = {};
            for (var property in originalAttribute) {
              attribute[property] = originalAttribute[property];
            }
            if (!attribute.__webglInitialized || attribute.createUniqueBuffers) {
              attribute.__webglInitialized = true;
              var size = 1;
              if (attribute.type === 'v2')
                size = 2;
              else if (attribute.type === 'v3')
                size = 3;
              else if (attribute.type === 'v4')
                size = 4;
              else if (attribute.type === 'c')
                size = 3;
              attribute.size = size;
              attribute.array = new Float32Array(nvertices * size);
              attribute.buffer = _gl.createBuffer();
              attribute.buffer.belongsToAttribute = name;
              originalAttribute.needsUpdate = true;
              attribute.__original = originalAttribute;
            }
            geometryGroup.__webglCustomAttributesList.push(attribute);
          }
        }
        geometryGroup.__inittedArrays = true;
      }
      ;
      function getBufferMaterial(object, geometryGroup) {
        return object.material instanceof THREE.MeshFaceMaterial ? object.material.materials[geometryGroup.materialIndex] : object.material;
      }
      function materialNeedsFaceNormals(material) {
        return material instanceof THREE.MeshPhongMaterial === false && material.shading === THREE.FlatShading;
      }
      function setParticleBuffers(geometry, hint, object) {
        var v,
            c,
            vertex,
            offset,
            color,
            vertices = geometry.vertices,
            vl = vertices.length,
            colors = geometry.colors,
            cl = colors.length,
            vertexArray = geometry.__vertexArray,
            colorArray = geometry.__colorArray,
            dirtyVertices = geometry.verticesNeedUpdate,
            dirtyColors = geometry.colorsNeedUpdate,
            customAttributes = geometry.__webglCustomAttributesList,
            i,
            il,
            ca,
            cal,
            value,
            customAttribute;
        if (dirtyVertices) {
          for (v = 0; v < vl; v++) {
            vertex = vertices[v];
            offset = v * 3;
            vertexArray[offset] = vertex.x;
            vertexArray[offset + 1] = vertex.y;
            vertexArray[offset + 2] = vertex.z;
          }
          _gl.bindBuffer(_gl.ARRAY_BUFFER, geometry.__webglVertexBuffer);
          _gl.bufferData(_gl.ARRAY_BUFFER, vertexArray, hint);
        }
        if (dirtyColors) {
          for (c = 0; c < cl; c++) {
            color = colors[c];
            offset = c * 3;
            colorArray[offset] = color.r;
            colorArray[offset + 1] = color.g;
            colorArray[offset + 2] = color.b;
          }
          _gl.bindBuffer(_gl.ARRAY_BUFFER, geometry.__webglColorBuffer);
          _gl.bufferData(_gl.ARRAY_BUFFER, colorArray, hint);
        }
        if (customAttributes) {
          for (i = 0, il = customAttributes.length; i < il; i++) {
            customAttribute = customAttributes[i];
            if (customAttribute.needsUpdate && (customAttribute.boundTo === undefined || customAttribute.boundTo === 'vertices')) {
              cal = customAttribute.value.length;
              offset = 0;
              if (customAttribute.size === 1) {
                for (ca = 0; ca < cal; ca++) {
                  customAttribute.array[ca] = customAttribute.value[ca];
                }
              } else if (customAttribute.size === 2) {
                for (ca = 0; ca < cal; ca++) {
                  value = customAttribute.value[ca];
                  customAttribute.array[offset] = value.x;
                  customAttribute.array[offset + 1] = value.y;
                  offset += 2;
                }
              } else if (customAttribute.size === 3) {
                if (customAttribute.type === 'c') {
                  for (ca = 0; ca < cal; ca++) {
                    value = customAttribute.value[ca];
                    customAttribute.array[offset] = value.r;
                    customAttribute.array[offset + 1] = value.g;
                    customAttribute.array[offset + 2] = value.b;
                    offset += 3;
                  }
                } else {
                  for (ca = 0; ca < cal; ca++) {
                    value = customAttribute.value[ca];
                    customAttribute.array[offset] = value.x;
                    customAttribute.array[offset + 1] = value.y;
                    customAttribute.array[offset + 2] = value.z;
                    offset += 3;
                  }
                }
              } else if (customAttribute.size === 4) {
                for (ca = 0; ca < cal; ca++) {
                  value = customAttribute.value[ca];
                  customAttribute.array[offset] = value.x;
                  customAttribute.array[offset + 1] = value.y;
                  customAttribute.array[offset + 2] = value.z;
                  customAttribute.array[offset + 3] = value.w;
                  offset += 4;
                }
              }
            }
            _gl.bindBuffer(_gl.ARRAY_BUFFER, customAttribute.buffer);
            _gl.bufferData(_gl.ARRAY_BUFFER, customAttribute.array, hint);
            customAttribute.needsUpdate = false;
          }
        }
      }
      function setLineBuffers(geometry, hint) {
        var v,
            c,
            d,
            vertex,
            offset,
            color,
            vertices = geometry.vertices,
            colors = geometry.colors,
            lineDistances = geometry.lineDistances,
            vl = vertices.length,
            cl = colors.length,
            dl = lineDistances.length,
            vertexArray = geometry.__vertexArray,
            colorArray = geometry.__colorArray,
            lineDistanceArray = geometry.__lineDistanceArray,
            dirtyVertices = geometry.verticesNeedUpdate,
            dirtyColors = geometry.colorsNeedUpdate,
            dirtyLineDistances = geometry.lineDistancesNeedUpdate,
            customAttributes = geometry.__webglCustomAttributesList,
            i,
            il,
            ca,
            cal,
            value,
            customAttribute;
        if (dirtyVertices) {
          for (v = 0; v < vl; v++) {
            vertex = vertices[v];
            offset = v * 3;
            vertexArray[offset] = vertex.x;
            vertexArray[offset + 1] = vertex.y;
            vertexArray[offset + 2] = vertex.z;
          }
          _gl.bindBuffer(_gl.ARRAY_BUFFER, geometry.__webglVertexBuffer);
          _gl.bufferData(_gl.ARRAY_BUFFER, vertexArray, hint);
        }
        if (dirtyColors) {
          for (c = 0; c < cl; c++) {
            color = colors[c];
            offset = c * 3;
            colorArray[offset] = color.r;
            colorArray[offset + 1] = color.g;
            colorArray[offset + 2] = color.b;
          }
          _gl.bindBuffer(_gl.ARRAY_BUFFER, geometry.__webglColorBuffer);
          _gl.bufferData(_gl.ARRAY_BUFFER, colorArray, hint);
        }
        if (dirtyLineDistances) {
          for (d = 0; d < dl; d++) {
            lineDistanceArray[d] = lineDistances[d];
          }
          _gl.bindBuffer(_gl.ARRAY_BUFFER, geometry.__webglLineDistanceBuffer);
          _gl.bufferData(_gl.ARRAY_BUFFER, lineDistanceArray, hint);
        }
        if (customAttributes) {
          for (i = 0, il = customAttributes.length; i < il; i++) {
            customAttribute = customAttributes[i];
            if (customAttribute.needsUpdate && (customAttribute.boundTo === undefined || customAttribute.boundTo === 'vertices')) {
              offset = 0;
              cal = customAttribute.value.length;
              if (customAttribute.size === 1) {
                for (ca = 0; ca < cal; ca++) {
                  customAttribute.array[ca] = customAttribute.value[ca];
                }
              } else if (customAttribute.size === 2) {
                for (ca = 0; ca < cal; ca++) {
                  value = customAttribute.value[ca];
                  customAttribute.array[offset] = value.x;
                  customAttribute.array[offset + 1] = value.y;
                  offset += 2;
                }
              } else if (customAttribute.size === 3) {
                if (customAttribute.type === 'c') {
                  for (ca = 0; ca < cal; ca++) {
                    value = customAttribute.value[ca];
                    customAttribute.array[offset] = value.r;
                    customAttribute.array[offset + 1] = value.g;
                    customAttribute.array[offset + 2] = value.b;
                    offset += 3;
                  }
                } else {
                  for (ca = 0; ca < cal; ca++) {
                    value = customAttribute.value[ca];
                    customAttribute.array[offset] = value.x;
                    customAttribute.array[offset + 1] = value.y;
                    customAttribute.array[offset + 2] = value.z;
                    offset += 3;
                  }
                }
              } else if (customAttribute.size === 4) {
                for (ca = 0; ca < cal; ca++) {
                  value = customAttribute.value[ca];
                  customAttribute.array[offset] = value.x;
                  customAttribute.array[offset + 1] = value.y;
                  customAttribute.array[offset + 2] = value.z;
                  customAttribute.array[offset + 3] = value.w;
                  offset += 4;
                }
              }
              _gl.bindBuffer(_gl.ARRAY_BUFFER, customAttribute.buffer);
              _gl.bufferData(_gl.ARRAY_BUFFER, customAttribute.array, hint);
              customAttribute.needsUpdate = false;
            }
          }
        }
      }
      function setMeshBuffers(geometryGroup, object, hint, dispose, material) {
        if (!geometryGroup.__inittedArrays) {
          return ;
        }
        var needsFaceNormals = materialNeedsFaceNormals(material);
        var f,
            fl,
            fi,
            face,
            vertexNormals,
            faceNormal,
            vertexColors,
            faceColor,
            vertexTangents,
            uv,
            uv2,
            v1,
            v2,
            v3,
            t1,
            t2,
            t3,
            n1,
            n2,
            n3,
            c1,
            c2,
            c3,
            sw1,
            sw2,
            sw3,
            si1,
            si2,
            si3,
            i,
            il,
            vn,
            uvi,
            uv2i,
            vk,
            vkl,
            vka,
            nka,
            chf,
            faceVertexNormals,
            vertexIndex = 0,
            offset = 0,
            offset_uv = 0,
            offset_uv2 = 0,
            offset_face = 0,
            offset_normal = 0,
            offset_tangent = 0,
            offset_line = 0,
            offset_color = 0,
            offset_skin = 0,
            offset_morphTarget = 0,
            offset_custom = 0,
            value,
            vertexArray = geometryGroup.__vertexArray,
            uvArray = geometryGroup.__uvArray,
            uv2Array = geometryGroup.__uv2Array,
            normalArray = geometryGroup.__normalArray,
            tangentArray = geometryGroup.__tangentArray,
            colorArray = geometryGroup.__colorArray,
            skinIndexArray = geometryGroup.__skinIndexArray,
            skinWeightArray = geometryGroup.__skinWeightArray,
            morphTargetsArrays = geometryGroup.__morphTargetsArrays,
            morphNormalsArrays = geometryGroup.__morphNormalsArrays,
            customAttributes = geometryGroup.__webglCustomAttributesList,
            customAttribute,
            faceArray = geometryGroup.__faceArray,
            lineArray = geometryGroup.__lineArray,
            geometry = object.geometry,
            dirtyVertices = geometry.verticesNeedUpdate,
            dirtyElements = geometry.elementsNeedUpdate,
            dirtyUvs = geometry.uvsNeedUpdate,
            dirtyNormals = geometry.normalsNeedUpdate,
            dirtyTangents = geometry.tangentsNeedUpdate,
            dirtyColors = geometry.colorsNeedUpdate,
            dirtyMorphTargets = geometry.morphTargetsNeedUpdate,
            vertices = geometry.vertices,
            chunk_faces3 = geometryGroup.faces3,
            obj_faces = geometry.faces,
            obj_uvs = geometry.faceVertexUvs[0],
            obj_uvs2 = geometry.faceVertexUvs[1],
            obj_skinIndices = geometry.skinIndices,
            obj_skinWeights = geometry.skinWeights,
            morphTargets = geometry.morphTargets,
            morphNormals = geometry.morphNormals;
        if (dirtyVertices) {
          for (f = 0, fl = chunk_faces3.length; f < fl; f++) {
            face = obj_faces[chunk_faces3[f]];
            v1 = vertices[face.a];
            v2 = vertices[face.b];
            v3 = vertices[face.c];
            vertexArray[offset] = v1.x;
            vertexArray[offset + 1] = v1.y;
            vertexArray[offset + 2] = v1.z;
            vertexArray[offset + 3] = v2.x;
            vertexArray[offset + 4] = v2.y;
            vertexArray[offset + 5] = v2.z;
            vertexArray[offset + 6] = v3.x;
            vertexArray[offset + 7] = v3.y;
            vertexArray[offset + 8] = v3.z;
            offset += 9;
          }
          _gl.bindBuffer(_gl.ARRAY_BUFFER, geometryGroup.__webglVertexBuffer);
          _gl.bufferData(_gl.ARRAY_BUFFER, vertexArray, hint);
        }
        if (dirtyMorphTargets) {
          for (vk = 0, vkl = morphTargets.length; vk < vkl; vk++) {
            offset_morphTarget = 0;
            for (f = 0, fl = chunk_faces3.length; f < fl; f++) {
              chf = chunk_faces3[f];
              face = obj_faces[chf];
              v1 = morphTargets[vk].vertices[face.a];
              v2 = morphTargets[vk].vertices[face.b];
              v3 = morphTargets[vk].vertices[face.c];
              vka = morphTargetsArrays[vk];
              vka[offset_morphTarget] = v1.x;
              vka[offset_morphTarget + 1] = v1.y;
              vka[offset_morphTarget + 2] = v1.z;
              vka[offset_morphTarget + 3] = v2.x;
              vka[offset_morphTarget + 4] = v2.y;
              vka[offset_morphTarget + 5] = v2.z;
              vka[offset_morphTarget + 6] = v3.x;
              vka[offset_morphTarget + 7] = v3.y;
              vka[offset_morphTarget + 8] = v3.z;
              if (material.morphNormals) {
                if (needsFaceNormals) {
                  n1 = morphNormals[vk].faceNormals[chf];
                  n2 = n1;
                  n3 = n1;
                } else {
                  faceVertexNormals = morphNormals[vk].vertexNormals[chf];
                  n1 = faceVertexNormals.a;
                  n2 = faceVertexNormals.b;
                  n3 = faceVertexNormals.c;
                }
                nka = morphNormalsArrays[vk];
                nka[offset_morphTarget] = n1.x;
                nka[offset_morphTarget + 1] = n1.y;
                nka[offset_morphTarget + 2] = n1.z;
                nka[offset_morphTarget + 3] = n2.x;
                nka[offset_morphTarget + 4] = n2.y;
                nka[offset_morphTarget + 5] = n2.z;
                nka[offset_morphTarget + 6] = n3.x;
                nka[offset_morphTarget + 7] = n3.y;
                nka[offset_morphTarget + 8] = n3.z;
              }
              offset_morphTarget += 9;
            }
            _gl.bindBuffer(_gl.ARRAY_BUFFER, geometryGroup.__webglMorphTargetsBuffers[vk]);
            _gl.bufferData(_gl.ARRAY_BUFFER, morphTargetsArrays[vk], hint);
            if (material.morphNormals) {
              _gl.bindBuffer(_gl.ARRAY_BUFFER, geometryGroup.__webglMorphNormalsBuffers[vk]);
              _gl.bufferData(_gl.ARRAY_BUFFER, morphNormalsArrays[vk], hint);
            }
          }
        }
        if (obj_skinWeights.length) {
          for (f = 0, fl = chunk_faces3.length; f < fl; f++) {
            face = obj_faces[chunk_faces3[f]];
            sw1 = obj_skinWeights[face.a];
            sw2 = obj_skinWeights[face.b];
            sw3 = obj_skinWeights[face.c];
            skinWeightArray[offset_skin] = sw1.x;
            skinWeightArray[offset_skin + 1] = sw1.y;
            skinWeightArray[offset_skin + 2] = sw1.z;
            skinWeightArray[offset_skin + 3] = sw1.w;
            skinWeightArray[offset_skin + 4] = sw2.x;
            skinWeightArray[offset_skin + 5] = sw2.y;
            skinWeightArray[offset_skin + 6] = sw2.z;
            skinWeightArray[offset_skin + 7] = sw2.w;
            skinWeightArray[offset_skin + 8] = sw3.x;
            skinWeightArray[offset_skin + 9] = sw3.y;
            skinWeightArray[offset_skin + 10] = sw3.z;
            skinWeightArray[offset_skin + 11] = sw3.w;
            si1 = obj_skinIndices[face.a];
            si2 = obj_skinIndices[face.b];
            si3 = obj_skinIndices[face.c];
            skinIndexArray[offset_skin] = si1.x;
            skinIndexArray[offset_skin + 1] = si1.y;
            skinIndexArray[offset_skin + 2] = si1.z;
            skinIndexArray[offset_skin + 3] = si1.w;
            skinIndexArray[offset_skin + 4] = si2.x;
            skinIndexArray[offset_skin + 5] = si2.y;
            skinIndexArray[offset_skin + 6] = si2.z;
            skinIndexArray[offset_skin + 7] = si2.w;
            skinIndexArray[offset_skin + 8] = si3.x;
            skinIndexArray[offset_skin + 9] = si3.y;
            skinIndexArray[offset_skin + 10] = si3.z;
            skinIndexArray[offset_skin + 11] = si3.w;
            offset_skin += 12;
          }
          if (offset_skin > 0) {
            _gl.bindBuffer(_gl.ARRAY_BUFFER, geometryGroup.__webglSkinIndicesBuffer);
            _gl.bufferData(_gl.ARRAY_BUFFER, skinIndexArray, hint);
            _gl.bindBuffer(_gl.ARRAY_BUFFER, geometryGroup.__webglSkinWeightsBuffer);
            _gl.bufferData(_gl.ARRAY_BUFFER, skinWeightArray, hint);
          }
        }
        if (dirtyColors) {
          for (f = 0, fl = chunk_faces3.length; f < fl; f++) {
            face = obj_faces[chunk_faces3[f]];
            vertexColors = face.vertexColors;
            faceColor = face.color;
            if (vertexColors.length === 3 && material.vertexColors === THREE.VertexColors) {
              c1 = vertexColors[0];
              c2 = vertexColors[1];
              c3 = vertexColors[2];
            } else {
              c1 = faceColor;
              c2 = faceColor;
              c3 = faceColor;
            }
            colorArray[offset_color] = c1.r;
            colorArray[offset_color + 1] = c1.g;
            colorArray[offset_color + 2] = c1.b;
            colorArray[offset_color + 3] = c2.r;
            colorArray[offset_color + 4] = c2.g;
            colorArray[offset_color + 5] = c2.b;
            colorArray[offset_color + 6] = c3.r;
            colorArray[offset_color + 7] = c3.g;
            colorArray[offset_color + 8] = c3.b;
            offset_color += 9;
          }
          if (offset_color > 0) {
            _gl.bindBuffer(_gl.ARRAY_BUFFER, geometryGroup.__webglColorBuffer);
            _gl.bufferData(_gl.ARRAY_BUFFER, colorArray, hint);
          }
        }
        if (dirtyTangents && geometry.hasTangents) {
          for (f = 0, fl = chunk_faces3.length; f < fl; f++) {
            face = obj_faces[chunk_faces3[f]];
            vertexTangents = face.vertexTangents;
            t1 = vertexTangents[0];
            t2 = vertexTangents[1];
            t3 = vertexTangents[2];
            tangentArray[offset_tangent] = t1.x;
            tangentArray[offset_tangent + 1] = t1.y;
            tangentArray[offset_tangent + 2] = t1.z;
            tangentArray[offset_tangent + 3] = t1.w;
            tangentArray[offset_tangent + 4] = t2.x;
            tangentArray[offset_tangent + 5] = t2.y;
            tangentArray[offset_tangent + 6] = t2.z;
            tangentArray[offset_tangent + 7] = t2.w;
            tangentArray[offset_tangent + 8] = t3.x;
            tangentArray[offset_tangent + 9] = t3.y;
            tangentArray[offset_tangent + 10] = t3.z;
            tangentArray[offset_tangent + 11] = t3.w;
            offset_tangent += 12;
          }
          _gl.bindBuffer(_gl.ARRAY_BUFFER, geometryGroup.__webglTangentBuffer);
          _gl.bufferData(_gl.ARRAY_BUFFER, tangentArray, hint);
        }
        if (dirtyNormals) {
          for (f = 0, fl = chunk_faces3.length; f < fl; f++) {
            face = obj_faces[chunk_faces3[f]];
            vertexNormals = face.vertexNormals;
            faceNormal = face.normal;
            if (vertexNormals.length === 3 && needsFaceNormals === false) {
              for (i = 0; i < 3; i++) {
                vn = vertexNormals[i];
                normalArray[offset_normal] = vn.x;
                normalArray[offset_normal + 1] = vn.y;
                normalArray[offset_normal + 2] = vn.z;
                offset_normal += 3;
              }
            } else {
              for (i = 0; i < 3; i++) {
                normalArray[offset_normal] = faceNormal.x;
                normalArray[offset_normal + 1] = faceNormal.y;
                normalArray[offset_normal + 2] = faceNormal.z;
                offset_normal += 3;
              }
            }
          }
          _gl.bindBuffer(_gl.ARRAY_BUFFER, geometryGroup.__webglNormalBuffer);
          _gl.bufferData(_gl.ARRAY_BUFFER, normalArray, hint);
        }
        if (dirtyUvs && obj_uvs) {
          for (f = 0, fl = chunk_faces3.length; f < fl; f++) {
            fi = chunk_faces3[f];
            uv = obj_uvs[fi];
            if (uv === undefined)
              continue;
            for (i = 0; i < 3; i++) {
              uvi = uv[i];
              uvArray[offset_uv] = uvi.x;
              uvArray[offset_uv + 1] = uvi.y;
              offset_uv += 2;
            }
          }
          if (offset_uv > 0) {
            _gl.bindBuffer(_gl.ARRAY_BUFFER, geometryGroup.__webglUVBuffer);
            _gl.bufferData(_gl.ARRAY_BUFFER, uvArray, hint);
          }
        }
        if (dirtyUvs && obj_uvs2) {
          for (f = 0, fl = chunk_faces3.length; f < fl; f++) {
            fi = chunk_faces3[f];
            uv2 = obj_uvs2[fi];
            if (uv2 === undefined)
              continue;
            for (i = 0; i < 3; i++) {
              uv2i = uv2[i];
              uv2Array[offset_uv2] = uv2i.x;
              uv2Array[offset_uv2 + 1] = uv2i.y;
              offset_uv2 += 2;
            }
          }
          if (offset_uv2 > 0) {
            _gl.bindBuffer(_gl.ARRAY_BUFFER, geometryGroup.__webglUV2Buffer);
            _gl.bufferData(_gl.ARRAY_BUFFER, uv2Array, hint);
          }
        }
        if (dirtyElements) {
          for (f = 0, fl = chunk_faces3.length; f < fl; f++) {
            faceArray[offset_face] = vertexIndex;
            faceArray[offset_face + 1] = vertexIndex + 1;
            faceArray[offset_face + 2] = vertexIndex + 2;
            offset_face += 3;
            lineArray[offset_line] = vertexIndex;
            lineArray[offset_line + 1] = vertexIndex + 1;
            lineArray[offset_line + 2] = vertexIndex;
            lineArray[offset_line + 3] = vertexIndex + 2;
            lineArray[offset_line + 4] = vertexIndex + 1;
            lineArray[offset_line + 5] = vertexIndex + 2;
            offset_line += 6;
            vertexIndex += 3;
          }
          _gl.bindBuffer(_gl.ELEMENT_ARRAY_BUFFER, geometryGroup.__webglFaceBuffer);
          _gl.bufferData(_gl.ELEMENT_ARRAY_BUFFER, faceArray, hint);
          _gl.bindBuffer(_gl.ELEMENT_ARRAY_BUFFER, geometryGroup.__webglLineBuffer);
          _gl.bufferData(_gl.ELEMENT_ARRAY_BUFFER, lineArray, hint);
        }
        if (customAttributes) {
          for (i = 0, il = customAttributes.length; i < il; i++) {
            customAttribute = customAttributes[i];
            if (!customAttribute.__original.needsUpdate)
              continue;
            offset_custom = 0;
            if (customAttribute.size === 1) {
              if (customAttribute.boundTo === undefined || customAttribute.boundTo === 'vertices') {
                for (f = 0, fl = chunk_faces3.length; f < fl; f++) {
                  face = obj_faces[chunk_faces3[f]];
                  customAttribute.array[offset_custom] = customAttribute.value[face.a];
                  customAttribute.array[offset_custom + 1] = customAttribute.value[face.b];
                  customAttribute.array[offset_custom + 2] = customAttribute.value[face.c];
                  offset_custom += 3;
                }
              } else if (customAttribute.boundTo === 'faces') {
                for (f = 0, fl = chunk_faces3.length; f < fl; f++) {
                  value = customAttribute.value[chunk_faces3[f]];
                  customAttribute.array[offset_custom] = value;
                  customAttribute.array[offset_custom + 1] = value;
                  customAttribute.array[offset_custom + 2] = value;
                  offset_custom += 3;
                }
              }
            } else if (customAttribute.size === 2) {
              if (customAttribute.boundTo === undefined || customAttribute.boundTo === 'vertices') {
                for (f = 0, fl = chunk_faces3.length; f < fl; f++) {
                  face = obj_faces[chunk_faces3[f]];
                  v1 = customAttribute.value[face.a];
                  v2 = customAttribute.value[face.b];
                  v3 = customAttribute.value[face.c];
                  customAttribute.array[offset_custom] = v1.x;
                  customAttribute.array[offset_custom + 1] = v1.y;
                  customAttribute.array[offset_custom + 2] = v2.x;
                  customAttribute.array[offset_custom + 3] = v2.y;
                  customAttribute.array[offset_custom + 4] = v3.x;
                  customAttribute.array[offset_custom + 5] = v3.y;
                  offset_custom += 6;
                }
              } else if (customAttribute.boundTo === 'faces') {
                for (f = 0, fl = chunk_faces3.length; f < fl; f++) {
                  value = customAttribute.value[chunk_faces3[f]];
                  v1 = value;
                  v2 = value;
                  v3 = value;
                  customAttribute.array[offset_custom] = v1.x;
                  customAttribute.array[offset_custom + 1] = v1.y;
                  customAttribute.array[offset_custom + 2] = v2.x;
                  customAttribute.array[offset_custom + 3] = v2.y;
                  customAttribute.array[offset_custom + 4] = v3.x;
                  customAttribute.array[offset_custom + 5] = v3.y;
                  offset_custom += 6;
                }
              }
            } else if (customAttribute.size === 3) {
              var pp;
              if (customAttribute.type === 'c') {
                pp = ['r', 'g', 'b'];
              } else {
                pp = ['x', 'y', 'z'];
              }
              if (customAttribute.boundTo === undefined || customAttribute.boundTo === 'vertices') {
                for (f = 0, fl = chunk_faces3.length; f < fl; f++) {
                  face = obj_faces[chunk_faces3[f]];
                  v1 = customAttribute.value[face.a];
                  v2 = customAttribute.value[face.b];
                  v3 = customAttribute.value[face.c];
                  customAttribute.array[offset_custom] = v1[pp[0]];
                  customAttribute.array[offset_custom + 1] = v1[pp[1]];
                  customAttribute.array[offset_custom + 2] = v1[pp[2]];
                  customAttribute.array[offset_custom + 3] = v2[pp[0]];
                  customAttribute.array[offset_custom + 4] = v2[pp[1]];
                  customAttribute.array[offset_custom + 5] = v2[pp[2]];
                  customAttribute.array[offset_custom + 6] = v3[pp[0]];
                  customAttribute.array[offset_custom + 7] = v3[pp[1]];
                  customAttribute.array[offset_custom + 8] = v3[pp[2]];
                  offset_custom += 9;
                }
              } else if (customAttribute.boundTo === 'faces') {
                for (f = 0, fl = chunk_faces3.length; f < fl; f++) {
                  value = customAttribute.value[chunk_faces3[f]];
                  v1 = value;
                  v2 = value;
                  v3 = value;
                  customAttribute.array[offset_custom] = v1[pp[0]];
                  customAttribute.array[offset_custom + 1] = v1[pp[1]];
                  customAttribute.array[offset_custom + 2] = v1[pp[2]];
                  customAttribute.array[offset_custom + 3] = v2[pp[0]];
                  customAttribute.array[offset_custom + 4] = v2[pp[1]];
                  customAttribute.array[offset_custom + 5] = v2[pp[2]];
                  customAttribute.array[offset_custom + 6] = v3[pp[0]];
                  customAttribute.array[offset_custom + 7] = v3[pp[1]];
                  customAttribute.array[offset_custom + 8] = v3[pp[2]];
                  offset_custom += 9;
                }
              } else if (customAttribute.boundTo === 'faceVertices') {
                for (f = 0, fl = chunk_faces3.length; f < fl; f++) {
                  value = customAttribute.value[chunk_faces3[f]];
                  v1 = value[0];
                  v2 = value[1];
                  v3 = value[2];
                  customAttribute.array[offset_custom] = v1[pp[0]];
                  customAttribute.array[offset_custom + 1] = v1[pp[1]];
                  customAttribute.array[offset_custom + 2] = v1[pp[2]];
                  customAttribute.array[offset_custom + 3] = v2[pp[0]];
                  customAttribute.array[offset_custom + 4] = v2[pp[1]];
                  customAttribute.array[offset_custom + 5] = v2[pp[2]];
                  customAttribute.array[offset_custom + 6] = v3[pp[0]];
                  customAttribute.array[offset_custom + 7] = v3[pp[1]];
                  customAttribute.array[offset_custom + 8] = v3[pp[2]];
                  offset_custom += 9;
                }
              }
            } else if (customAttribute.size === 4) {
              if (customAttribute.boundTo === undefined || customAttribute.boundTo === 'vertices') {
                for (f = 0, fl = chunk_faces3.length; f < fl; f++) {
                  face = obj_faces[chunk_faces3[f]];
                  v1 = customAttribute.value[face.a];
                  v2 = customAttribute.value[face.b];
                  v3 = customAttribute.value[face.c];
                  customAttribute.array[offset_custom] = v1.x;
                  customAttribute.array[offset_custom + 1] = v1.y;
                  customAttribute.array[offset_custom + 2] = v1.z;
                  customAttribute.array[offset_custom + 3] = v1.w;
                  customAttribute.array[offset_custom + 4] = v2.x;
                  customAttribute.array[offset_custom + 5] = v2.y;
                  customAttribute.array[offset_custom + 6] = v2.z;
                  customAttribute.array[offset_custom + 7] = v2.w;
                  customAttribute.array[offset_custom + 8] = v3.x;
                  customAttribute.array[offset_custom + 9] = v3.y;
                  customAttribute.array[offset_custom + 10] = v3.z;
                  customAttribute.array[offset_custom + 11] = v3.w;
                  offset_custom += 12;
                }
              } else if (customAttribute.boundTo === 'faces') {
                for (f = 0, fl = chunk_faces3.length; f < fl; f++) {
                  value = customAttribute.value[chunk_faces3[f]];
                  v1 = value;
                  v2 = value;
                  v3 = value;
                  customAttribute.array[offset_custom] = v1.x;
                  customAttribute.array[offset_custom + 1] = v1.y;
                  customAttribute.array[offset_custom + 2] = v1.z;
                  customAttribute.array[offset_custom + 3] = v1.w;
                  customAttribute.array[offset_custom + 4] = v2.x;
                  customAttribute.array[offset_custom + 5] = v2.y;
                  customAttribute.array[offset_custom + 6] = v2.z;
                  customAttribute.array[offset_custom + 7] = v2.w;
                  customAttribute.array[offset_custom + 8] = v3.x;
                  customAttribute.array[offset_custom + 9] = v3.y;
                  customAttribute.array[offset_custom + 10] = v3.z;
                  customAttribute.array[offset_custom + 11] = v3.w;
                  offset_custom += 12;
                }
              } else if (customAttribute.boundTo === 'faceVertices') {
                for (f = 0, fl = chunk_faces3.length; f < fl; f++) {
                  value = customAttribute.value[chunk_faces3[f]];
                  v1 = value[0];
                  v2 = value[1];
                  v3 = value[2];
                  customAttribute.array[offset_custom] = v1.x;
                  customAttribute.array[offset_custom + 1] = v1.y;
                  customAttribute.array[offset_custom + 2] = v1.z;
                  customAttribute.array[offset_custom + 3] = v1.w;
                  customAttribute.array[offset_custom + 4] = v2.x;
                  customAttribute.array[offset_custom + 5] = v2.y;
                  customAttribute.array[offset_custom + 6] = v2.z;
                  customAttribute.array[offset_custom + 7] = v2.w;
                  customAttribute.array[offset_custom + 8] = v3.x;
                  customAttribute.array[offset_custom + 9] = v3.y;
                  customAttribute.array[offset_custom + 10] = v3.z;
                  customAttribute.array[offset_custom + 11] = v3.w;
                  offset_custom += 12;
                }
              }
            }
            _gl.bindBuffer(_gl.ARRAY_BUFFER, customAttribute.buffer);
            _gl.bufferData(_gl.ARRAY_BUFFER, customAttribute.array, hint);
          }
        }
        if (dispose) {
          delete geometryGroup.__inittedArrays;
          delete geometryGroup.__colorArray;
          delete geometryGroup.__normalArray;
          delete geometryGroup.__tangentArray;
          delete geometryGroup.__uvArray;
          delete geometryGroup.__uv2Array;
          delete geometryGroup.__faceArray;
          delete geometryGroup.__vertexArray;
          delete geometryGroup.__lineArray;
          delete geometryGroup.__skinIndexArray;
          delete geometryGroup.__skinWeightArray;
        }
      }
      ;
      this.renderBufferImmediate = function(object, program, material) {
        state.initAttributes();
        if (object.hasPositions && !object.__webglVertexBuffer)
          object.__webglVertexBuffer = _gl.createBuffer();
        if (object.hasNormals && !object.__webglNormalBuffer)
          object.__webglNormalBuffer = _gl.createBuffer();
        if (object.hasUvs && !object.__webglUvBuffer)
          object.__webglUvBuffer = _gl.createBuffer();
        if (object.hasColors && !object.__webglColorBuffer)
          object.__webglColorBuffer = _gl.createBuffer();
        if (object.hasPositions) {
          _gl.bindBuffer(_gl.ARRAY_BUFFER, object.__webglVertexBuffer);
          _gl.bufferData(_gl.ARRAY_BUFFER, object.positionArray, _gl.DYNAMIC_DRAW);
          state.enableAttribute(program.attributes.position);
          _gl.vertexAttribPointer(program.attributes.position, 3, _gl.FLOAT, false, 0, 0);
        }
        if (object.hasNormals) {
          _gl.bindBuffer(_gl.ARRAY_BUFFER, object.__webglNormalBuffer);
          if (material instanceof THREE.MeshPhongMaterial === false && material.shading === THREE.FlatShading) {
            var nx,
                ny,
                nz,
                nax,
                nbx,
                ncx,
                nay,
                nby,
                ncy,
                naz,
                nbz,
                ncz,
                normalArray,
                i,
                il = object.count * 3;
            for (i = 0; i < il; i += 9) {
              normalArray = object.normalArray;
              nax = normalArray[i];
              nay = normalArray[i + 1];
              naz = normalArray[i + 2];
              nbx = normalArray[i + 3];
              nby = normalArray[i + 4];
              nbz = normalArray[i + 5];
              ncx = normalArray[i + 6];
              ncy = normalArray[i + 7];
              ncz = normalArray[i + 8];
              nx = (nax + nbx + ncx) / 3;
              ny = (nay + nby + ncy) / 3;
              nz = (naz + nbz + ncz) / 3;
              normalArray[i] = nx;
              normalArray[i + 1] = ny;
              normalArray[i + 2] = nz;
              normalArray[i + 3] = nx;
              normalArray[i + 4] = ny;
              normalArray[i + 5] = nz;
              normalArray[i + 6] = nx;
              normalArray[i + 7] = ny;
              normalArray[i + 8] = nz;
            }
          }
          _gl.bufferData(_gl.ARRAY_BUFFER, object.normalArray, _gl.DYNAMIC_DRAW);
          state.enableAttribute(program.attributes.normal);
          _gl.vertexAttribPointer(program.attributes.normal, 3, _gl.FLOAT, false, 0, 0);
        }
        if (object.hasUvs && material.map) {
          _gl.bindBuffer(_gl.ARRAY_BUFFER, object.__webglUvBuffer);
          _gl.bufferData(_gl.ARRAY_BUFFER, object.uvArray, _gl.DYNAMIC_DRAW);
          state.enableAttribute(program.attributes.uv);
          _gl.vertexAttribPointer(program.attributes.uv, 2, _gl.FLOAT, false, 0, 0);
        }
        if (object.hasColors && material.vertexColors !== THREE.NoColors) {
          _gl.bindBuffer(_gl.ARRAY_BUFFER, object.__webglColorBuffer);
          _gl.bufferData(_gl.ARRAY_BUFFER, object.colorArray, _gl.DYNAMIC_DRAW);
          state.enableAttribute(program.attributes.color);
          _gl.vertexAttribPointer(program.attributes.color, 3, _gl.FLOAT, false, 0, 0);
        }
        state.disableUnusedAttributes();
        _gl.drawArrays(_gl.TRIANGLES, 0, object.count);
        object.count = 0;
      };
      function setupVertexAttributes(material, program, geometry, startIndex) {
        var geometryAttributes = geometry.attributes;
        var programAttributes = program.attributes;
        var programAttributesKeys = program.attributesKeys;
        for (var i = 0,
            l = programAttributesKeys.length; i < l; i++) {
          var key = programAttributesKeys[i];
          var programAttribute = programAttributes[key];
          if (programAttribute >= 0) {
            var geometryAttribute = geometryAttributes[key];
            if (geometryAttribute !== undefined) {
              var size = geometryAttribute.itemSize;
              _gl.bindBuffer(_gl.ARRAY_BUFFER, geometryAttribute.buffer);
              state.enableAttribute(programAttribute);
              _gl.vertexAttribPointer(programAttribute, size, _gl.FLOAT, false, 0, startIndex * size * 4);
            } else if (material.defaultAttributeValues !== undefined) {
              if (material.defaultAttributeValues[key].length === 2) {
                _gl.vertexAttrib2fv(programAttribute, material.defaultAttributeValues[key]);
              } else if (material.defaultAttributeValues[key].length === 3) {
                _gl.vertexAttrib3fv(programAttribute, material.defaultAttributeValues[key]);
              }
            }
          }
        }
        state.disableUnusedAttributes();
      }
      this.renderBufferDirect = function(camera, lights, fog, material, geometry, object) {
        if (material.visible === false)
          return ;
        updateObject(object);
        var program = setProgram(camera, lights, fog, material, object);
        var updateBuffers = false,
            wireframeBit = material.wireframe ? 1 : 0,
            geometryProgram = 'direct_' + geometry.id + '_' + program.id + '_' + wireframeBit;
        if (geometryProgram !== _currentGeometryProgram) {
          _currentGeometryProgram = geometryProgram;
          updateBuffers = true;
        }
        if (updateBuffers) {
          state.initAttributes();
        }
        if (object instanceof THREE.Mesh) {
          var mode = material.wireframe === true ? _gl.LINES : _gl.TRIANGLES;
          var index = geometry.attributes.index;
          if (index) {
            var type,
                size;
            if (index.array instanceof Uint32Array && extensions.get('OES_element_index_uint')) {
              type = _gl.UNSIGNED_INT;
              size = 4;
            } else {
              type = _gl.UNSIGNED_SHORT;
              size = 2;
            }
            var offsets = geometry.offsets;
            if (offsets.length === 0) {
              if (updateBuffers) {
                setupVertexAttributes(material, program, geometry, 0);
                _gl.bindBuffer(_gl.ELEMENT_ARRAY_BUFFER, index.buffer);
              }
              _gl.drawElements(mode, index.array.length, type, 0);
              _this.info.render.calls++;
              _this.info.render.vertices += index.array.length;
              _this.info.render.faces += index.array.length / 3;
            } else {
              updateBuffers = true;
              for (var i = 0,
                  il = offsets.length; i < il; i++) {
                var startIndex = offsets[i].index;
                if (updateBuffers) {
                  setupVertexAttributes(material, program, geometry, startIndex);
                  _gl.bindBuffer(_gl.ELEMENT_ARRAY_BUFFER, index.buffer);
                }
                _gl.drawElements(mode, offsets[i].count, type, offsets[i].start * size);
                _this.info.render.calls++;
                _this.info.render.vertices += offsets[i].count;
                _this.info.render.faces += offsets[i].count / 3;
              }
            }
          } else {
            if (updateBuffers) {
              setupVertexAttributes(material, program, geometry, 0);
            }
            var position = geometry.attributes['position'];
            _gl.drawArrays(mode, 0, position.array.length / position.itemSize);
            _this.info.render.calls++;
            _this.info.render.vertices += position.array.length / position.itemSize;
            _this.info.render.faces += position.array.length / (3 * position.itemSize);
          }
        } else if (object instanceof THREE.PointCloud) {
          var mode = _gl.POINTS;
          var index = geometry.attributes.index;
          if (index) {
            var type,
                size;
            if (index.array instanceof Uint32Array && extensions.get('OES_element_index_uint')) {
              type = _gl.UNSIGNED_INT;
              size = 4;
            } else {
              type = _gl.UNSIGNED_SHORT;
              size = 2;
            }
            var offsets = geometry.offsets;
            if (offsets.length === 0) {
              if (updateBuffers) {
                setupVertexAttributes(material, program, geometry, 0);
                _gl.bindBuffer(_gl.ELEMENT_ARRAY_BUFFER, index.buffer);
              }
              _gl.drawElements(mode, index.array.length, type, 0);
              _this.info.render.calls++;
              _this.info.render.points += index.array.length;
            } else {
              if (offsets.length > 1)
                updateBuffers = true;
              for (var i = 0,
                  il = offsets.length; i < il; i++) {
                var startIndex = offsets[i].index;
                if (updateBuffers) {
                  setupVertexAttributes(material, program, geometry, startIndex);
                  _gl.bindBuffer(_gl.ELEMENT_ARRAY_BUFFER, index.buffer);
                }
                _gl.drawElements(mode, offsets[i].count, type, offsets[i].start * size);
                _this.info.render.calls++;
                _this.info.render.points += offsets[i].count;
              }
            }
          } else {
            if (updateBuffers) {
              setupVertexAttributes(material, program, geometry, 0);
            }
            var position = geometry.attributes.position;
            var offsets = geometry.offsets;
            if (offsets.length === 0) {
              _gl.drawArrays(mode, 0, position.array.length / 3);
              _this.info.render.calls++;
              _this.info.render.points += position.array.length / 3;
            } else {
              for (var i = 0,
                  il = offsets.length; i < il; i++) {
                _gl.drawArrays(mode, offsets[i].index, offsets[i].count);
                _this.info.render.calls++;
                _this.info.render.points += offsets[i].count;
              }
            }
          }
        } else if (object instanceof THREE.Line) {
          var mode = (object.mode === THREE.LineStrip) ? _gl.LINE_STRIP : _gl.LINES;
          state.setLineWidth(material.linewidth * pixelRatio);
          var index = geometry.attributes.index;
          if (index) {
            var type,
                size;
            if (index.array instanceof Uint32Array) {
              type = _gl.UNSIGNED_INT;
              size = 4;
            } else {
              type = _gl.UNSIGNED_SHORT;
              size = 2;
            }
            var offsets = geometry.offsets;
            if (offsets.length === 0) {
              if (updateBuffers) {
                setupVertexAttributes(material, program, geometry, 0);
                _gl.bindBuffer(_gl.ELEMENT_ARRAY_BUFFER, index.buffer);
              }
              _gl.drawElements(mode, index.array.length, type, 0);
              _this.info.render.calls++;
              _this.info.render.vertices += index.array.length;
            } else {
              if (offsets.length > 1)
                updateBuffers = true;
              for (var i = 0,
                  il = offsets.length; i < il; i++) {
                var startIndex = offsets[i].index;
                if (updateBuffers) {
                  setupVertexAttributes(material, program, geometry, startIndex);
                  _gl.bindBuffer(_gl.ELEMENT_ARRAY_BUFFER, index.buffer);
                }
                _gl.drawElements(mode, offsets[i].count, type, offsets[i].start * size);
                _this.info.render.calls++;
                _this.info.render.vertices += offsets[i].count;
              }
            }
          } else {
            if (updateBuffers) {
              setupVertexAttributes(material, program, geometry, 0);
            }
            var position = geometry.attributes.position;
            var offsets = geometry.offsets;
            if (offsets.length === 0) {
              _gl.drawArrays(mode, 0, position.array.length / 3);
              _this.info.render.calls++;
              _this.info.render.vertices += position.array.length / 3;
            } else {
              for (var i = 0,
                  il = offsets.length; i < il; i++) {
                _gl.drawArrays(mode, offsets[i].index, offsets[i].count);
                _this.info.render.calls++;
                _this.info.render.vertices += offsets[i].count;
              }
            }
          }
        }
      };
      this.renderBuffer = function(camera, lights, fog, material, geometryGroup, object) {
        if (material.visible === false)
          return ;
        updateObject(object);
        var program = setProgram(camera, lights, fog, material, object);
        var attributes = program.attributes;
        var updateBuffers = false,
            wireframeBit = material.wireframe ? 1 : 0,
            geometryProgram = geometryGroup.id + '_' + program.id + '_' + wireframeBit;
        if (geometryProgram !== _currentGeometryProgram) {
          _currentGeometryProgram = geometryProgram;
          updateBuffers = true;
        }
        if (updateBuffers) {
          state.initAttributes();
        }
        if (!material.morphTargets && attributes.position >= 0) {
          if (updateBuffers) {
            _gl.bindBuffer(_gl.ARRAY_BUFFER, geometryGroup.__webglVertexBuffer);
            state.enableAttribute(attributes.position);
            _gl.vertexAttribPointer(attributes.position, 3, _gl.FLOAT, false, 0, 0);
          }
        } else {
          if (object.morphTargetBase) {
            setupMorphTargets(material, geometryGroup, object);
          }
        }
        if (updateBuffers) {
          if (geometryGroup.__webglCustomAttributesList) {
            for (var i = 0,
                il = geometryGroup.__webglCustomAttributesList.length; i < il; i++) {
              var attribute = geometryGroup.__webglCustomAttributesList[i];
              if (attributes[attribute.buffer.belongsToAttribute] >= 0) {
                _gl.bindBuffer(_gl.ARRAY_BUFFER, attribute.buffer);
                state.enableAttribute(attributes[attribute.buffer.belongsToAttribute]);
                _gl.vertexAttribPointer(attributes[attribute.buffer.belongsToAttribute], attribute.size, _gl.FLOAT, false, 0, 0);
              }
            }
          }
          if (attributes.color >= 0) {
            if (object.geometry.colors.length > 0 || object.geometry.faces.length > 0) {
              _gl.bindBuffer(_gl.ARRAY_BUFFER, geometryGroup.__webglColorBuffer);
              state.enableAttribute(attributes.color);
              _gl.vertexAttribPointer(attributes.color, 3, _gl.FLOAT, false, 0, 0);
            } else if (material.defaultAttributeValues !== undefined) {
              _gl.vertexAttrib3fv(attributes.color, material.defaultAttributeValues.color);
            }
          }
          if (attributes.normal >= 0) {
            _gl.bindBuffer(_gl.ARRAY_BUFFER, geometryGroup.__webglNormalBuffer);
            state.enableAttribute(attributes.normal);
            _gl.vertexAttribPointer(attributes.normal, 3, _gl.FLOAT, false, 0, 0);
          }
          if (attributes.tangent >= 0) {
            _gl.bindBuffer(_gl.ARRAY_BUFFER, geometryGroup.__webglTangentBuffer);
            state.enableAttribute(attributes.tangent);
            _gl.vertexAttribPointer(attributes.tangent, 4, _gl.FLOAT, false, 0, 0);
          }
          if (attributes.uv >= 0) {
            if (object.geometry.faceVertexUvs[0]) {
              _gl.bindBuffer(_gl.ARRAY_BUFFER, geometryGroup.__webglUVBuffer);
              state.enableAttribute(attributes.uv);
              _gl.vertexAttribPointer(attributes.uv, 2, _gl.FLOAT, false, 0, 0);
            } else if (material.defaultAttributeValues !== undefined) {
              _gl.vertexAttrib2fv(attributes.uv, material.defaultAttributeValues.uv);
            }
          }
          if (attributes.uv2 >= 0) {
            if (object.geometry.faceVertexUvs[1]) {
              _gl.bindBuffer(_gl.ARRAY_BUFFER, geometryGroup.__webglUV2Buffer);
              state.enableAttribute(attributes.uv2);
              _gl.vertexAttribPointer(attributes.uv2, 2, _gl.FLOAT, false, 0, 0);
            } else if (material.defaultAttributeValues !== undefined) {
              _gl.vertexAttrib2fv(attributes.uv2, material.defaultAttributeValues.uv2);
            }
          }
          if (material.skinning && attributes.skinIndex >= 0 && attributes.skinWeight >= 0) {
            _gl.bindBuffer(_gl.ARRAY_BUFFER, geometryGroup.__webglSkinIndicesBuffer);
            state.enableAttribute(attributes.skinIndex);
            _gl.vertexAttribPointer(attributes.skinIndex, 4, _gl.FLOAT, false, 0, 0);
            _gl.bindBuffer(_gl.ARRAY_BUFFER, geometryGroup.__webglSkinWeightsBuffer);
            state.enableAttribute(attributes.skinWeight);
            _gl.vertexAttribPointer(attributes.skinWeight, 4, _gl.FLOAT, false, 0, 0);
          }
          if (attributes.lineDistance >= 0) {
            _gl.bindBuffer(_gl.ARRAY_BUFFER, geometryGroup.__webglLineDistanceBuffer);
            state.enableAttribute(attributes.lineDistance);
            _gl.vertexAttribPointer(attributes.lineDistance, 1, _gl.FLOAT, false, 0, 0);
          }
        }
        state.disableUnusedAttributes();
        if (object instanceof THREE.Mesh) {
          var type = geometryGroup.__typeArray === Uint32Array ? _gl.UNSIGNED_INT : _gl.UNSIGNED_SHORT;
          if (material.wireframe) {
            state.setLineWidth(material.wireframeLinewidth * pixelRatio);
            if (updateBuffers)
              _gl.bindBuffer(_gl.ELEMENT_ARRAY_BUFFER, geometryGroup.__webglLineBuffer);
            _gl.drawElements(_gl.LINES, geometryGroup.__webglLineCount, type, 0);
          } else {
            if (updateBuffers)
              _gl.bindBuffer(_gl.ELEMENT_ARRAY_BUFFER, geometryGroup.__webglFaceBuffer);
            _gl.drawElements(_gl.TRIANGLES, geometryGroup.__webglFaceCount, type, 0);
          }
          _this.info.render.calls++;
          _this.info.render.vertices += geometryGroup.__webglFaceCount;
          _this.info.render.faces += geometryGroup.__webglFaceCount / 3;
        } else if (object instanceof THREE.Line) {
          var mode = (object.mode === THREE.LineStrip) ? _gl.LINE_STRIP : _gl.LINES;
          state.setLineWidth(material.linewidth * pixelRatio);
          _gl.drawArrays(mode, 0, geometryGroup.__webglLineCount);
          _this.info.render.calls++;
        } else if (object instanceof THREE.PointCloud) {
          _gl.drawArrays(_gl.POINTS, 0, geometryGroup.__webglParticleCount);
          _this.info.render.calls++;
          _this.info.render.points += geometryGroup.__webglParticleCount;
        }
      };
      function setupMorphTargets(material, geometryGroup, object) {
        var attributes = material.program.attributes;
        if (object.morphTargetBase !== -1 && attributes.position >= 0) {
          _gl.bindBuffer(_gl.ARRAY_BUFFER, geometryGroup.__webglMorphTargetsBuffers[object.morphTargetBase]);
          state.enableAttribute(attributes.position);
          _gl.vertexAttribPointer(attributes.position, 3, _gl.FLOAT, false, 0, 0);
        } else if (attributes.position >= 0) {
          _gl.bindBuffer(_gl.ARRAY_BUFFER, geometryGroup.__webglVertexBuffer);
          state.enableAttribute(attributes.position);
          _gl.vertexAttribPointer(attributes.position, 3, _gl.FLOAT, false, 0, 0);
        }
        if (object.morphTargetForcedOrder.length) {
          var m = 0;
          var order = object.morphTargetForcedOrder;
          var influences = object.morphTargetInfluences;
          var attribute;
          while (m < material.numSupportedMorphTargets && m < order.length) {
            attribute = attributes['morphTarget' + m];
            if (attribute >= 0) {
              _gl.bindBuffer(_gl.ARRAY_BUFFER, geometryGroup.__webglMorphTargetsBuffers[order[m]]);
              state.enableAttribute(attribute);
              _gl.vertexAttribPointer(attribute, 3, _gl.FLOAT, false, 0, 0);
            }
            attribute = attributes['morphNormal' + m];
            if (attribute >= 0 && material.morphNormals) {
              _gl.bindBuffer(_gl.ARRAY_BUFFER, geometryGroup.__webglMorphNormalsBuffers[order[m]]);
              state.enableAttribute(attribute);
              _gl.vertexAttribPointer(attribute, 3, _gl.FLOAT, false, 0, 0);
            }
            object.__webglMorphTargetInfluences[m] = influences[order[m]];
            m++;
          }
        } else {
          var activeInfluenceIndices = [];
          var influences = object.morphTargetInfluences;
          var morphTargets = object.geometry.morphTargets;
          if (influences.length > morphTargets.length) {
            console.warn('THREE.WebGLRenderer: Influences array is bigger than morphTargets array.');
            influences.length = morphTargets.length;
          }
          for (var i = 0,
              il = influences.length; i < il; i++) {
            var influence = influences[i];
            activeInfluenceIndices.push([influence, i]);
          }
          if (activeInfluenceIndices.length > material.numSupportedMorphTargets) {
            activeInfluenceIndices.sort(numericalSort);
            activeInfluenceIndices.length = material.numSupportedMorphTargets;
          } else if (activeInfluenceIndices.length > material.numSupportedMorphNormals) {
            activeInfluenceIndices.sort(numericalSort);
          } else if (activeInfluenceIndices.length === 0) {
            activeInfluenceIndices.push([0, 0]);
          }
          var attribute;
          for (var m = 0,
              ml = material.numSupportedMorphTargets; m < ml; m++) {
            if (activeInfluenceIndices[m]) {
              var influenceIndex = activeInfluenceIndices[m][1];
              attribute = attributes['morphTarget' + m];
              if (attribute >= 0) {
                _gl.bindBuffer(_gl.ARRAY_BUFFER, geometryGroup.__webglMorphTargetsBuffers[influenceIndex]);
                state.enableAttribute(attribute);
                _gl.vertexAttribPointer(attribute, 3, _gl.FLOAT, false, 0, 0);
              }
              attribute = attributes['morphNormal' + m];
              if (attribute >= 0 && material.morphNormals) {
                _gl.bindBuffer(_gl.ARRAY_BUFFER, geometryGroup.__webglMorphNormalsBuffers[influenceIndex]);
                state.enableAttribute(attribute);
                _gl.vertexAttribPointer(attribute, 3, _gl.FLOAT, false, 0, 0);
              }
              object.__webglMorphTargetInfluences[m] = influences[influenceIndex];
            } else {
              object.__webglMorphTargetInfluences[m] = 0;
            }
          }
        }
        if (material.program.uniforms.morphTargetInfluences !== null) {
          _gl.uniform1fv(material.program.uniforms.morphTargetInfluences, object.__webglMorphTargetInfluences);
        }
      }
      function painterSortStable(a, b) {
        if (a.object.renderOrder !== b.object.renderOrder) {
          return a.object.renderOrder - b.object.renderOrder;
        } else if (a.material.id !== b.material.id) {
          return a.material.id - b.material.id;
        } else if (a.z !== b.z) {
          return a.z - b.z;
        } else {
          return a.id - b.id;
        }
      }
      function reversePainterSortStable(a, b) {
        if (a.object.renderOrder !== b.object.renderOrder) {
          return a.object.renderOrder - b.object.renderOrder;
        }
        if (a.z !== b.z) {
          return b.z - a.z;
        } else {
          return a.id - b.id;
        }
      }
      function numericalSort(a, b) {
        return b[0] - a[0];
      }
      this.render = function(scene, camera, renderTarget, forceClear) {
        if (camera instanceof THREE.Camera === false) {
          THREE.error('THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera.');
          return ;
        }
        var fog = scene.fog;
        _currentGeometryProgram = '';
        _currentMaterialId = -1;
        _currentCamera = null;
        _lightsNeedUpdate = true;
        if (scene.autoUpdate === true)
          scene.updateMatrixWorld();
        if (camera.parent === undefined)
          camera.updateMatrixWorld();
        scene.traverse(function(object) {
          if (object instanceof THREE.SkinnedMesh) {
            object.skeleton.update();
          }
        });
        camera.matrixWorldInverse.getInverse(camera.matrixWorld);
        _projScreenMatrix.multiplyMatrices(camera.projectionMatrix, camera.matrixWorldInverse);
        _frustum.setFromMatrix(_projScreenMatrix);
        lights.length = 0;
        opaqueObjects.length = 0;
        transparentObjects.length = 0;
        sprites.length = 0;
        lensFlares.length = 0;
        projectObject(scene);
        if (_this.sortObjects === true) {
          opaqueObjects.sort(painterSortStable);
          transparentObjects.sort(reversePainterSortStable);
        }
        shadowMapPlugin.render(scene, camera);
        _this.info.render.calls = 0;
        _this.info.render.vertices = 0;
        _this.info.render.faces = 0;
        _this.info.render.points = 0;
        this.setRenderTarget(renderTarget);
        if (this.autoClear || forceClear) {
          this.clear(this.autoClearColor, this.autoClearDepth, this.autoClearStencil);
        }
        for (var i = 0,
            il = _webglObjectsImmediate.length; i < il; i++) {
          var webglObject = _webglObjectsImmediate[i];
          var object = webglObject.object;
          if (object.visible) {
            setupMatrices(object, camera);
            unrollImmediateBufferMaterial(webglObject);
          }
        }
        if (scene.overrideMaterial) {
          var overrideMaterial = scene.overrideMaterial;
          setMaterial(overrideMaterial);
          renderObjects(opaqueObjects, camera, lights, fog, overrideMaterial);
          renderObjects(transparentObjects, camera, lights, fog, overrideMaterial);
          renderObjectsImmediate(_webglObjectsImmediate, '', camera, lights, fog, overrideMaterial);
        } else {
          state.setBlending(THREE.NoBlending);
          renderObjects(opaqueObjects, camera, lights, fog, null);
          renderObjectsImmediate(_webglObjectsImmediate, 'opaque', camera, lights, fog, null);
          renderObjects(transparentObjects, camera, lights, fog, null);
          renderObjectsImmediate(_webglObjectsImmediate, 'transparent', camera, lights, fog, null);
        }
        spritePlugin.render(scene, camera);
        lensFlarePlugin.render(scene, camera, _currentWidth, _currentHeight);
        if (renderTarget && renderTarget.generateMipmaps && renderTarget.minFilter !== THREE.NearestFilter && renderTarget.minFilter !== THREE.LinearFilter) {
          updateRenderTargetMipmap(renderTarget);
        }
        state.setDepthTest(true);
        state.setDepthWrite(true);
        state.setColorWrite(true);
      };
      function projectObject(object) {
        if (object.visible === false)
          return ;
        if (object instanceof THREE.Scene || object instanceof THREE.Group) {} else {
          initObject(object);
          if (object instanceof THREE.Light) {
            lights.push(object);
          } else if (object instanceof THREE.Sprite) {
            sprites.push(object);
          } else if (object instanceof THREE.LensFlare) {
            lensFlares.push(object);
          } else {
            var webglObjects = _webglObjects[object.id];
            if (webglObjects && (object.frustumCulled === false || _frustum.intersectsObject(object) === true)) {
              for (var i = 0,
                  l = webglObjects.length; i < l; i++) {
                var webglObject = webglObjects[i];
                unrollBufferMaterial(webglObject);
                webglObject.render = true;
                if (_this.sortObjects === true) {
                  _vector3.setFromMatrixPosition(object.matrixWorld);
                  _vector3.applyProjection(_projScreenMatrix);
                  webglObject.z = _vector3.z;
                }
              }
            }
          }
        }
        for (var i = 0,
            l = object.children.length; i < l; i++) {
          projectObject(object.children[i]);
        }
      }
      function renderObjects(renderList, camera, lights, fog, overrideMaterial) {
        var material;
        for (var i = 0,
            l = renderList.length; i < l; i++) {
          var webglObject = renderList[i];
          var object = webglObject.object;
          var buffer = webglObject.buffer;
          setupMatrices(object, camera);
          if (overrideMaterial) {
            material = overrideMaterial;
          } else {
            material = webglObject.material;
            if (!material)
              continue;
            setMaterial(material);
          }
          _this.setMaterialFaces(material);
          if (buffer instanceof THREE.BufferGeometry) {
            _this.renderBufferDirect(camera, lights, fog, material, buffer, object);
          } else {
            _this.renderBuffer(camera, lights, fog, material, buffer, object);
          }
        }
      }
      function renderObjectsImmediate(renderList, materialType, camera, lights, fog, overrideMaterial) {
        var material;
        for (var i = 0,
            l = renderList.length; i < l; i++) {
          var webglObject = renderList[i];
          var object = webglObject.object;
          if (object.visible) {
            if (overrideMaterial) {
              material = overrideMaterial;
            } else {
              material = webglObject[materialType];
              if (!material)
                continue;
              setMaterial(material);
            }
            _this.renderImmediateObject(camera, lights, fog, material, object);
          }
        }
      }
      this.renderImmediateObject = function(camera, lights, fog, material, object) {
        var program = setProgram(camera, lights, fog, material, object);
        _currentGeometryProgram = '';
        _this.setMaterialFaces(material);
        if (object.immediateRenderCallback) {
          object.immediateRenderCallback(program, _gl, _frustum);
        } else {
          object.render(function(object) {
            _this.renderBufferImmediate(object, program, material);
          });
        }
      };
      function unrollImmediateBufferMaterial(globject) {
        var object = globject.object,
            material = object.material;
        if (material.transparent) {
          globject.transparent = material;
          globject.opaque = null;
        } else {
          globject.opaque = material;
          globject.transparent = null;
        }
      }
      function unrollBufferMaterial(globject) {
        var object = globject.object;
        var buffer = globject.buffer;
        var geometry = object.geometry;
        var material = object.material;
        if (material instanceof THREE.MeshFaceMaterial) {
          var materialIndex = geometry instanceof THREE.BufferGeometry ? 0 : buffer.materialIndex;
          material = material.materials[materialIndex];
          globject.material = material;
          if (material.transparent) {
            transparentObjects.push(globject);
          } else {
            opaqueObjects.push(globject);
          }
        } else if (material) {
          globject.material = material;
          if (material.transparent) {
            transparentObjects.push(globject);
          } else {
            opaqueObjects.push(globject);
          }
        }
      }
      function initObject(object) {
        if (object.__webglInit === undefined) {
          object.__webglInit = true;
          object._modelViewMatrix = new THREE.Matrix4();
          object._normalMatrix = new THREE.Matrix3();
          object.addEventListener('removed', onObjectRemoved);
        }
        var geometry = object.geometry;
        if (geometry === undefined) {} else if (geometry.__webglInit === undefined) {
          geometry.__webglInit = true;
          geometry.addEventListener('dispose', onGeometryDispose);
          if (geometry instanceof THREE.BufferGeometry) {
            _this.info.memory.geometries++;
          } else if (object instanceof THREE.Mesh) {
            initGeometryGroups(object, geometry);
          } else if (object instanceof THREE.Line) {
            if (geometry.__webglVertexBuffer === undefined) {
              createLineBuffers(geometry);
              initLineBuffers(geometry, object);
              geometry.verticesNeedUpdate = true;
              geometry.colorsNeedUpdate = true;
              geometry.lineDistancesNeedUpdate = true;
            }
          } else if (object instanceof THREE.PointCloud) {
            if (geometry.__webglVertexBuffer === undefined) {
              createParticleBuffers(geometry);
              initParticleBuffers(geometry, object);
              geometry.verticesNeedUpdate = true;
              geometry.colorsNeedUpdate = true;
            }
          }
        }
        if (object.__webglActive === undefined) {
          object.__webglActive = true;
          if (object instanceof THREE.Mesh) {
            if (geometry instanceof THREE.BufferGeometry) {
              addBuffer(_webglObjects, geometry, object);
            } else if (geometry instanceof THREE.Geometry) {
              var geometryGroupsList = geometryGroups[geometry.id];
              for (var i = 0,
                  l = geometryGroupsList.length; i < l; i++) {
                addBuffer(_webglObjects, geometryGroupsList[i], object);
              }
            }
          } else if (object instanceof THREE.Line || object instanceof THREE.PointCloud) {
            addBuffer(_webglObjects, geometry, object);
          } else if (object instanceof THREE.ImmediateRenderObject || object.immediateRenderCallback) {
            addBufferImmediate(_webglObjectsImmediate, object);
          }
        }
      }
      var geometryGroups = {};
      var geometryGroupCounter = 0;
      function makeGroups(geometry, usesFaceMaterial) {
        var maxVerticesInGroup = extensions.get('OES_element_index_uint') ? 4294967296 : 65535;
        var groupHash,
            hash_map = {};
        var numMorphTargets = geometry.morphTargets.length;
        var numMorphNormals = geometry.morphNormals.length;
        var group;
        var groups = {};
        var groupsList = [];
        for (var f = 0,
            fl = geometry.faces.length; f < fl; f++) {
          var face = geometry.faces[f];
          var materialIndex = usesFaceMaterial ? face.materialIndex : 0;
          if (!(materialIndex in hash_map)) {
            hash_map[materialIndex] = {
              hash: materialIndex,
              counter: 0
            };
          }
          groupHash = hash_map[materialIndex].hash + '_' + hash_map[materialIndex].counter;
          if (!(groupHash in groups)) {
            group = {
              id: geometryGroupCounter++,
              faces3: [],
              materialIndex: materialIndex,
              vertices: 0,
              numMorphTargets: numMorphTargets,
              numMorphNormals: numMorphNormals
            };
            groups[groupHash] = group;
            groupsList.push(group);
          }
          if (groups[groupHash].vertices + 3 > maxVerticesInGroup) {
            hash_map[materialIndex].counter += 1;
            groupHash = hash_map[materialIndex].hash + '_' + hash_map[materialIndex].counter;
            if (!(groupHash in groups)) {
              group = {
                id: geometryGroupCounter++,
                faces3: [],
                materialIndex: materialIndex,
                vertices: 0,
                numMorphTargets: numMorphTargets,
                numMorphNormals: numMorphNormals
              };
              groups[groupHash] = group;
              groupsList.push(group);
            }
          }
          groups[groupHash].faces3.push(f);
          groups[groupHash].vertices += 3;
        }
        return groupsList;
      }
      function initGeometryGroups(object, geometry) {
        var material = object.material,
            addBuffers = false;
        if (geometryGroups[geometry.id] === undefined || geometry.groupsNeedUpdate === true) {
          delete _webglObjects[object.id];
          geometryGroups[geometry.id] = makeGroups(geometry, material instanceof THREE.MeshFaceMaterial);
          geometry.groupsNeedUpdate = false;
        }
        var geometryGroupsList = geometryGroups[geometry.id];
        for (var i = 0,
            il = geometryGroupsList.length; i < il; i++) {
          var geometryGroup = geometryGroupsList[i];
          if (geometryGroup.__webglVertexBuffer === undefined) {
            createMeshBuffers(geometryGroup);
            initMeshBuffers(geometryGroup, object);
            geometry.verticesNeedUpdate = true;
            geometry.morphTargetsNeedUpdate = true;
            geometry.elementsNeedUpdate = true;
            geometry.uvsNeedUpdate = true;
            geometry.normalsNeedUpdate = true;
            geometry.tangentsNeedUpdate = true;
            geometry.colorsNeedUpdate = true;
            addBuffers = true;
          } else {
            addBuffers = false;
          }
          if (addBuffers || object.__webglActive === undefined) {
            addBuffer(_webglObjects, geometryGroup, object);
          }
        }
        object.__webglActive = true;
      }
      function addBuffer(objlist, buffer, object) {
        var id = object.id;
        objlist[id] = objlist[id] || [];
        objlist[id].push({
          id: id,
          buffer: buffer,
          object: object,
          material: null,
          z: 0
        });
      }
      ;
      function addBufferImmediate(objlist, object) {
        objlist.push({
          id: null,
          object: object,
          opaque: null,
          transparent: null,
          z: 0
        });
      }
      ;
      function updateObject(object) {
        var geometry = object.geometry;
        if (geometry instanceof THREE.BufferGeometry) {
          var attributes = geometry.attributes;
          var attributesKeys = geometry.attributesKeys;
          for (var i = 0,
              l = attributesKeys.length; i < l; i++) {
            var key = attributesKeys[i];
            var attribute = attributes[key];
            var bufferType = (key === 'index') ? _gl.ELEMENT_ARRAY_BUFFER : _gl.ARRAY_BUFFER;
            if (attribute.buffer === undefined) {
              attribute.buffer = _gl.createBuffer();
              _gl.bindBuffer(bufferType, attribute.buffer);
              _gl.bufferData(bufferType, attribute.array, (attribute instanceof THREE.DynamicBufferAttribute) ? _gl.DYNAMIC_DRAW : _gl.STATIC_DRAW);
              attribute.needsUpdate = false;
            } else if (attribute.needsUpdate === true) {
              _gl.bindBuffer(bufferType, attribute.buffer);
              if (attribute.updateRange === undefined || attribute.updateRange.count === -1) {
                _gl.bufferSubData(bufferType, 0, attribute.array);
              } else if (attribute.updateRange.count === 0) {
                console.error('THREE.WebGLRenderer.updateObject: using updateRange for THREE.DynamicBufferAttribute and marked as needsUpdate but count is 0, ensure you are using set methods or updating manually.');
              } else {
                _gl.bufferSubData(bufferType, attribute.updateRange.offset * attribute.array.BYTES_PER_ELEMENT, attribute.array.subarray(attribute.updateRange.offset, attribute.updateRange.offset + attribute.updateRange.count));
                attribute.updateRange.count = 0;
              }
              attribute.needsUpdate = false;
            }
          }
        } else if (object instanceof THREE.Mesh) {
          if (geometry.groupsNeedUpdate === true) {
            initGeometryGroups(object, geometry);
          }
          var geometryGroupsList = geometryGroups[geometry.id];
          for (var i = 0,
              il = geometryGroupsList.length; i < il; i++) {
            var geometryGroup = geometryGroupsList[i];
            var material = getBufferMaterial(object, geometryGroup);
            var customAttributesDirty = material.attributes && areCustomAttributesDirty(material);
            if (geometry.verticesNeedUpdate || geometry.morphTargetsNeedUpdate || geometry.elementsNeedUpdate || geometry.uvsNeedUpdate || geometry.normalsNeedUpdate || geometry.colorsNeedUpdate || geometry.tangentsNeedUpdate || customAttributesDirty) {
              setMeshBuffers(geometryGroup, object, _gl.DYNAMIC_DRAW, !geometry.dynamic, material);
            }
          }
          geometry.verticesNeedUpdate = false;
          geometry.morphTargetsNeedUpdate = false;
          geometry.elementsNeedUpdate = false;
          geometry.uvsNeedUpdate = false;
          geometry.normalsNeedUpdate = false;
          geometry.colorsNeedUpdate = false;
          geometry.tangentsNeedUpdate = false;
          material.attributes && clearCustomAttributes(material);
        } else if (object instanceof THREE.Line) {
          var material = getBufferMaterial(object, geometry);
          var customAttributesDirty = material.attributes && areCustomAttributesDirty(material);
          if (geometry.verticesNeedUpdate || geometry.colorsNeedUpdate || geometry.lineDistancesNeedUpdate || customAttributesDirty) {
            setLineBuffers(geometry, _gl.DYNAMIC_DRAW);
          }
          geometry.verticesNeedUpdate = false;
          geometry.colorsNeedUpdate = false;
          geometry.lineDistancesNeedUpdate = false;
          material.attributes && clearCustomAttributes(material);
        } else if (object instanceof THREE.PointCloud) {
          var material = getBufferMaterial(object, geometry);
          var customAttributesDirty = material.attributes && areCustomAttributesDirty(material);
          if (geometry.verticesNeedUpdate || geometry.colorsNeedUpdate || customAttributesDirty) {
            setParticleBuffers(geometry, _gl.DYNAMIC_DRAW, object);
          }
          geometry.verticesNeedUpdate = false;
          geometry.colorsNeedUpdate = false;
          material.attributes && clearCustomAttributes(material);
        }
      }
      function areCustomAttributesDirty(material) {
        for (var name in material.attributes) {
          if (material.attributes[name].needsUpdate)
            return true;
        }
        return false;
      }
      function clearCustomAttributes(material) {
        for (var name in material.attributes) {
          material.attributes[name].needsUpdate = false;
        }
      }
      function removeObject(object) {
        if (object instanceof THREE.Mesh || object instanceof THREE.PointCloud || object instanceof THREE.Line) {
          delete _webglObjects[object.id];
        } else if (object instanceof THREE.ImmediateRenderObject || object.immediateRenderCallback) {
          removeInstances(_webglObjectsImmediate, object);
        }
        delete object.__webglInit;
        delete object._modelViewMatrix;
        delete object._normalMatrix;
        delete object.__webglActive;
      }
      function removeInstances(objlist, object) {
        for (var o = objlist.length - 1; o >= 0; o--) {
          if (objlist[o].object === object) {
            objlist.splice(o, 1);
          }
        }
      }
      var shaderIDs = {
        MeshDepthMaterial: 'depth',
        MeshNormalMaterial: 'normal',
        MeshBasicMaterial: 'basic',
        MeshLambertMaterial: 'lambert',
        MeshPhongMaterial: 'phong',
        LineBasicMaterial: 'basic',
        LineDashedMaterial: 'dashed',
        PointCloudMaterial: 'particle_basic'
      };
      function initMaterial(material, lights, fog, object) {
        material.addEventListener('dispose', onMaterialDispose);
        var shaderID = shaderIDs[material.type];
        if (shaderID) {
          var shader = THREE.ShaderLib[shaderID];
          material.__webglShader = {
            uniforms: THREE.UniformsUtils.clone(shader.uniforms),
            vertexShader: shader.vertexShader,
            fragmentShader: shader.fragmentShader
          };
        } else {
          material.__webglShader = {
            uniforms: material.uniforms,
            vertexShader: material.vertexShader,
            fragmentShader: material.fragmentShader
          };
        }
        var maxLightCount = allocateLights(lights);
        var maxShadows = allocateShadows(lights);
        var maxBones = allocateBones(object);
        var parameters = {
          precision: _precision,
          supportsVertexTextures: _supportsVertexTextures,
          map: !!material.map,
          envMap: !!material.envMap,
          envMapMode: material.envMap && material.envMap.mapping,
          lightMap: !!material.lightMap,
          bumpMap: !!material.bumpMap,
          normalMap: !!material.normalMap,
          specularMap: !!material.specularMap,
          alphaMap: !!material.alphaMap,
          combine: material.combine,
          vertexColors: material.vertexColors,
          fog: fog,
          useFog: material.fog,
          fogExp: fog instanceof THREE.FogExp2,
          flatShading: material.shading === THREE.FlatShading,
          sizeAttenuation: material.sizeAttenuation,
          logarithmicDepthBuffer: _logarithmicDepthBuffer,
          skinning: material.skinning,
          maxBones: maxBones,
          useVertexTexture: _supportsBoneTextures && object && object.skeleton && object.skeleton.useVertexTexture,
          morphTargets: material.morphTargets,
          morphNormals: material.morphNormals,
          maxMorphTargets: _this.maxMorphTargets,
          maxMorphNormals: _this.maxMorphNormals,
          maxDirLights: maxLightCount.directional,
          maxPointLights: maxLightCount.point,
          maxSpotLights: maxLightCount.spot,
          maxHemiLights: maxLightCount.hemi,
          maxShadows: maxShadows,
          shadowMapEnabled: _this.shadowMapEnabled && object.receiveShadow && maxShadows > 0,
          shadowMapType: _this.shadowMapType,
          shadowMapDebug: _this.shadowMapDebug,
          shadowMapCascade: _this.shadowMapCascade,
          alphaTest: material.alphaTest,
          metal: material.metal,
          wrapAround: material.wrapAround,
          doubleSided: material.side === THREE.DoubleSide,
          flipSided: material.side === THREE.BackSide
        };
        var chunks = [];
        if (shaderID) {
          chunks.push(shaderID);
        } else {
          chunks.push(material.fragmentShader);
          chunks.push(material.vertexShader);
        }
        if (material.defines !== undefined) {
          for (var name in material.defines) {
            chunks.push(name);
            chunks.push(material.defines[name]);
          }
        }
        for (var name in parameters) {
          chunks.push(name);
          chunks.push(parameters[name]);
        }
        var code = chunks.join();
        var program;
        for (var p = 0,
            pl = _programs.length; p < pl; p++) {
          var programInfo = _programs[p];
          if (programInfo.code === code) {
            program = programInfo;
            program.usedTimes++;
            break;
          }
        }
        if (program === undefined) {
          program = new THREE.WebGLProgram(_this, code, material, parameters);
          _programs.push(program);
          _this.info.memory.programs = _programs.length;
        }
        material.program = program;
        var attributes = program.attributes;
        if (material.morphTargets) {
          material.numSupportedMorphTargets = 0;
          var id,
              base = 'morphTarget';
          for (var i = 0; i < _this.maxMorphTargets; i++) {
            id = base + i;
            if (attributes[id] >= 0) {
              material.numSupportedMorphTargets++;
            }
          }
        }
        if (material.morphNormals) {
          material.numSupportedMorphNormals = 0;
          var id,
              base = 'morphNormal';
          for (i = 0; i < _this.maxMorphNormals; i++) {
            id = base + i;
            if (attributes[id] >= 0) {
              material.numSupportedMorphNormals++;
            }
          }
        }
        material.uniformsList = [];
        for (var u in material.__webglShader.uniforms) {
          var location = material.program.uniforms[u];
          if (location) {
            material.uniformsList.push([material.__webglShader.uniforms[u], location]);
          }
        }
      }
      function setMaterial(material) {
        if (material.transparent === true) {
          state.setBlending(material.blending, material.blendEquation, material.blendSrc, material.blendDst, material.blendEquationAlpha, material.blendSrcAlpha, material.blendDstAlpha);
        } else {
          state.setBlending(THREE.NoBlending);
        }
        state.setDepthTest(material.depthTest);
        state.setDepthWrite(material.depthWrite);
        state.setColorWrite(material.colorWrite);
        state.setPolygonOffset(material.polygonOffset, material.polygonOffsetFactor, material.polygonOffsetUnits);
      }
      function setProgram(camera, lights, fog, material, object) {
        _usedTextureUnits = 0;
        if (material.needsUpdate) {
          if (material.program)
            deallocateMaterial(material);
          initMaterial(material, lights, fog, object);
          material.needsUpdate = false;
        }
        if (material.morphTargets) {
          if (!object.__webglMorphTargetInfluences) {
            object.__webglMorphTargetInfluences = new Float32Array(_this.maxMorphTargets);
          }
        }
        var refreshProgram = false;
        var refreshMaterial = false;
        var refreshLights = false;
        var program = material.program,
            p_uniforms = program.uniforms,
            m_uniforms = material.__webglShader.uniforms;
        if (program.id !== _currentProgram) {
          _gl.useProgram(program.program);
          _currentProgram = program.id;
          refreshProgram = true;
          refreshMaterial = true;
          refreshLights = true;
        }
        if (material.id !== _currentMaterialId) {
          if (_currentMaterialId === -1)
            refreshLights = true;
          _currentMaterialId = material.id;
          refreshMaterial = true;
        }
        if (refreshProgram || camera !== _currentCamera) {
          _gl.uniformMatrix4fv(p_uniforms.projectionMatrix, false, camera.projectionMatrix.elements);
          if (_logarithmicDepthBuffer) {
            _gl.uniform1f(p_uniforms.logDepthBufFC, 2.0 / (Math.log(camera.far + 1.0) / Math.LN2));
          }
          if (camera !== _currentCamera)
            _currentCamera = camera;
          if (material instanceof THREE.ShaderMaterial || material instanceof THREE.MeshPhongMaterial || material.envMap) {
            if (p_uniforms.cameraPosition !== null) {
              _vector3.setFromMatrixPosition(camera.matrixWorld);
              _gl.uniform3f(p_uniforms.cameraPosition, _vector3.x, _vector3.y, _vector3.z);
            }
          }
          if (material instanceof THREE.MeshPhongMaterial || material instanceof THREE.MeshLambertMaterial || material instanceof THREE.MeshBasicMaterial || material instanceof THREE.ShaderMaterial || material.skinning) {
            if (p_uniforms.viewMatrix !== null) {
              _gl.uniformMatrix4fv(p_uniforms.viewMatrix, false, camera.matrixWorldInverse.elements);
            }
          }
        }
        if (material.skinning) {
          if (object.bindMatrix && p_uniforms.bindMatrix !== null) {
            _gl.uniformMatrix4fv(p_uniforms.bindMatrix, false, object.bindMatrix.elements);
          }
          if (object.bindMatrixInverse && p_uniforms.bindMatrixInverse !== null) {
            _gl.uniformMatrix4fv(p_uniforms.bindMatrixInverse, false, object.bindMatrixInverse.elements);
          }
          if (_supportsBoneTextures && object.skeleton && object.skeleton.useVertexTexture) {
            if (p_uniforms.boneTexture !== null) {
              var textureUnit = getTextureUnit();
              _gl.uniform1i(p_uniforms.boneTexture, textureUnit);
              _this.setTexture(object.skeleton.boneTexture, textureUnit);
            }
            if (p_uniforms.boneTextureWidth !== null) {
              _gl.uniform1i(p_uniforms.boneTextureWidth, object.skeleton.boneTextureWidth);
            }
            if (p_uniforms.boneTextureHeight !== null) {
              _gl.uniform1i(p_uniforms.boneTextureHeight, object.skeleton.boneTextureHeight);
            }
          } else if (object.skeleton && object.skeleton.boneMatrices) {
            if (p_uniforms.boneGlobalMatrices !== null) {
              _gl.uniformMatrix4fv(p_uniforms.boneGlobalMatrices, false, object.skeleton.boneMatrices);
            }
          }
        }
        if (refreshMaterial) {
          if (fog && material.fog) {
            refreshUniformsFog(m_uniforms, fog);
          }
          if (material instanceof THREE.MeshPhongMaterial || material instanceof THREE.MeshLambertMaterial || material.lights) {
            if (_lightsNeedUpdate) {
              refreshLights = true;
              setupLights(lights);
              _lightsNeedUpdate = false;
            }
            if (refreshLights) {
              refreshUniformsLights(m_uniforms, _lights);
              markUniformsLightsNeedsUpdate(m_uniforms, true);
            } else {
              markUniformsLightsNeedsUpdate(m_uniforms, false);
            }
          }
          if (material instanceof THREE.MeshBasicMaterial || material instanceof THREE.MeshLambertMaterial || material instanceof THREE.MeshPhongMaterial) {
            refreshUniformsCommon(m_uniforms, material);
          }
          if (material instanceof THREE.LineBasicMaterial) {
            refreshUniformsLine(m_uniforms, material);
          } else if (material instanceof THREE.LineDashedMaterial) {
            refreshUniformsLine(m_uniforms, material);
            refreshUniformsDash(m_uniforms, material);
          } else if (material instanceof THREE.PointCloudMaterial) {
            refreshUniformsParticle(m_uniforms, material);
          } else if (material instanceof THREE.MeshPhongMaterial) {
            refreshUniformsPhong(m_uniforms, material);
          } else if (material instanceof THREE.MeshLambertMaterial) {
            refreshUniformsLambert(m_uniforms, material);
          } else if (material instanceof THREE.MeshDepthMaterial) {
            m_uniforms.mNear.value = camera.near;
            m_uniforms.mFar.value = camera.far;
            m_uniforms.opacity.value = material.opacity;
          } else if (material instanceof THREE.MeshNormalMaterial) {
            m_uniforms.opacity.value = material.opacity;
          }
          if (object.receiveShadow && !material._shadowPass) {
            refreshUniformsShadow(m_uniforms, lights);
          }
          loadUniformsGeneric(material.uniformsList);
        }
        loadUniformsMatrices(p_uniforms, object);
        if (p_uniforms.modelMatrix !== null) {
          _gl.uniformMatrix4fv(p_uniforms.modelMatrix, false, object.matrixWorld.elements);
        }
        return program;
      }
      function refreshUniformsCommon(uniforms, material) {
        uniforms.opacity.value = material.opacity;
        uniforms.diffuse.value = material.color;
        uniforms.map.value = material.map;
        uniforms.lightMap.value = material.lightMap;
        uniforms.specularMap.value = material.specularMap;
        uniforms.alphaMap.value = material.alphaMap;
        if (material.bumpMap) {
          uniforms.bumpMap.value = material.bumpMap;
          uniforms.bumpScale.value = material.bumpScale;
        }
        if (material.normalMap) {
          uniforms.normalMap.value = material.normalMap;
          uniforms.normalScale.value.copy(material.normalScale);
        }
        var uvScaleMap;
        if (material.map) {
          uvScaleMap = material.map;
        } else if (material.specularMap) {
          uvScaleMap = material.specularMap;
        } else if (material.normalMap) {
          uvScaleMap = material.normalMap;
        } else if (material.bumpMap) {
          uvScaleMap = material.bumpMap;
        } else if (material.alphaMap) {
          uvScaleMap = material.alphaMap;
        }
        if (uvScaleMap !== undefined) {
          var offset = uvScaleMap.offset;
          var repeat = uvScaleMap.repeat;
          uniforms.offsetRepeat.value.set(offset.x, offset.y, repeat.x, repeat.y);
        }
        uniforms.envMap.value = material.envMap;
        uniforms.flipEnvMap.value = (material.envMap instanceof THREE.WebGLRenderTargetCube) ? 1 : -1;
        uniforms.reflectivity.value = material.reflectivity;
        uniforms.refractionRatio.value = material.refractionRatio;
      }
      function refreshUniformsLine(uniforms, material) {
        uniforms.diffuse.value = material.color;
        uniforms.opacity.value = material.opacity;
      }
      function refreshUniformsDash(uniforms, material) {
        uniforms.dashSize.value = material.dashSize;
        uniforms.totalSize.value = material.dashSize + material.gapSize;
        uniforms.scale.value = material.scale;
      }
      function refreshUniformsParticle(uniforms, material) {
        uniforms.psColor.value = material.color;
        uniforms.opacity.value = material.opacity;
        uniforms.size.value = material.size;
        uniforms.scale.value = _canvas.height / 2.0;
        uniforms.map.value = material.map;
        if (material.map !== null) {
          var offset = material.map.offset;
          var repeat = material.map.repeat;
          uniforms.offsetRepeat.value.set(offset.x, offset.y, repeat.x, repeat.y);
        }
      }
      function refreshUniformsFog(uniforms, fog) {
        uniforms.fogColor.value = fog.color;
        if (fog instanceof THREE.Fog) {
          uniforms.fogNear.value = fog.near;
          uniforms.fogFar.value = fog.far;
        } else if (fog instanceof THREE.FogExp2) {
          uniforms.fogDensity.value = fog.density;
        }
      }
      function refreshUniformsPhong(uniforms, material) {
        uniforms.shininess.value = material.shininess;
        uniforms.emissive.value = material.emissive;
        uniforms.specular.value = material.specular;
        if (material.wrapAround) {
          uniforms.wrapRGB.value.copy(material.wrapRGB);
        }
      }
      function refreshUniformsLambert(uniforms, material) {
        uniforms.emissive.value = material.emissive;
        if (material.wrapAround) {
          uniforms.wrapRGB.value.copy(material.wrapRGB);
        }
      }
      function refreshUniformsLights(uniforms, lights) {
        uniforms.ambientLightColor.value = lights.ambient;
        uniforms.directionalLightColor.value = lights.directional.colors;
        uniforms.directionalLightDirection.value = lights.directional.positions;
        uniforms.pointLightColor.value = lights.point.colors;
        uniforms.pointLightPosition.value = lights.point.positions;
        uniforms.pointLightDistance.value = lights.point.distances;
        uniforms.pointLightDecay.value = lights.point.decays;
        uniforms.spotLightColor.value = lights.spot.colors;
        uniforms.spotLightPosition.value = lights.spot.positions;
        uniforms.spotLightDistance.value = lights.spot.distances;
        uniforms.spotLightDirection.value = lights.spot.directions;
        uniforms.spotLightAngleCos.value = lights.spot.anglesCos;
        uniforms.spotLightExponent.value = lights.spot.exponents;
        uniforms.spotLightDecay.value = lights.spot.decays;
        uniforms.hemisphereLightSkyColor.value = lights.hemi.skyColors;
        uniforms.hemisphereLightGroundColor.value = lights.hemi.groundColors;
        uniforms.hemisphereLightDirection.value = lights.hemi.positions;
      }
      function markUniformsLightsNeedsUpdate(uniforms, value) {
        uniforms.ambientLightColor.needsUpdate = value;
        uniforms.directionalLightColor.needsUpdate = value;
        uniforms.directionalLightDirection.needsUpdate = value;
        uniforms.pointLightColor.needsUpdate = value;
        uniforms.pointLightPosition.needsUpdate = value;
        uniforms.pointLightDistance.needsUpdate = value;
        uniforms.pointLightDecay.needsUpdate = value;
        uniforms.spotLightColor.needsUpdate = value;
        uniforms.spotLightPosition.needsUpdate = value;
        uniforms.spotLightDistance.needsUpdate = value;
        uniforms.spotLightDirection.needsUpdate = value;
        uniforms.spotLightAngleCos.needsUpdate = value;
        uniforms.spotLightExponent.needsUpdate = value;
        uniforms.spotLightDecay.needsUpdate = value;
        uniforms.hemisphereLightSkyColor.needsUpdate = value;
        uniforms.hemisphereLightGroundColor.needsUpdate = value;
        uniforms.hemisphereLightDirection.needsUpdate = value;
      }
      function refreshUniformsShadow(uniforms, lights) {
        if (uniforms.shadowMatrix) {
          var j = 0;
          for (var i = 0,
              il = lights.length; i < il; i++) {
            var light = lights[i];
            if (!light.castShadow)
              continue;
            if (light instanceof THREE.SpotLight || (light instanceof THREE.DirectionalLight && !light.shadowCascade)) {
              uniforms.shadowMap.value[j] = light.shadowMap;
              uniforms.shadowMapSize.value[j] = light.shadowMapSize;
              uniforms.shadowMatrix.value[j] = light.shadowMatrix;
              uniforms.shadowDarkness.value[j] = light.shadowDarkness;
              uniforms.shadowBias.value[j] = light.shadowBias;
              j++;
            }
          }
        }
      }
      function loadUniformsMatrices(uniforms, object) {
        _gl.uniformMatrix4fv(uniforms.modelViewMatrix, false, object._modelViewMatrix.elements);
        if (uniforms.normalMatrix) {
          _gl.uniformMatrix3fv(uniforms.normalMatrix, false, object._normalMatrix.elements);
        }
      }
      function getTextureUnit() {
        var textureUnit = _usedTextureUnits;
        if (textureUnit >= _maxTextures) {
          THREE.warn('WebGLRenderer: trying to use ' + textureUnit + ' texture units while this GPU supports only ' + _maxTextures);
        }
        _usedTextureUnits += 1;
        return textureUnit;
      }
      function loadUniformsGeneric(uniforms) {
        var texture,
            textureUnit,
            offset;
        for (var j = 0,
            jl = uniforms.length; j < jl; j++) {
          var uniform = uniforms[j][0];
          if (uniform.needsUpdate === false)
            continue;
          var type = uniform.type;
          var value = uniform.value;
          var location = uniforms[j][1];
          switch (type) {
            case '1i':
              _gl.uniform1i(location, value);
              break;
            case '1f':
              _gl.uniform1f(location, value);
              break;
            case '2f':
              _gl.uniform2f(location, value[0], value[1]);
              break;
            case '3f':
              _gl.uniform3f(location, value[0], value[1], value[2]);
              break;
            case '4f':
              _gl.uniform4f(location, value[0], value[1], value[2], value[3]);
              break;
            case '1iv':
              _gl.uniform1iv(location, value);
              break;
            case '3iv':
              _gl.uniform3iv(location, value);
              break;
            case '1fv':
              _gl.uniform1fv(location, value);
              break;
            case '2fv':
              _gl.uniform2fv(location, value);
              break;
            case '3fv':
              _gl.uniform3fv(location, value);
              break;
            case '4fv':
              _gl.uniform4fv(location, value);
              break;
            case 'Matrix3fv':
              _gl.uniformMatrix3fv(location, false, value);
              break;
            case 'Matrix4fv':
              _gl.uniformMatrix4fv(location, false, value);
              break;
            case 'i':
              _gl.uniform1i(location, value);
              break;
            case 'f':
              _gl.uniform1f(location, value);
              break;
            case 'v2':
              _gl.uniform2f(location, value.x, value.y);
              break;
            case 'v3':
              _gl.uniform3f(location, value.x, value.y, value.z);
              break;
            case 'v4':
              _gl.uniform4f(location, value.x, value.y, value.z, value.w);
              break;
            case 'c':
              _gl.uniform3f(location, value.r, value.g, value.b);
              break;
            case 'iv1':
              _gl.uniform1iv(location, value);
              break;
            case 'iv':
              _gl.uniform3iv(location, value);
              break;
            case 'fv1':
              _gl.uniform1fv(location, value);
              break;
            case 'fv':
              _gl.uniform3fv(location, value);
              break;
            case 'v2v':
              if (uniform._array === undefined) {
                uniform._array = new Float32Array(2 * value.length);
              }
              for (var i = 0,
                  il = value.length; i < il; i++) {
                offset = i * 2;
                uniform._array[offset] = value[i].x;
                uniform._array[offset + 1] = value[i].y;
              }
              _gl.uniform2fv(location, uniform._array);
              break;
            case 'v3v':
              if (uniform._array === undefined) {
                uniform._array = new Float32Array(3 * value.length);
              }
              for (var i = 0,
                  il = value.length; i < il; i++) {
                offset = i * 3;
                uniform._array[offset] = value[i].x;
                uniform._array[offset + 1] = value[i].y;
                uniform._array[offset + 2] = value[i].z;
              }
              _gl.uniform3fv(location, uniform._array);
              break;
            case 'v4v':
              if (uniform._array === undefined) {
                uniform._array = new Float32Array(4 * value.length);
              }
              for (var i = 0,
                  il = value.length; i < il; i++) {
                offset = i * 4;
                uniform._array[offset] = value[i].x;
                uniform._array[offset + 1] = value[i].y;
                uniform._array[offset + 2] = value[i].z;
                uniform._array[offset + 3] = value[i].w;
              }
              _gl.uniform4fv(location, uniform._array);
              break;
            case 'm3':
              _gl.uniformMatrix3fv(location, false, value.elements);
              break;
            case 'm3v':
              if (uniform._array === undefined) {
                uniform._array = new Float32Array(9 * value.length);
              }
              for (var i = 0,
                  il = value.length; i < il; i++) {
                value[i].flattenToArrayOffset(uniform._array, i * 9);
              }
              _gl.uniformMatrix3fv(location, false, uniform._array);
              break;
            case 'm4':
              _gl.uniformMatrix4fv(location, false, value.elements);
              break;
            case 'm4v':
              if (uniform._array === undefined) {
                uniform._array = new Float32Array(16 * value.length);
              }
              for (var i = 0,
                  il = value.length; i < il; i++) {
                value[i].flattenToArrayOffset(uniform._array, i * 16);
              }
              _gl.uniformMatrix4fv(location, false, uniform._array);
              break;
            case 't':
              texture = value;
              textureUnit = getTextureUnit();
              _gl.uniform1i(location, textureUnit);
              if (!texture)
                continue;
              if (texture instanceof THREE.CubeTexture || (texture.image instanceof Array && texture.image.length === 6)) {
                setCubeTexture(texture, textureUnit);
              } else if (texture instanceof THREE.WebGLRenderTargetCube) {
                setCubeTextureDynamic(texture, textureUnit);
              } else {
                _this.setTexture(texture, textureUnit);
              }
              break;
            case 'tv':
              if (uniform._array === undefined) {
                uniform._array = [];
              }
              for (var i = 0,
                  il = uniform.value.length; i < il; i++) {
                uniform._array[i] = getTextureUnit();
              }
              _gl.uniform1iv(location, uniform._array);
              for (var i = 0,
                  il = uniform.value.length; i < il; i++) {
                texture = uniform.value[i];
                textureUnit = uniform._array[i];
                if (!texture)
                  continue;
                _this.setTexture(texture, textureUnit);
              }
              break;
            default:
              THREE.warn('THREE.WebGLRenderer: Unknown uniform type: ' + type);
          }
        }
      }
      function setupMatrices(object, camera) {
        object._modelViewMatrix.multiplyMatrices(camera.matrixWorldInverse, object.matrixWorld);
        object._normalMatrix.getNormalMatrix(object._modelViewMatrix);
      }
      function setColorLinear(array, offset, color, intensity) {
        array[offset] = color.r * intensity;
        array[offset + 1] = color.g * intensity;
        array[offset + 2] = color.b * intensity;
      }
      function setupLights(lights) {
        var l,
            ll,
            light,
            r = 0,
            g = 0,
            b = 0,
            color,
            skyColor,
            groundColor,
            intensity,
            distance,
            zlights = _lights,
            dirColors = zlights.directional.colors,
            dirPositions = zlights.directional.positions,
            pointColors = zlights.point.colors,
            pointPositions = zlights.point.positions,
            pointDistances = zlights.point.distances,
            pointDecays = zlights.point.decays,
            spotColors = zlights.spot.colors,
            spotPositions = zlights.spot.positions,
            spotDistances = zlights.spot.distances,
            spotDirections = zlights.spot.directions,
            spotAnglesCos = zlights.spot.anglesCos,
            spotExponents = zlights.spot.exponents,
            spotDecays = zlights.spot.decays,
            hemiSkyColors = zlights.hemi.skyColors,
            hemiGroundColors = zlights.hemi.groundColors,
            hemiPositions = zlights.hemi.positions,
            dirLength = 0,
            pointLength = 0,
            spotLength = 0,
            hemiLength = 0,
            dirCount = 0,
            pointCount = 0,
            spotCount = 0,
            hemiCount = 0,
            dirOffset = 0,
            pointOffset = 0,
            spotOffset = 0,
            hemiOffset = 0;
        for (l = 0, ll = lights.length; l < ll; l++) {
          light = lights[l];
          if (light.onlyShadow)
            continue;
          color = light.color;
          intensity = light.intensity;
          distance = light.distance;
          if (light instanceof THREE.AmbientLight) {
            if (!light.visible)
              continue;
            r += color.r;
            g += color.g;
            b += color.b;
          } else if (light instanceof THREE.DirectionalLight) {
            dirCount += 1;
            if (!light.visible)
              continue;
            _direction.setFromMatrixPosition(light.matrixWorld);
            _vector3.setFromMatrixPosition(light.target.matrixWorld);
            _direction.sub(_vector3);
            _direction.normalize();
            dirOffset = dirLength * 3;
            dirPositions[dirOffset] = _direction.x;
            dirPositions[dirOffset + 1] = _direction.y;
            dirPositions[dirOffset + 2] = _direction.z;
            setColorLinear(dirColors, dirOffset, color, intensity);
            dirLength += 1;
          } else if (light instanceof THREE.PointLight) {
            pointCount += 1;
            if (!light.visible)
              continue;
            pointOffset = pointLength * 3;
            setColorLinear(pointColors, pointOffset, color, intensity);
            _vector3.setFromMatrixPosition(light.matrixWorld);
            pointPositions[pointOffset] = _vector3.x;
            pointPositions[pointOffset + 1] = _vector3.y;
            pointPositions[pointOffset + 2] = _vector3.z;
            pointDistances[pointLength] = distance;
            pointDecays[pointLength] = (light.distance === 0) ? 0.0 : light.decay;
            pointLength += 1;
          } else if (light instanceof THREE.SpotLight) {
            spotCount += 1;
            if (!light.visible)
              continue;
            spotOffset = spotLength * 3;
            setColorLinear(spotColors, spotOffset, color, intensity);
            _direction.setFromMatrixPosition(light.matrixWorld);
            spotPositions[spotOffset] = _direction.x;
            spotPositions[spotOffset + 1] = _direction.y;
            spotPositions[spotOffset + 2] = _direction.z;
            spotDistances[spotLength] = distance;
            _vector3.setFromMatrixPosition(light.target.matrixWorld);
            _direction.sub(_vector3);
            _direction.normalize();
            spotDirections[spotOffset] = _direction.x;
            spotDirections[spotOffset + 1] = _direction.y;
            spotDirections[spotOffset + 2] = _direction.z;
            spotAnglesCos[spotLength] = Math.cos(light.angle);
            spotExponents[spotLength] = light.exponent;
            spotDecays[spotLength] = (light.distance === 0) ? 0.0 : light.decay;
            spotLength += 1;
          } else if (light instanceof THREE.HemisphereLight) {
            hemiCount += 1;
            if (!light.visible)
              continue;
            _direction.setFromMatrixPosition(light.matrixWorld);
            _direction.normalize();
            hemiOffset = hemiLength * 3;
            hemiPositions[hemiOffset] = _direction.x;
            hemiPositions[hemiOffset + 1] = _direction.y;
            hemiPositions[hemiOffset + 2] = _direction.z;
            skyColor = light.color;
            groundColor = light.groundColor;
            setColorLinear(hemiSkyColors, hemiOffset, skyColor, intensity);
            setColorLinear(hemiGroundColors, hemiOffset, groundColor, intensity);
            hemiLength += 1;
          }
        }
        for (l = dirLength * 3, ll = Math.max(dirColors.length, dirCount * 3); l < ll; l++)
          dirColors[l] = 0.0;
        for (l = pointLength * 3, ll = Math.max(pointColors.length, pointCount * 3); l < ll; l++)
          pointColors[l] = 0.0;
        for (l = spotLength * 3, ll = Math.max(spotColors.length, spotCount * 3); l < ll; l++)
          spotColors[l] = 0.0;
        for (l = hemiLength * 3, ll = Math.max(hemiSkyColors.length, hemiCount * 3); l < ll; l++)
          hemiSkyColors[l] = 0.0;
        for (l = hemiLength * 3, ll = Math.max(hemiGroundColors.length, hemiCount * 3); l < ll; l++)
          hemiGroundColors[l] = 0.0;
        zlights.directional.length = dirLength;
        zlights.point.length = pointLength;
        zlights.spot.length = spotLength;
        zlights.hemi.length = hemiLength;
        zlights.ambient[0] = r;
        zlights.ambient[1] = g;
        zlights.ambient[2] = b;
      }
      this.setFaceCulling = function(cullFace, frontFaceDirection) {
        if (cullFace === THREE.CullFaceNone) {
          _gl.disable(_gl.CULL_FACE);
        } else {
          if (frontFaceDirection === THREE.FrontFaceDirectionCW) {
            _gl.frontFace(_gl.CW);
          } else {
            _gl.frontFace(_gl.CCW);
          }
          if (cullFace === THREE.CullFaceBack) {
            _gl.cullFace(_gl.BACK);
          } else if (cullFace === THREE.CullFaceFront) {
            _gl.cullFace(_gl.FRONT);
          } else {
            _gl.cullFace(_gl.FRONT_AND_BACK);
          }
          _gl.enable(_gl.CULL_FACE);
        }
      };
      this.setMaterialFaces = function(material) {
        state.setDoubleSided(material.side === THREE.DoubleSide);
        state.setFlipSided(material.side === THREE.BackSide);
      };
      function setTextureParameters(textureType, texture, isImagePowerOfTwo) {
        var extension;
        if (isImagePowerOfTwo) {
          _gl.texParameteri(textureType, _gl.TEXTURE_WRAP_S, paramThreeToGL(texture.wrapS));
          _gl.texParameteri(textureType, _gl.TEXTURE_WRAP_T, paramThreeToGL(texture.wrapT));
          _gl.texParameteri(textureType, _gl.TEXTURE_MAG_FILTER, paramThreeToGL(texture.magFilter));
          _gl.texParameteri(textureType, _gl.TEXTURE_MIN_FILTER, paramThreeToGL(texture.minFilter));
        } else {
          _gl.texParameteri(textureType, _gl.TEXTURE_WRAP_S, _gl.CLAMP_TO_EDGE);
          _gl.texParameteri(textureType, _gl.TEXTURE_WRAP_T, _gl.CLAMP_TO_EDGE);
          if (texture.wrapS !== THREE.ClampToEdgeWrapping || texture.wrapT !== THREE.ClampToEdgeWrapping) {
            THREE.warn('THREE.WebGLRenderer: Texture is not power of two. Texture.wrapS and Texture.wrapT should be set to THREE.ClampToEdgeWrapping. ( ' + texture.sourceFile + ' )');
          }
          _gl.texParameteri(textureType, _gl.TEXTURE_MAG_FILTER, filterFallback(texture.magFilter));
          _gl.texParameteri(textureType, _gl.TEXTURE_MIN_FILTER, filterFallback(texture.minFilter));
          if (texture.minFilter !== THREE.NearestFilter && texture.minFilter !== THREE.LinearFilter) {
            THREE.warn('THREE.WebGLRenderer: Texture is not power of two. Texture.minFilter should be set to THREE.NearestFilter or THREE.LinearFilter. ( ' + texture.sourceFile + ' )');
          }
        }
        extension = extensions.get('EXT_texture_filter_anisotropic');
        if (extension && texture.type !== THREE.FloatType && texture.type !== THREE.HalfFloatType) {
          if (texture.anisotropy > 1 || texture.__currentAnisotropy) {
            _gl.texParameterf(textureType, extension.TEXTURE_MAX_ANISOTROPY_EXT, Math.min(texture.anisotropy, _this.getMaxAnisotropy()));
            texture.__currentAnisotropy = texture.anisotropy;
          }
        }
      }
      this.uploadTexture = function(texture) {
        if (texture.__webglInit === undefined) {
          texture.__webglInit = true;
          texture.addEventListener('dispose', onTextureDispose);
          texture.__webglTexture = _gl.createTexture();
          _this.info.memory.textures++;
        }
        _gl.bindTexture(_gl.TEXTURE_2D, texture.__webglTexture);
        _gl.pixelStorei(_gl.UNPACK_FLIP_Y_WEBGL, texture.flipY);
        _gl.pixelStorei(_gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, texture.premultiplyAlpha);
        _gl.pixelStorei(_gl.UNPACK_ALIGNMENT, texture.unpackAlignment);
        texture.image = clampToMaxSize(texture.image, _maxTextureSize);
        var image = texture.image,
            isImagePowerOfTwo = THREE.Math.isPowerOfTwo(image.width) && THREE.Math.isPowerOfTwo(image.height),
            glFormat = paramThreeToGL(texture.format),
            glType = paramThreeToGL(texture.type);
        setTextureParameters(_gl.TEXTURE_2D, texture, isImagePowerOfTwo);
        var mipmap,
            mipmaps = texture.mipmaps;
        if (texture instanceof THREE.DataTexture) {
          if (mipmaps.length > 0 && isImagePowerOfTwo) {
            for (var i = 0,
                il = mipmaps.length; i < il; i++) {
              mipmap = mipmaps[i];
              _gl.texImage2D(_gl.TEXTURE_2D, i, glFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data);
            }
            texture.generateMipmaps = false;
          } else {
            _gl.texImage2D(_gl.TEXTURE_2D, 0, glFormat, image.width, image.height, 0, glFormat, glType, image.data);
          }
        } else if (texture instanceof THREE.CompressedTexture) {
          for (var i = 0,
              il = mipmaps.length; i < il; i++) {
            mipmap = mipmaps[i];
            if (texture.format !== THREE.RGBAFormat && texture.format !== THREE.RGBFormat) {
              if (getCompressedTextureFormats().indexOf(glFormat) > -1) {
                _gl.compressedTexImage2D(_gl.TEXTURE_2D, i, glFormat, mipmap.width, mipmap.height, 0, mipmap.data);
              } else {
                THREE.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()");
              }
            } else {
              _gl.texImage2D(_gl.TEXTURE_2D, i, glFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data);
            }
          }
        } else {
          if (mipmaps.length > 0 && isImagePowerOfTwo) {
            for (var i = 0,
                il = mipmaps.length; i < il; i++) {
              mipmap = mipmaps[i];
              _gl.texImage2D(_gl.TEXTURE_2D, i, glFormat, glFormat, glType, mipmap);
            }
            texture.generateMipmaps = false;
          } else {
            _gl.texImage2D(_gl.TEXTURE_2D, 0, glFormat, glFormat, glType, texture.image);
          }
        }
        if (texture.generateMipmaps && isImagePowerOfTwo)
          _gl.generateMipmap(_gl.TEXTURE_2D);
        texture.needsUpdate = false;
        if (texture.onUpdate)
          texture.onUpdate();
      };
      this.setTexture = function(texture, slot) {
        _gl.activeTexture(_gl.TEXTURE0 + slot);
        if (texture.needsUpdate) {
          _this.uploadTexture(texture);
        } else {
          _gl.bindTexture(_gl.TEXTURE_2D, texture.__webglTexture);
        }
      };
      function clampToMaxSize(image, maxSize) {
        if (image.width > maxSize || image.height > maxSize) {
          var scale = maxSize / Math.max(image.width, image.height);
          var canvas = document.createElement('canvas');
          canvas.width = Math.floor(image.width * scale);
          canvas.height = Math.floor(image.height * scale);
          var context = canvas.getContext('2d');
          context.drawImage(image, 0, 0, image.width, image.height, 0, 0, canvas.width, canvas.height);
          THREE.warn('THREE.WebGLRenderer: image is too big (' + image.width + 'x' + image.height + '). Resized to ' + canvas.width + 'x' + canvas.height, image);
          return canvas;
        }
        return image;
      }
      function setCubeTexture(texture, slot) {
        if (texture.image.length === 6) {
          if (texture.needsUpdate) {
            if (!texture.image.__webglTextureCube) {
              texture.addEventListener('dispose', onTextureDispose);
              texture.image.__webglTextureCube = _gl.createTexture();
              _this.info.memory.textures++;
            }
            _gl.activeTexture(_gl.TEXTURE0 + slot);
            _gl.bindTexture(_gl.TEXTURE_CUBE_MAP, texture.image.__webglTextureCube);
            _gl.pixelStorei(_gl.UNPACK_FLIP_Y_WEBGL, texture.flipY);
            var isCompressed = texture instanceof THREE.CompressedTexture;
            var isDataTexture = texture.image[0] instanceof THREE.DataTexture;
            var cubeImage = [];
            for (var i = 0; i < 6; i++) {
              if (_this.autoScaleCubemaps && !isCompressed && !isDataTexture) {
                cubeImage[i] = clampToMaxSize(texture.image[i], _maxCubemapSize);
              } else {
                cubeImage[i] = isDataTexture ? texture.image[i].image : texture.image[i];
              }
            }
            var image = cubeImage[0],
                isImagePowerOfTwo = THREE.Math.isPowerOfTwo(image.width) && THREE.Math.isPowerOfTwo(image.height),
                glFormat = paramThreeToGL(texture.format),
                glType = paramThreeToGL(texture.type);
            setTextureParameters(_gl.TEXTURE_CUBE_MAP, texture, isImagePowerOfTwo);
            for (var i = 0; i < 6; i++) {
              if (!isCompressed) {
                if (isDataTexture) {
                  _gl.texImage2D(_gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, 0, glFormat, cubeImage[i].width, cubeImage[i].height, 0, glFormat, glType, cubeImage[i].data);
                } else {
                  _gl.texImage2D(_gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, 0, glFormat, glFormat, glType, cubeImage[i]);
                }
              } else {
                var mipmap,
                    mipmaps = cubeImage[i].mipmaps;
                for (var j = 0,
                    jl = mipmaps.length; j < jl; j++) {
                  mipmap = mipmaps[j];
                  if (texture.format !== THREE.RGBAFormat && texture.format !== THREE.RGBFormat) {
                    if (getCompressedTextureFormats().indexOf(glFormat) > -1) {
                      _gl.compressedTexImage2D(_gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, j, glFormat, mipmap.width, mipmap.height, 0, mipmap.data);
                    } else {
                      THREE.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setCubeTexture()");
                    }
                  } else {
                    _gl.texImage2D(_gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, j, glFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data);
                  }
                }
              }
            }
            if (texture.generateMipmaps && isImagePowerOfTwo) {
              _gl.generateMipmap(_gl.TEXTURE_CUBE_MAP);
            }
            texture.needsUpdate = false;
            if (texture.onUpdate)
              texture.onUpdate();
          } else {
            _gl.activeTexture(_gl.TEXTURE0 + slot);
            _gl.bindTexture(_gl.TEXTURE_CUBE_MAP, texture.image.__webglTextureCube);
          }
        }
      }
      function setCubeTextureDynamic(texture, slot) {
        _gl.activeTexture(_gl.TEXTURE0 + slot);
        _gl.bindTexture(_gl.TEXTURE_CUBE_MAP, texture.__webglTexture);
      }
      function setupFrameBuffer(framebuffer, renderTarget, textureTarget) {
        _gl.bindFramebuffer(_gl.FRAMEBUFFER, framebuffer);
        _gl.framebufferTexture2D(_gl.FRAMEBUFFER, _gl.COLOR_ATTACHMENT0, textureTarget, renderTarget.__webglTexture, 0);
      }
      function setupRenderBuffer(renderbuffer, renderTarget) {
        _gl.bindRenderbuffer(_gl.RENDERBUFFER, renderbuffer);
        if (renderTarget.depthBuffer && !renderTarget.stencilBuffer) {
          _gl.renderbufferStorage(_gl.RENDERBUFFER, _gl.DEPTH_COMPONENT16, renderTarget.width, renderTarget.height);
          _gl.framebufferRenderbuffer(_gl.FRAMEBUFFER, _gl.DEPTH_ATTACHMENT, _gl.RENDERBUFFER, renderbuffer);
        } else if (renderTarget.depthBuffer && renderTarget.stencilBuffer) {
          _gl.renderbufferStorage(_gl.RENDERBUFFER, _gl.DEPTH_STENCIL, renderTarget.width, renderTarget.height);
          _gl.framebufferRenderbuffer(_gl.FRAMEBUFFER, _gl.DEPTH_STENCIL_ATTACHMENT, _gl.RENDERBUFFER, renderbuffer);
        } else {
          _gl.renderbufferStorage(_gl.RENDERBUFFER, _gl.RGBA4, renderTarget.width, renderTarget.height);
        }
      }
      this.setRenderTarget = function(renderTarget) {
        var isCube = (renderTarget instanceof THREE.WebGLRenderTargetCube);
        if (renderTarget && renderTarget.__webglFramebuffer === undefined) {
          if (renderTarget.depthBuffer === undefined)
            renderTarget.depthBuffer = true;
          if (renderTarget.stencilBuffer === undefined)
            renderTarget.stencilBuffer = true;
          renderTarget.addEventListener('dispose', onRenderTargetDispose);
          renderTarget.__webglTexture = _gl.createTexture();
          _this.info.memory.textures++;
          var isTargetPowerOfTwo = THREE.Math.isPowerOfTwo(renderTarget.width) && THREE.Math.isPowerOfTwo(renderTarget.height),
              glFormat = paramThreeToGL(renderTarget.format),
              glType = paramThreeToGL(renderTarget.type);
          if (isCube) {
            renderTarget.__webglFramebuffer = [];
            renderTarget.__webglRenderbuffer = [];
            _gl.bindTexture(_gl.TEXTURE_CUBE_MAP, renderTarget.__webglTexture);
            setTextureParameters(_gl.TEXTURE_CUBE_MAP, renderTarget, isTargetPowerOfTwo);
            for (var i = 0; i < 6; i++) {
              renderTarget.__webglFramebuffer[i] = _gl.createFramebuffer();
              renderTarget.__webglRenderbuffer[i] = _gl.createRenderbuffer();
              _gl.texImage2D(_gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, 0, glFormat, renderTarget.width, renderTarget.height, 0, glFormat, glType, null);
              setupFrameBuffer(renderTarget.__webglFramebuffer[i], renderTarget, _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i);
              setupRenderBuffer(renderTarget.__webglRenderbuffer[i], renderTarget);
            }
            if (isTargetPowerOfTwo)
              _gl.generateMipmap(_gl.TEXTURE_CUBE_MAP);
          } else {
            renderTarget.__webglFramebuffer = _gl.createFramebuffer();
            if (renderTarget.shareDepthFrom) {
              renderTarget.__webglRenderbuffer = renderTarget.shareDepthFrom.__webglRenderbuffer;
            } else {
              renderTarget.__webglRenderbuffer = _gl.createRenderbuffer();
            }
            _gl.bindTexture(_gl.TEXTURE_2D, renderTarget.__webglTexture);
            setTextureParameters(_gl.TEXTURE_2D, renderTarget, isTargetPowerOfTwo);
            _gl.texImage2D(_gl.TEXTURE_2D, 0, glFormat, renderTarget.width, renderTarget.height, 0, glFormat, glType, null);
            setupFrameBuffer(renderTarget.__webglFramebuffer, renderTarget, _gl.TEXTURE_2D);
            if (renderTarget.shareDepthFrom) {
              if (renderTarget.depthBuffer && !renderTarget.stencilBuffer) {
                _gl.framebufferRenderbuffer(_gl.FRAMEBUFFER, _gl.DEPTH_ATTACHMENT, _gl.RENDERBUFFER, renderTarget.__webglRenderbuffer);
              } else if (renderTarget.depthBuffer && renderTarget.stencilBuffer) {
                _gl.framebufferRenderbuffer(_gl.FRAMEBUFFER, _gl.DEPTH_STENCIL_ATTACHMENT, _gl.RENDERBUFFER, renderTarget.__webglRenderbuffer);
              }
            } else {
              setupRenderBuffer(renderTarget.__webglRenderbuffer, renderTarget);
            }
            if (isTargetPowerOfTwo)
              _gl.generateMipmap(_gl.TEXTURE_2D);
          }
          if (isCube) {
            _gl.bindTexture(_gl.TEXTURE_CUBE_MAP, null);
          } else {
            _gl.bindTexture(_gl.TEXTURE_2D, null);
          }
          _gl.bindRenderbuffer(_gl.RENDERBUFFER, null);
          _gl.bindFramebuffer(_gl.FRAMEBUFFER, null);
        }
        var framebuffer,
            width,
            height,
            vx,
            vy;
        if (renderTarget) {
          if (isCube) {
            framebuffer = renderTarget.__webglFramebuffer[renderTarget.activeCubeFace];
          } else {
            framebuffer = renderTarget.__webglFramebuffer;
          }
          width = renderTarget.width;
          height = renderTarget.height;
          vx = 0;
          vy = 0;
        } else {
          framebuffer = null;
          width = _viewportWidth;
          height = _viewportHeight;
          vx = _viewportX;
          vy = _viewportY;
        }
        if (framebuffer !== _currentFramebuffer) {
          _gl.bindFramebuffer(_gl.FRAMEBUFFER, framebuffer);
          _gl.viewport(vx, vy, width, height);
          _currentFramebuffer = framebuffer;
        }
        _currentWidth = width;
        _currentHeight = height;
      };
      this.readRenderTargetPixels = function(renderTarget, x, y, width, height, buffer) {
        if (!(renderTarget instanceof THREE.WebGLRenderTarget)) {
          console.error('THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.');
          return ;
        }
        if (renderTarget.__webglFramebuffer) {
          if (renderTarget.format !== THREE.RGBAFormat) {
            console.error('THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA format. readPixels can read only RGBA format.');
            return ;
          }
          var restore = false;
          if (renderTarget.__webglFramebuffer !== _currentFramebuffer) {
            _gl.bindFramebuffer(_gl.FRAMEBUFFER, renderTarget.__webglFramebuffer);
            restore = true;
          }
          if (_gl.checkFramebufferStatus(_gl.FRAMEBUFFER) === _gl.FRAMEBUFFER_COMPLETE) {
            _gl.readPixels(x, y, width, height, _gl.RGBA, _gl.UNSIGNED_BYTE, buffer);
          } else {
            console.error('THREE.WebGLRenderer.readRenderTargetPixels: readPixels from renderTarget failed. Framebuffer not complete.');
          }
          if (restore) {
            _gl.bindFramebuffer(_gl.FRAMEBUFFER, _currentFramebuffer);
          }
        }
      };
      function updateRenderTargetMipmap(renderTarget) {
        if (renderTarget instanceof THREE.WebGLRenderTargetCube) {
          _gl.bindTexture(_gl.TEXTURE_CUBE_MAP, renderTarget.__webglTexture);
          _gl.generateMipmap(_gl.TEXTURE_CUBE_MAP);
          _gl.bindTexture(_gl.TEXTURE_CUBE_MAP, null);
        } else {
          _gl.bindTexture(_gl.TEXTURE_2D, renderTarget.__webglTexture);
          _gl.generateMipmap(_gl.TEXTURE_2D);
          _gl.bindTexture(_gl.TEXTURE_2D, null);
        }
      }
      function filterFallback(f) {
        if (f === THREE.NearestFilter || f === THREE.NearestMipMapNearestFilter || f === THREE.NearestMipMapLinearFilter) {
          return _gl.NEAREST;
        }
        return _gl.LINEAR;
      }
      function paramThreeToGL(p) {
        var extension;
        if (p === THREE.RepeatWrapping)
          return _gl.REPEAT;
        if (p === THREE.ClampToEdgeWrapping)
          return _gl.CLAMP_TO_EDGE;
        if (p === THREE.MirroredRepeatWrapping)
          return _gl.MIRRORED_REPEAT;
        if (p === THREE.NearestFilter)
          return _gl.NEAREST;
        if (p === THREE.NearestMipMapNearestFilter)
          return _gl.NEAREST_MIPMAP_NEAREST;
        if (p === THREE.NearestMipMapLinearFilter)
          return _gl.NEAREST_MIPMAP_LINEAR;
        if (p === THREE.LinearFilter)
          return _gl.LINEAR;
        if (p === THREE.LinearMipMapNearestFilter)
          return _gl.LINEAR_MIPMAP_NEAREST;
        if (p === THREE.LinearMipMapLinearFilter)
          return _gl.LINEAR_MIPMAP_LINEAR;
        if (p === THREE.UnsignedByteType)
          return _gl.UNSIGNED_BYTE;
        if (p === THREE.UnsignedShort4444Type)
          return _gl.UNSIGNED_SHORT_4_4_4_4;
        if (p === THREE.UnsignedShort5551Type)
          return _gl.UNSIGNED_SHORT_5_5_5_1;
        if (p === THREE.UnsignedShort565Type)
          return _gl.UNSIGNED_SHORT_5_6_5;
        if (p === THREE.ByteType)
          return _gl.BYTE;
        if (p === THREE.ShortType)
          return _gl.SHORT;
        if (p === THREE.UnsignedShortType)
          return _gl.UNSIGNED_SHORT;
        if (p === THREE.IntType)
          return _gl.INT;
        if (p === THREE.UnsignedIntType)
          return _gl.UNSIGNED_INT;
        if (p === THREE.FloatType)
          return _gl.FLOAT;
        extension = extensions.get('OES_texture_half_float');
        if (extension !== null) {
          if (p === THREE.HalfFloatType)
            return extension.HALF_FLOAT_OES;
        }
        if (p === THREE.AlphaFormat)
          return _gl.ALPHA;
        if (p === THREE.RGBFormat)
          return _gl.RGB;
        if (p === THREE.RGBAFormat)
          return _gl.RGBA;
        if (p === THREE.LuminanceFormat)
          return _gl.LUMINANCE;
        if (p === THREE.LuminanceAlphaFormat)
          return _gl.LUMINANCE_ALPHA;
        if (p === THREE.AddEquation)
          return _gl.FUNC_ADD;
        if (p === THREE.SubtractEquation)
          return _gl.FUNC_SUBTRACT;
        if (p === THREE.ReverseSubtractEquation)
          return _gl.FUNC_REVERSE_SUBTRACT;
        if (p === THREE.ZeroFactor)
          return _gl.ZERO;
        if (p === THREE.OneFactor)
          return _gl.ONE;
        if (p === THREE.SrcColorFactor)
          return _gl.SRC_COLOR;
        if (p === THREE.OneMinusSrcColorFactor)
          return _gl.ONE_MINUS_SRC_COLOR;
        if (p === THREE.SrcAlphaFactor)
          return _gl.SRC_ALPHA;
        if (p === THREE.OneMinusSrcAlphaFactor)
          return _gl.ONE_MINUS_SRC_ALPHA;
        if (p === THREE.DstAlphaFactor)
          return _gl.DST_ALPHA;
        if (p === THREE.OneMinusDstAlphaFactor)
          return _gl.ONE_MINUS_DST_ALPHA;
        if (p === THREE.DstColorFactor)
          return _gl.DST_COLOR;
        if (p === THREE.OneMinusDstColorFactor)
          return _gl.ONE_MINUS_DST_COLOR;
        if (p === THREE.SrcAlphaSaturateFactor)
          return _gl.SRC_ALPHA_SATURATE;
        extension = extensions.get('WEBGL_compressed_texture_s3tc');
        if (extension !== null) {
          if (p === THREE.RGB_S3TC_DXT1_Format)
            return extension.COMPRESSED_RGB_S3TC_DXT1_EXT;
          if (p === THREE.RGBA_S3TC_DXT1_Format)
            return extension.COMPRESSED_RGBA_S3TC_DXT1_EXT;
          if (p === THREE.RGBA_S3TC_DXT3_Format)
            return extension.COMPRESSED_RGBA_S3TC_DXT3_EXT;
          if (p === THREE.RGBA_S3TC_DXT5_Format)
            return extension.COMPRESSED_RGBA_S3TC_DXT5_EXT;
        }
        extension = extensions.get('WEBGL_compressed_texture_pvrtc');
        if (extension !== null) {
          if (p === THREE.RGB_PVRTC_4BPPV1_Format)
            return extension.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;
          if (p === THREE.RGB_PVRTC_2BPPV1_Format)
            return extension.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;
          if (p === THREE.RGBA_PVRTC_4BPPV1_Format)
            return extension.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;
          if (p === THREE.RGBA_PVRTC_2BPPV1_Format)
            return extension.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG;
        }
        extension = extensions.get('EXT_blend_minmax');
        if (extension !== null) {
          if (p === THREE.MinEquation)
            return extension.MIN_EXT;
          if (p === THREE.MaxEquation)
            return extension.MAX_EXT;
        }
        return 0;
      }
      function allocateBones(object) {
        if (_supportsBoneTextures && object && object.skeleton && object.skeleton.useVertexTexture) {
          return 1024;
        } else {
          var nVertexUniforms = _gl.getParameter(_gl.MAX_VERTEX_UNIFORM_VECTORS);
          var nVertexMatrices = Math.floor((nVertexUniforms - 20) / 4);
          var maxBones = nVertexMatrices;
          if (object !== undefined && object instanceof THREE.SkinnedMesh) {
            maxBones = Math.min(object.skeleton.bones.length, maxBones);
            if (maxBones < object.skeleton.bones.length) {
              THREE.warn('WebGLRenderer: too many bones - ' + object.skeleton.bones.length + ', this GPU supports just ' + maxBones + ' (try OpenGL instead of ANGLE)');
            }
          }
          return maxBones;
        }
      }
      function allocateLights(lights) {
        var dirLights = 0;
        var pointLights = 0;
        var spotLights = 0;
        var hemiLights = 0;
        for (var l = 0,
            ll = lights.length; l < ll; l++) {
          var light = lights[l];
          if (light.onlyShadow || light.visible === false)
            continue;
          if (light instanceof THREE.DirectionalLight)
            dirLights++;
          if (light instanceof THREE.PointLight)
            pointLights++;
          if (light instanceof THREE.SpotLight)
            spotLights++;
          if (light instanceof THREE.HemisphereLight)
            hemiLights++;
        }
        return {
          'directional': dirLights,
          'point': pointLights,
          'spot': spotLights,
          'hemi': hemiLights
        };
      }
      function allocateShadows(lights) {
        var maxShadows = 0;
        for (var l = 0,
            ll = lights.length; l < ll; l++) {
          var light = lights[l];
          if (!light.castShadow)
            continue;
          if (light instanceof THREE.SpotLight)
            maxShadows++;
          if (light instanceof THREE.DirectionalLight && !light.shadowCascade)
            maxShadows++;
        }
        return maxShadows;
      }
      this.initMaterial = function() {
        THREE.warn('THREE.WebGLRenderer: .initMaterial() has been removed.');
      };
      this.addPrePlugin = function() {
        THREE.warn('THREE.WebGLRenderer: .addPrePlugin() has been removed.');
      };
      this.addPostPlugin = function() {
        THREE.warn('THREE.WebGLRenderer: .addPostPlugin() has been removed.');
      };
      this.updateShadowMap = function() {
        THREE.warn('THREE.WebGLRenderer: .updateShadowMap() has been removed.');
      };
    };
    THREE.WebGLRenderTarget = function(width, height, options) {
      this.width = width;
      this.height = height;
      options = options || {};
      this.wrapS = options.wrapS !== undefined ? options.wrapS : THREE.ClampToEdgeWrapping;
      this.wrapT = options.wrapT !== undefined ? options.wrapT : THREE.ClampToEdgeWrapping;
      this.magFilter = options.magFilter !== undefined ? options.magFilter : THREE.LinearFilter;
      this.minFilter = options.minFilter !== undefined ? options.minFilter : THREE.LinearMipMapLinearFilter;
      this.anisotropy = options.anisotropy !== undefined ? options.anisotropy : 1;
      this.offset = new THREE.Vector2(0, 0);
      this.repeat = new THREE.Vector2(1, 1);
      this.format = options.format !== undefined ? options.format : THREE.RGBAFormat;
      this.type = options.type !== undefined ? options.type : THREE.UnsignedByteType;
      this.depthBuffer = options.depthBuffer !== undefined ? options.depthBuffer : true;
      this.stencilBuffer = options.stencilBuffer !== undefined ? options.stencilBuffer : true;
      this.generateMipmaps = true;
      this.shareDepthFrom = options.shareDepthFrom !== undefined ? options.shareDepthFrom : null;
    };
    THREE.WebGLRenderTarget.prototype = {
      constructor: THREE.WebGLRenderTarget,
      setSize: function(width, height) {
        this.width = width;
        this.height = height;
      },
      clone: function() {
        var tmp = new THREE.WebGLRenderTarget(this.width, this.height);
        tmp.wrapS = this.wrapS;
        tmp.wrapT = this.wrapT;
        tmp.magFilter = this.magFilter;
        tmp.minFilter = this.minFilter;
        tmp.anisotropy = this.anisotropy;
        tmp.offset.copy(this.offset);
        tmp.repeat.copy(this.repeat);
        tmp.format = this.format;
        tmp.type = this.type;
        tmp.depthBuffer = this.depthBuffer;
        tmp.stencilBuffer = this.stencilBuffer;
        tmp.generateMipmaps = this.generateMipmaps;
        tmp.shareDepthFrom = this.shareDepthFrom;
        return tmp;
      },
      dispose: function() {
        this.dispatchEvent({type: 'dispose'});
      }
    };
    THREE.EventDispatcher.prototype.apply(THREE.WebGLRenderTarget.prototype);
    THREE.WebGLRenderTargetCube = function(width, height, options) {
      THREE.WebGLRenderTarget.call(this, width, height, options);
      this.activeCubeFace = 0;
    };
    THREE.WebGLRenderTargetCube.prototype = Object.create(THREE.WebGLRenderTarget.prototype);
    THREE.WebGLRenderTargetCube.prototype.constructor = THREE.WebGLRenderTargetCube;
    THREE.WebGLExtensions = function(gl) {
      var extensions = {};
      this.get = function(name) {
        if (extensions[name] !== undefined) {
          return extensions[name];
        }
        var extension;
        switch (name) {
          case 'EXT_texture_filter_anisotropic':
            extension = gl.getExtension('EXT_texture_filter_anisotropic') || gl.getExtension('MOZ_EXT_texture_filter_anisotropic') || gl.getExtension('WEBKIT_EXT_texture_filter_anisotropic');
            break;
          case 'WEBGL_compressed_texture_s3tc':
            extension = gl.getExtension('WEBGL_compressed_texture_s3tc') || gl.getExtension('MOZ_WEBGL_compressed_texture_s3tc') || gl.getExtension('WEBKIT_WEBGL_compressed_texture_s3tc');
            break;
          case 'WEBGL_compressed_texture_pvrtc':
            extension = gl.getExtension('WEBGL_compressed_texture_pvrtc') || gl.getExtension('WEBKIT_WEBGL_compressed_texture_pvrtc');
            break;
          default:
            extension = gl.getExtension(name);
        }
        if (extension === null) {
          THREE.warn('THREE.WebGLRenderer: ' + name + ' extension not supported.');
        }
        extensions[name] = extension;
        return extension;
      };
    };
    THREE.WebGLProgram = (function() {
      var programIdCount = 0;
      var generateDefines = function(defines) {
        var value,
            chunk,
            chunks = [];
        for (var d in defines) {
          value = defines[d];
          if (value === false)
            continue;
          chunk = '#define ' + d + ' ' + value;
          chunks.push(chunk);
        }
        return chunks.join('\n');
      };
      var cacheUniformLocations = function(gl, program, identifiers) {
        var uniforms = {};
        for (var i = 0,
            l = identifiers.length; i < l; i++) {
          var id = identifiers[i];
          uniforms[id] = gl.getUniformLocation(program, id);
        }
        return uniforms;
      };
      var cacheAttributeLocations = function(gl, program, identifiers) {
        var attributes = {};
        for (var i = 0,
            l = identifiers.length; i < l; i++) {
          var id = identifiers[i];
          attributes[id] = gl.getAttribLocation(program, id);
        }
        return attributes;
      };
      return function(renderer, code, material, parameters) {
        var _this = renderer;
        var _gl = _this.context;
        var defines = material.defines;
        var uniforms = material.__webglShader.uniforms;
        var attributes = material.attributes;
        var vertexShader = material.__webglShader.vertexShader;
        var fragmentShader = material.__webglShader.fragmentShader;
        var index0AttributeName = material.index0AttributeName;
        if (index0AttributeName === undefined && parameters.morphTargets === true) {
          index0AttributeName = 'position';
        }
        var shadowMapTypeDefine = 'SHADOWMAP_TYPE_BASIC';
        if (parameters.shadowMapType === THREE.PCFShadowMap) {
          shadowMapTypeDefine = 'SHADOWMAP_TYPE_PCF';
        } else if (parameters.shadowMapType === THREE.PCFSoftShadowMap) {
          shadowMapTypeDefine = 'SHADOWMAP_TYPE_PCF_SOFT';
        }
        var envMapTypeDefine = 'ENVMAP_TYPE_CUBE';
        var envMapModeDefine = 'ENVMAP_MODE_REFLECTION';
        var envMapBlendingDefine = 'ENVMAP_BLENDING_MULTIPLY';
        if (parameters.envMap) {
          switch (material.envMap.mapping) {
            case THREE.CubeReflectionMapping:
            case THREE.CubeRefractionMapping:
              envMapTypeDefine = 'ENVMAP_TYPE_CUBE';
              break;
            case THREE.EquirectangularReflectionMapping:
            case THREE.EquirectangularRefractionMapping:
              envMapTypeDefine = 'ENVMAP_TYPE_EQUIREC';
              break;
            case THREE.SphericalReflectionMapping:
              envMapTypeDefine = 'ENVMAP_TYPE_SPHERE';
              break;
          }
          switch (material.envMap.mapping) {
            case THREE.CubeRefractionMapping:
            case THREE.EquirectangularRefractionMapping:
              envMapModeDefine = 'ENVMAP_MODE_REFRACTION';
              break;
          }
          switch (material.combine) {
            case THREE.MultiplyOperation:
              envMapBlendingDefine = 'ENVMAP_BLENDING_MULTIPLY';
              break;
            case THREE.MixOperation:
              envMapBlendingDefine = 'ENVMAP_BLENDING_MIX';
              break;
            case THREE.AddOperation:
              envMapBlendingDefine = 'ENVMAP_BLENDING_ADD';
              break;
          }
        }
        var gammaFactorDefine = (renderer.gammaFactor > 0) ? renderer.gammaFactor : 1.0;
        var customDefines = generateDefines(defines);
        var program = _gl.createProgram();
        var prefix_vertex,
            prefix_fragment;
        if (material instanceof THREE.RawShaderMaterial) {
          prefix_vertex = '';
          prefix_fragment = '';
        } else {
          prefix_vertex = ['precision ' + parameters.precision + ' float;', 'precision ' + parameters.precision + ' int;', customDefines, parameters.supportsVertexTextures ? '#define VERTEX_TEXTURES' : '', _this.gammaInput ? '#define GAMMA_INPUT' : '', _this.gammaOutput ? '#define GAMMA_OUTPUT' : '', '#define GAMMA_FACTOR ' + gammaFactorDefine, '#define MAX_DIR_LIGHTS ' + parameters.maxDirLights, '#define MAX_POINT_LIGHTS ' + parameters.maxPointLights, '#define MAX_SPOT_LIGHTS ' + parameters.maxSpotLights, '#define MAX_HEMI_LIGHTS ' + parameters.maxHemiLights, '#define MAX_SHADOWS ' + parameters.maxShadows, '#define MAX_BONES ' + parameters.maxBones, parameters.map ? '#define USE_MAP' : '', parameters.envMap ? '#define USE_ENVMAP' : '', parameters.envMap ? '#define ' + envMapModeDefine : '', parameters.lightMap ? '#define USE_LIGHTMAP' : '', parameters.bumpMap ? '#define USE_BUMPMAP' : '', parameters.normalMap ? '#define USE_NORMALMAP' : '', parameters.specularMap ? '#define USE_SPECULARMAP' : '', parameters.alphaMap ? '#define USE_ALPHAMAP' : '', parameters.vertexColors ? '#define USE_COLOR' : '', parameters.flatShading ? '#define FLAT_SHADED' : '', parameters.skinning ? '#define USE_SKINNING' : '', parameters.useVertexTexture ? '#define BONE_TEXTURE' : '', parameters.morphTargets ? '#define USE_MORPHTARGETS' : '', parameters.morphNormals ? '#define USE_MORPHNORMALS' : '', parameters.wrapAround ? '#define WRAP_AROUND' : '', parameters.doubleSided ? '#define DOUBLE_SIDED' : '', parameters.flipSided ? '#define FLIP_SIDED' : '', parameters.shadowMapEnabled ? '#define USE_SHADOWMAP' : '', parameters.shadowMapEnabled ? '#define ' + shadowMapTypeDefine : '', parameters.shadowMapDebug ? '#define SHADOWMAP_DEBUG' : '', parameters.shadowMapCascade ? '#define SHADOWMAP_CASCADE' : '', parameters.sizeAttenuation ? '#define USE_SIZEATTENUATION' : '', parameters.logarithmicDepthBuffer ? '#define USE_LOGDEPTHBUF' : '', 'uniform mat4 modelMatrix;', 'uniform mat4 modelViewMatrix;', 'uniform mat4 projectionMatrix;', 'uniform mat4 viewMatrix;', 'uniform mat3 normalMatrix;', 'uniform vec3 cameraPosition;', 'attribute vec3 position;', 'attribute vec3 normal;', 'attribute vec2 uv;', 'attribute vec2 uv2;', '#ifdef USE_COLOR', '	attribute vec3 color;', '#endif', '#ifdef USE_MORPHTARGETS', '	attribute vec3 morphTarget0;', '	attribute vec3 morphTarget1;', '	attribute vec3 morphTarget2;', '	attribute vec3 morphTarget3;', '	#ifdef USE_MORPHNORMALS', '		attribute vec3 morphNormal0;', '		attribute vec3 morphNormal1;', '		attribute vec3 morphNormal2;', '		attribute vec3 morphNormal3;', '	#else', '		attribute vec3 morphTarget4;', '		attribute vec3 morphTarget5;', '		attribute vec3 morphTarget6;', '		attribute vec3 morphTarget7;', '	#endif', '#endif', '#ifdef USE_SKINNING', '	attribute vec4 skinIndex;', '	attribute vec4 skinWeight;', '#endif', ''].join('\n');
          prefix_fragment = ['precision ' + parameters.precision + ' float;', 'precision ' + parameters.precision + ' int;', (parameters.bumpMap || parameters.normalMap || parameters.flatShading) ? '#extension GL_OES_standard_derivatives : enable' : '', customDefines, '#define MAX_DIR_LIGHTS ' + parameters.maxDirLights, '#define MAX_POINT_LIGHTS ' + parameters.maxPointLights, '#define MAX_SPOT_LIGHTS ' + parameters.maxSpotLights, '#define MAX_HEMI_LIGHTS ' + parameters.maxHemiLights, '#define MAX_SHADOWS ' + parameters.maxShadows, parameters.alphaTest ? '#define ALPHATEST ' + parameters.alphaTest : '', _this.gammaInput ? '#define GAMMA_INPUT' : '', _this.gammaOutput ? '#define GAMMA_OUTPUT' : '', '#define GAMMA_FACTOR ' + gammaFactorDefine, (parameters.useFog && parameters.fog) ? '#define USE_FOG' : '', (parameters.useFog && parameters.fogExp) ? '#define FOG_EXP2' : '', parameters.map ? '#define USE_MAP' : '', parameters.envMap ? '#define USE_ENVMAP' : '', parameters.envMap ? '#define ' + envMapTypeDefine : '', parameters.envMap ? '#define ' + envMapModeDefine : '', parameters.envMap ? '#define ' + envMapBlendingDefine : '', parameters.lightMap ? '#define USE_LIGHTMAP' : '', parameters.bumpMap ? '#define USE_BUMPMAP' : '', parameters.normalMap ? '#define USE_NORMALMAP' : '', parameters.specularMap ? '#define USE_SPECULARMAP' : '', parameters.alphaMap ? '#define USE_ALPHAMAP' : '', parameters.vertexColors ? '#define USE_COLOR' : '', parameters.flatShading ? '#define FLAT_SHADED' : '', parameters.metal ? '#define METAL' : '', parameters.wrapAround ? '#define WRAP_AROUND' : '', parameters.doubleSided ? '#define DOUBLE_SIDED' : '', parameters.flipSided ? '#define FLIP_SIDED' : '', parameters.shadowMapEnabled ? '#define USE_SHADOWMAP' : '', parameters.shadowMapEnabled ? '#define ' + shadowMapTypeDefine : '', parameters.shadowMapDebug ? '#define SHADOWMAP_DEBUG' : '', parameters.shadowMapCascade ? '#define SHADOWMAP_CASCADE' : '', parameters.logarithmicDepthBuffer ? '#define USE_LOGDEPTHBUF' : '', 'uniform mat4 viewMatrix;', 'uniform vec3 cameraPosition;', ''].join('\n');
        }
        var glVertexShader = new THREE.WebGLShader(_gl, _gl.VERTEX_SHADER, prefix_vertex + vertexShader);
        var glFragmentShader = new THREE.WebGLShader(_gl, _gl.FRAGMENT_SHADER, prefix_fragment + fragmentShader);
        _gl.attachShader(program, glVertexShader);
        _gl.attachShader(program, glFragmentShader);
        if (index0AttributeName !== undefined) {
          _gl.bindAttribLocation(program, 0, index0AttributeName);
        }
        _gl.linkProgram(program);
        var programLogInfo = _gl.getProgramInfoLog(program);
        if (_gl.getProgramParameter(program, _gl.LINK_STATUS) === false) {
          THREE.error('THREE.WebGLProgram: shader error: ' + _gl.getError(), 'gl.VALIDATE_STATUS', _gl.getProgramParameter(program, _gl.VALIDATE_STATUS), 'gl.getPRogramInfoLog', programLogInfo);
        }
        if (programLogInfo !== '') {
          THREE.warn('THREE.WebGLProgram: gl.getProgramInfoLog()' + programLogInfo);
        }
        _gl.deleteShader(glVertexShader);
        _gl.deleteShader(glFragmentShader);
        var identifiers = ['viewMatrix', 'modelViewMatrix', 'projectionMatrix', 'normalMatrix', 'modelMatrix', 'cameraPosition', 'morphTargetInfluences', 'bindMatrix', 'bindMatrixInverse'];
        if (parameters.useVertexTexture) {
          identifiers.push('boneTexture');
          identifiers.push('boneTextureWidth');
          identifiers.push('boneTextureHeight');
        } else {
          identifiers.push('boneGlobalMatrices');
        }
        if (parameters.logarithmicDepthBuffer) {
          identifiers.push('logDepthBufFC');
        }
        for (var u in uniforms) {
          identifiers.push(u);
        }
        this.uniforms = cacheUniformLocations(_gl, program, identifiers);
        identifiers = ['position', 'normal', 'uv', 'uv2', 'tangent', 'color', 'skinIndex', 'skinWeight', 'lineDistance'];
        for (var i = 0; i < parameters.maxMorphTargets; i++) {
          identifiers.push('morphTarget' + i);
        }
        for (var i = 0; i < parameters.maxMorphNormals; i++) {
          identifiers.push('morphNormal' + i);
        }
        for (var a in attributes) {
          identifiers.push(a);
        }
        this.attributes = cacheAttributeLocations(_gl, program, identifiers);
        this.attributesKeys = Object.keys(this.attributes);
        this.id = programIdCount++;
        this.code = code;
        this.usedTimes = 1;
        this.program = program;
        this.vertexShader = glVertexShader;
        this.fragmentShader = glFragmentShader;
        return this;
      };
    })();
    THREE.WebGLShader = (function() {
      var addLineNumbers = function(string) {
        var lines = string.split('\n');
        for (var i = 0; i < lines.length; i++) {
          lines[i] = (i + 1) + ': ' + lines[i];
        }
        return lines.join('\n');
      };
      return function(gl, type, string) {
        var shader = gl.createShader(type);
        gl.shaderSource(shader, string);
        gl.compileShader(shader);
        if (gl.getShaderParameter(shader, gl.COMPILE_STATUS) === false) {
          THREE.error('THREE.WebGLShader: Shader couldn\'t compile.');
        }
        if (gl.getShaderInfoLog(shader) !== '') {
          THREE.warn('THREE.WebGLShader: gl.getShaderInfoLog()', gl.getShaderInfoLog(shader), addLineNumbers(string));
        }
        return shader;
      };
    })();
    THREE.WebGLState = function(gl, paramThreeToGL) {
      var newAttributes = new Uint8Array(16);
      var enabledAttributes = new Uint8Array(16);
      var currentBlending = null;
      var currentBlendEquation = null;
      var currentBlendSrc = null;
      var currentBlendDst = null;
      var currentBlendEquationAlpha = null;
      var currentBlendSrcAlpha = null;
      var currentBlendDstAlpha = null;
      var currentDepthTest = null;
      var currentDepthWrite = null;
      var currentColorWrite = null;
      var currentDoubleSided = null;
      var currentFlipSided = null;
      var currentLineWidth = null;
      var currentPolygonOffset = null;
      var currentPolygonOffsetFactor = null;
      var currentPolygonOffsetUnits = null;
      this.initAttributes = function() {
        for (var i = 0,
            l = newAttributes.length; i < l; i++) {
          newAttributes[i] = 0;
        }
      };
      this.enableAttribute = function(attribute) {
        newAttributes[attribute] = 1;
        if (enabledAttributes[attribute] === 0) {
          gl.enableVertexAttribArray(attribute);
          enabledAttributes[attribute] = 1;
        }
      };
      this.disableUnusedAttributes = function() {
        for (var i = 0,
            l = enabledAttributes.length; i < l; i++) {
          if (enabledAttributes[i] !== newAttributes[i]) {
            gl.disableVertexAttribArray(i);
            enabledAttributes[i] = 0;
          }
        }
      };
      this.setBlending = function(blending, blendEquation, blendSrc, blendDst, blendEquationAlpha, blendSrcAlpha, blendDstAlpha) {
        if (blending !== currentBlending) {
          if (blending === THREE.NoBlending) {
            gl.disable(gl.BLEND);
          } else if (blending === THREE.AdditiveBlending) {
            gl.enable(gl.BLEND);
            gl.blendEquation(gl.FUNC_ADD);
            gl.blendFunc(gl.SRC_ALPHA, gl.ONE);
          } else if (blending === THREE.SubtractiveBlending) {
            gl.enable(gl.BLEND);
            gl.blendEquation(gl.FUNC_ADD);
            gl.blendFunc(gl.ZERO, gl.ONE_MINUS_SRC_COLOR);
          } else if (blending === THREE.MultiplyBlending) {
            gl.enable(gl.BLEND);
            gl.blendEquation(gl.FUNC_ADD);
            gl.blendFunc(gl.ZERO, gl.SRC_COLOR);
          } else if (blending === THREE.CustomBlending) {
            gl.enable(gl.BLEND);
          } else {
            gl.enable(gl.BLEND);
            gl.blendEquationSeparate(gl.FUNC_ADD, gl.FUNC_ADD);
            gl.blendFuncSeparate(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA, gl.ONE, gl.ONE_MINUS_SRC_ALPHA);
          }
          currentBlending = blending;
        }
        if (blending === THREE.CustomBlending) {
          blendEquationAlpha = blendEquationAlpha || blendEquation;
          blendSrcAlpha = blendSrcAlpha || blendSrc;
          blendDstAlpha = blendDstAlpha || blendDst;
          if (blendEquation !== currentBlendEquation || blendEquationAlpha !== currentBlendEquationAlpha) {
            gl.blendEquationSeparate(paramThreeToGL(blendEquation), paramThreeToGL(blendEquationAlpha));
            currentBlendEquation = blendEquation;
            currentBlendEquationAlpha = blendEquationAlpha;
          }
          if (blendSrc !== currentBlendSrc || blendDst !== currentBlendDst || blendSrcAlpha !== currentBlendSrcAlpha || blendDstAlpha !== currentBlendDstAlpha) {
            gl.blendFuncSeparate(paramThreeToGL(blendSrc), paramThreeToGL(blendDst), paramThreeToGL(blendSrcAlpha), paramThreeToGL(blendDstAlpha));
            currentBlendSrc = blendSrc;
            currentBlendDst = blendDst;
            currentBlendSrcAlpha = blendSrcAlpha;
            currentBlendDstAlpha = blendDstAlpha;
          }
        } else {
          currentBlendEquation = null;
          currentBlendSrc = null;
          currentBlendDst = null;
          currentBlendEquationAlpha = null;
          currentBlendSrcAlpha = null;
          currentBlendDstAlpha = null;
        }
      };
      this.setDepthTest = function(depthTest) {
        if (currentDepthTest !== depthTest) {
          if (depthTest) {
            gl.enable(gl.DEPTH_TEST);
          } else {
            gl.disable(gl.DEPTH_TEST);
          }
          currentDepthTest = depthTest;
        }
      };
      this.setDepthWrite = function(depthWrite) {
        if (currentDepthWrite !== depthWrite) {
          gl.depthMask(depthWrite);
          currentDepthWrite = depthWrite;
        }
      };
      this.setColorWrite = function(colorWrite) {
        if (currentColorWrite !== colorWrite) {
          gl.colorMask(colorWrite, colorWrite, colorWrite, colorWrite);
          currentColorWrite = colorWrite;
        }
      };
      this.setDoubleSided = function(doubleSided) {
        if (currentDoubleSided !== doubleSided) {
          if (doubleSided) {
            gl.disable(gl.CULL_FACE);
          } else {
            gl.enable(gl.CULL_FACE);
          }
          currentDoubleSided = doubleSided;
        }
      };
      this.setFlipSided = function(flipSided) {
        if (currentFlipSided !== flipSided) {
          if (flipSided) {
            gl.frontFace(gl.CW);
          } else {
            gl.frontFace(gl.CCW);
          }
          currentFlipSided = flipSided;
        }
      };
      this.setLineWidth = function(width) {
        if (width !== currentLineWidth) {
          gl.lineWidth(width);
          currentLineWidth = width;
        }
      };
      this.setPolygonOffset = function(polygonoffset, factor, units) {
        if (currentPolygonOffset !== polygonoffset) {
          if (polygonoffset) {
            gl.enable(gl.POLYGON_OFFSET_FILL);
          } else {
            gl.disable(gl.POLYGON_OFFSET_FILL);
          }
          currentPolygonOffset = polygonoffset;
        }
        if (polygonoffset && (currentPolygonOffsetFactor !== factor || currentPolygonOffsetUnits !== units)) {
          gl.polygonOffset(factor, units);
          currentPolygonOffsetFactor = factor;
          currentPolygonOffsetUnits = units;
        }
      };
      this.reset = function() {
        for (var i = 0; i < enabledAttributes.length; i++) {
          enabledAttributes[i] = 0;
        }
        currentBlending = null;
        currentDepthTest = null;
        currentDepthWrite = null;
        currentColorWrite = null;
        currentDoubleSided = null;
        currentFlipSided = null;
      };
    };
    THREE.LensFlarePlugin = function(renderer, flares) {
      var gl = renderer.context;
      var vertexBuffer,
          elementBuffer;
      var program,
          attributes,
          uniforms;
      var hasVertexTexture;
      var tempTexture,
          occlusionTexture;
      var init = function() {
        var vertices = new Float32Array([-1, -1, 0, 0, 1, -1, 1, 0, 1, 1, 1, 1, -1, 1, 0, 1]);
        var faces = new Uint16Array([0, 1, 2, 0, 2, 3]);
        vertexBuffer = gl.createBuffer();
        elementBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, vertexBuffer);
        gl.bufferData(gl.ARRAY_BUFFER, vertices, gl.STATIC_DRAW);
        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, elementBuffer);
        gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, faces, gl.STATIC_DRAW);
        tempTexture = gl.createTexture();
        occlusionTexture = gl.createTexture();
        gl.bindTexture(gl.TEXTURE_2D, tempTexture);
        gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGB, 16, 16, 0, gl.RGB, gl.UNSIGNED_BYTE, null);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
        gl.bindTexture(gl.TEXTURE_2D, occlusionTexture);
        gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, 16, 16, 0, gl.RGBA, gl.UNSIGNED_BYTE, null);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
        hasVertexTexture = gl.getParameter(gl.MAX_VERTEX_TEXTURE_IMAGE_UNITS) > 0;
        var shader;
        if (hasVertexTexture) {
          shader = {
            vertexShader: ["uniform lowp int renderType;", "uniform vec3 screenPosition;", "uniform vec2 scale;", "uniform float rotation;", "uniform sampler2D occlusionMap;", "attribute vec2 position;", "attribute vec2 uv;", "varying vec2 vUV;", "varying float vVisibility;", "void main() {", "vUV = uv;", "vec2 pos = position;", "if( renderType == 2 ) {", "vec4 visibility = texture2D( occlusionMap, vec2( 0.1, 0.1 ) );", "visibility += texture2D( occlusionMap, vec2( 0.5, 0.1 ) );", "visibility += texture2D( occlusionMap, vec2( 0.9, 0.1 ) );", "visibility += texture2D( occlusionMap, vec2( 0.9, 0.5 ) );", "visibility += texture2D( occlusionMap, vec2( 0.9, 0.9 ) );", "visibility += texture2D( occlusionMap, vec2( 0.5, 0.9 ) );", "visibility += texture2D( occlusionMap, vec2( 0.1, 0.9 ) );", "visibility += texture2D( occlusionMap, vec2( 0.1, 0.5 ) );", "visibility += texture2D( occlusionMap, vec2( 0.5, 0.5 ) );", "vVisibility =        visibility.r / 9.0;", "vVisibility *= 1.0 - visibility.g / 9.0;", "vVisibility *=       visibility.b / 9.0;", "vVisibility *= 1.0 - visibility.a / 9.0;", "pos.x = cos( rotation ) * position.x - sin( rotation ) * position.y;", "pos.y = sin( rotation ) * position.x + cos( rotation ) * position.y;", "}", "gl_Position = vec4( ( pos * scale + screenPosition.xy ).xy, screenPosition.z, 1.0 );", "}"].join("\n"),
            fragmentShader: ["uniform lowp int renderType;", "uniform sampler2D map;", "uniform float opacity;", "uniform vec3 color;", "varying vec2 vUV;", "varying float vVisibility;", "void main() {", "if( renderType == 0 ) {", "gl_FragColor = vec4( 1.0, 0.0, 1.0, 0.0 );", "} else if( renderType == 1 ) {", "gl_FragColor = texture2D( map, vUV );", "} else {", "vec4 texture = texture2D( map, vUV );", "texture.a *= opacity * vVisibility;", "gl_FragColor = texture;", "gl_FragColor.rgb *= color;", "}", "}"].join("\n")
          };
        } else {
          shader = {
            vertexShader: ["uniform lowp int renderType;", "uniform vec3 screenPosition;", "uniform vec2 scale;", "uniform float rotation;", "attribute vec2 position;", "attribute vec2 uv;", "varying vec2 vUV;", "void main() {", "vUV = uv;", "vec2 pos = position;", "if( renderType == 2 ) {", "pos.x = cos( rotation ) * position.x - sin( rotation ) * position.y;", "pos.y = sin( rotation ) * position.x + cos( rotation ) * position.y;", "}", "gl_Position = vec4( ( pos * scale + screenPosition.xy ).xy, screenPosition.z, 1.0 );", "}"].join("\n"),
            fragmentShader: ["precision mediump float;", "uniform lowp int renderType;", "uniform sampler2D map;", "uniform sampler2D occlusionMap;", "uniform float opacity;", "uniform vec3 color;", "varying vec2 vUV;", "void main() {", "if( renderType == 0 ) {", "gl_FragColor = vec4( texture2D( map, vUV ).rgb, 0.0 );", "} else if( renderType == 1 ) {", "gl_FragColor = texture2D( map, vUV );", "} else {", "float visibility = texture2D( occlusionMap, vec2( 0.5, 0.1 ) ).a;", "visibility += texture2D( occlusionMap, vec2( 0.9, 0.5 ) ).a;", "visibility += texture2D( occlusionMap, vec2( 0.5, 0.9 ) ).a;", "visibility += texture2D( occlusionMap, vec2( 0.1, 0.5 ) ).a;", "visibility = ( 1.0 - visibility / 4.0 );", "vec4 texture = texture2D( map, vUV );", "texture.a *= opacity * visibility;", "gl_FragColor = texture;", "gl_FragColor.rgb *= color;", "}", "}"].join("\n")
          };
        }
        program = createProgram(shader);
        attributes = {
          vertex: gl.getAttribLocation(program, "position"),
          uv: gl.getAttribLocation(program, "uv")
        };
        uniforms = {
          renderType: gl.getUniformLocation(program, "renderType"),
          map: gl.getUniformLocation(program, "map"),
          occlusionMap: gl.getUniformLocation(program, "occlusionMap"),
          opacity: gl.getUniformLocation(program, "opacity"),
          color: gl.getUniformLocation(program, "color"),
          scale: gl.getUniformLocation(program, "scale"),
          rotation: gl.getUniformLocation(program, "rotation"),
          screenPosition: gl.getUniformLocation(program, "screenPosition")
        };
      };
      this.render = function(scene, camera, viewportWidth, viewportHeight) {
        if (flares.length === 0)
          return ;
        var tempPosition = new THREE.Vector3();
        var invAspect = viewportHeight / viewportWidth,
            halfViewportWidth = viewportWidth * 0.5,
            halfViewportHeight = viewportHeight * 0.5;
        var size = 16 / viewportHeight,
            scale = new THREE.Vector2(size * invAspect, size);
        var screenPosition = new THREE.Vector3(1, 1, 0),
            screenPositionPixels = new THREE.Vector2(1, 1);
        if (program === undefined) {
          init();
        }
        gl.useProgram(program);
        gl.enableVertexAttribArray(attributes.vertex);
        gl.enableVertexAttribArray(attributes.uv);
        gl.uniform1i(uniforms.occlusionMap, 0);
        gl.uniform1i(uniforms.map, 1);
        gl.bindBuffer(gl.ARRAY_BUFFER, vertexBuffer);
        gl.vertexAttribPointer(attributes.vertex, 2, gl.FLOAT, false, 2 * 8, 0);
        gl.vertexAttribPointer(attributes.uv, 2, gl.FLOAT, false, 2 * 8, 8);
        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, elementBuffer);
        gl.disable(gl.CULL_FACE);
        gl.depthMask(false);
        for (var i = 0,
            l = flares.length; i < l; i++) {
          size = 16 / viewportHeight;
          scale.set(size * invAspect, size);
          var flare = flares[i];
          tempPosition.set(flare.matrixWorld.elements[12], flare.matrixWorld.elements[13], flare.matrixWorld.elements[14]);
          tempPosition.applyMatrix4(camera.matrixWorldInverse);
          tempPosition.applyProjection(camera.projectionMatrix);
          screenPosition.copy(tempPosition);
          screenPositionPixels.x = screenPosition.x * halfViewportWidth + halfViewportWidth;
          screenPositionPixels.y = screenPosition.y * halfViewportHeight + halfViewportHeight;
          if (hasVertexTexture || (screenPositionPixels.x > 0 && screenPositionPixels.x < viewportWidth && screenPositionPixels.y > 0 && screenPositionPixels.y < viewportHeight)) {
            gl.activeTexture(gl.TEXTURE1);
            gl.bindTexture(gl.TEXTURE_2D, tempTexture);
            gl.copyTexImage2D(gl.TEXTURE_2D, 0, gl.RGB, screenPositionPixels.x - 8, screenPositionPixels.y - 8, 16, 16, 0);
            gl.uniform1i(uniforms.renderType, 0);
            gl.uniform2f(uniforms.scale, scale.x, scale.y);
            gl.uniform3f(uniforms.screenPosition, screenPosition.x, screenPosition.y, screenPosition.z);
            gl.disable(gl.BLEND);
            gl.enable(gl.DEPTH_TEST);
            gl.drawElements(gl.TRIANGLES, 6, gl.UNSIGNED_SHORT, 0);
            gl.activeTexture(gl.TEXTURE0);
            gl.bindTexture(gl.TEXTURE_2D, occlusionTexture);
            gl.copyTexImage2D(gl.TEXTURE_2D, 0, gl.RGBA, screenPositionPixels.x - 8, screenPositionPixels.y - 8, 16, 16, 0);
            gl.uniform1i(uniforms.renderType, 1);
            gl.disable(gl.DEPTH_TEST);
            gl.activeTexture(gl.TEXTURE1);
            gl.bindTexture(gl.TEXTURE_2D, tempTexture);
            gl.drawElements(gl.TRIANGLES, 6, gl.UNSIGNED_SHORT, 0);
            flare.positionScreen.copy(screenPosition);
            if (flare.customUpdateCallback) {
              flare.customUpdateCallback(flare);
            } else {
              flare.updateLensFlares();
            }
            gl.uniform1i(uniforms.renderType, 2);
            gl.enable(gl.BLEND);
            for (var j = 0,
                jl = flare.lensFlares.length; j < jl; j++) {
              var sprite = flare.lensFlares[j];
              if (sprite.opacity > 0.001 && sprite.scale > 0.001) {
                screenPosition.x = sprite.x;
                screenPosition.y = sprite.y;
                screenPosition.z = sprite.z;
                size = sprite.size * sprite.scale / viewportHeight;
                scale.x = size * invAspect;
                scale.y = size;
                gl.uniform3f(uniforms.screenPosition, screenPosition.x, screenPosition.y, screenPosition.z);
                gl.uniform2f(uniforms.scale, scale.x, scale.y);
                gl.uniform1f(uniforms.rotation, sprite.rotation);
                gl.uniform1f(uniforms.opacity, sprite.opacity);
                gl.uniform3f(uniforms.color, sprite.color.r, sprite.color.g, sprite.color.b);
                renderer.state.setBlending(sprite.blending, sprite.blendEquation, sprite.blendSrc, sprite.blendDst);
                renderer.setTexture(sprite.texture, 1);
                gl.drawElements(gl.TRIANGLES, 6, gl.UNSIGNED_SHORT, 0);
              }
            }
          }
        }
        gl.enable(gl.CULL_FACE);
        gl.enable(gl.DEPTH_TEST);
        gl.depthMask(true);
        renderer.resetGLState();
      };
      function createProgram(shader) {
        var program = gl.createProgram();
        var fragmentShader = gl.createShader(gl.FRAGMENT_SHADER);
        var vertexShader = gl.createShader(gl.VERTEX_SHADER);
        var prefix = "precision " + renderer.getPrecision() + " float;\n";
        gl.shaderSource(fragmentShader, prefix + shader.fragmentShader);
        gl.shaderSource(vertexShader, prefix + shader.vertexShader);
        gl.compileShader(fragmentShader);
        gl.compileShader(vertexShader);
        gl.attachShader(program, fragmentShader);
        gl.attachShader(program, vertexShader);
        gl.linkProgram(program);
        return program;
      }
    };
    THREE.ShadowMapPlugin = function(_renderer, _lights, _webglObjects, _webglObjectsImmediate) {
      var _gl = _renderer.context;
      var _depthMaterial,
          _depthMaterialMorph,
          _depthMaterialSkin,
          _depthMaterialMorphSkin,
          _frustum = new THREE.Frustum(),
          _projScreenMatrix = new THREE.Matrix4(),
          _min = new THREE.Vector3(),
          _max = new THREE.Vector3(),
          _matrixPosition = new THREE.Vector3(),
          _renderList = [];
      var depthShader = THREE.ShaderLib["depthRGBA"];
      var depthUniforms = THREE.UniformsUtils.clone(depthShader.uniforms);
      _depthMaterial = new THREE.ShaderMaterial({
        uniforms: depthUniforms,
        vertexShader: depthShader.vertexShader,
        fragmentShader: depthShader.fragmentShader
      });
      _depthMaterialMorph = new THREE.ShaderMaterial({
        uniforms: depthUniforms,
        vertexShader: depthShader.vertexShader,
        fragmentShader: depthShader.fragmentShader,
        morphTargets: true
      });
      _depthMaterialSkin = new THREE.ShaderMaterial({
        uniforms: depthUniforms,
        vertexShader: depthShader.vertexShader,
        fragmentShader: depthShader.fragmentShader,
        skinning: true
      });
      _depthMaterialMorphSkin = new THREE.ShaderMaterial({
        uniforms: depthUniforms,
        vertexShader: depthShader.vertexShader,
        fragmentShader: depthShader.fragmentShader,
        morphTargets: true,
        skinning: true
      });
      _depthMaterial._shadowPass = true;
      _depthMaterialMorph._shadowPass = true;
      _depthMaterialSkin._shadowPass = true;
      _depthMaterialMorphSkin._shadowPass = true;
      this.render = function(scene, camera) {
        if (_renderer.shadowMapEnabled === false)
          return ;
        var i,
            il,
            j,
            jl,
            n,
            shadowMap,
            shadowMatrix,
            shadowCamera,
            buffer,
            material,
            webglObject,
            object,
            light,
            lights = [],
            k = 0,
            fog = null;
        _gl.clearColor(1, 1, 1, 1);
        _gl.disable(_gl.BLEND);
        _gl.enable(_gl.CULL_FACE);
        _gl.frontFace(_gl.CCW);
        if (_renderer.shadowMapCullFace === THREE.CullFaceFront) {
          _gl.cullFace(_gl.FRONT);
        } else {
          _gl.cullFace(_gl.BACK);
        }
        _renderer.state.setDepthTest(true);
        for (i = 0, il = _lights.length; i < il; i++) {
          light = _lights[i];
          if (!light.castShadow)
            continue;
          if ((light instanceof THREE.DirectionalLight) && light.shadowCascade) {
            for (n = 0; n < light.shadowCascadeCount; n++) {
              var virtualLight;
              if (!light.shadowCascadeArray[n]) {
                virtualLight = createVirtualLight(light, n);
                virtualLight.originalCamera = camera;
                var gyro = new THREE.Gyroscope();
                gyro.position.copy(light.shadowCascadeOffset);
                gyro.add(virtualLight);
                gyro.add(virtualLight.target);
                camera.add(gyro);
                light.shadowCascadeArray[n] = virtualLight;
              } else {
                virtualLight = light.shadowCascadeArray[n];
              }
              updateVirtualLight(light, n);
              lights[k] = virtualLight;
              k++;
            }
          } else {
            lights[k] = light;
            k++;
          }
        }
        for (i = 0, il = lights.length; i < il; i++) {
          light = lights[i];
          if (!light.shadowMap) {
            var shadowFilter = THREE.LinearFilter;
            if (_renderer.shadowMapType === THREE.PCFSoftShadowMap) {
              shadowFilter = THREE.NearestFilter;
            }
            var pars = {
              minFilter: shadowFilter,
              magFilter: shadowFilter,
              format: THREE.RGBAFormat
            };
            light.shadowMap = new THREE.WebGLRenderTarget(light.shadowMapWidth, light.shadowMapHeight, pars);
            light.shadowMapSize = new THREE.Vector2(light.shadowMapWidth, light.shadowMapHeight);
            light.shadowMatrix = new THREE.Matrix4();
          }
          if (!light.shadowCamera) {
            if (light instanceof THREE.SpotLight) {
              light.shadowCamera = new THREE.PerspectiveCamera(light.shadowCameraFov, light.shadowMapWidth / light.shadowMapHeight, light.shadowCameraNear, light.shadowCameraFar);
            } else if (light instanceof THREE.DirectionalLight) {
              light.shadowCamera = new THREE.OrthographicCamera(light.shadowCameraLeft, light.shadowCameraRight, light.shadowCameraTop, light.shadowCameraBottom, light.shadowCameraNear, light.shadowCameraFar);
            } else {
              THREE.error("THREE.ShadowMapPlugin: Unsupported light type for shadow", light);
              continue;
            }
            scene.add(light.shadowCamera);
            if (scene.autoUpdate === true)
              scene.updateMatrixWorld();
          }
          if (light.shadowCameraVisible && !light.cameraHelper) {
            light.cameraHelper = new THREE.CameraHelper(light.shadowCamera);
            scene.add(light.cameraHelper);
          }
          if (light.isVirtual && virtualLight.originalCamera == camera) {
            updateShadowCamera(camera, light);
          }
          shadowMap = light.shadowMap;
          shadowMatrix = light.shadowMatrix;
          shadowCamera = light.shadowCamera;
          shadowCamera.position.setFromMatrixPosition(light.matrixWorld);
          _matrixPosition.setFromMatrixPosition(light.target.matrixWorld);
          shadowCamera.lookAt(_matrixPosition);
          shadowCamera.updateMatrixWorld();
          shadowCamera.matrixWorldInverse.getInverse(shadowCamera.matrixWorld);
          if (light.cameraHelper)
            light.cameraHelper.visible = light.shadowCameraVisible;
          if (light.shadowCameraVisible)
            light.cameraHelper.update();
          shadowMatrix.set(0.5, 0.0, 0.0, 0.5, 0.0, 0.5, 0.0, 0.5, 0.0, 0.0, 0.5, 0.5, 0.0, 0.0, 0.0, 1.0);
          shadowMatrix.multiply(shadowCamera.projectionMatrix);
          shadowMatrix.multiply(shadowCamera.matrixWorldInverse);
          _projScreenMatrix.multiplyMatrices(shadowCamera.projectionMatrix, shadowCamera.matrixWorldInverse);
          _frustum.setFromMatrix(_projScreenMatrix);
          _renderer.setRenderTarget(shadowMap);
          _renderer.clear();
          _renderList.length = 0;
          projectObject(scene, scene, shadowCamera);
          var objectMaterial,
              useMorphing,
              useSkinning;
          for (j = 0, jl = _renderList.length; j < jl; j++) {
            webglObject = _renderList[j];
            object = webglObject.object;
            buffer = webglObject.buffer;
            objectMaterial = getObjectMaterial(object);
            useMorphing = object.geometry.morphTargets !== undefined && object.geometry.morphTargets.length > 0 && objectMaterial.morphTargets;
            useSkinning = object instanceof THREE.SkinnedMesh && objectMaterial.skinning;
            if (object.customDepthMaterial) {
              material = object.customDepthMaterial;
            } else if (useSkinning) {
              material = useMorphing ? _depthMaterialMorphSkin : _depthMaterialSkin;
            } else if (useMorphing) {
              material = _depthMaterialMorph;
            } else {
              material = _depthMaterial;
            }
            _renderer.setMaterialFaces(objectMaterial);
            if (buffer instanceof THREE.BufferGeometry) {
              _renderer.renderBufferDirect(shadowCamera, _lights, fog, material, buffer, object);
            } else {
              _renderer.renderBuffer(shadowCamera, _lights, fog, material, buffer, object);
            }
          }
          for (j = 0, jl = _webglObjectsImmediate.length; j < jl; j++) {
            webglObject = _webglObjectsImmediate[j];
            object = webglObject.object;
            if (object.visible && object.castShadow) {
              object._modelViewMatrix.multiplyMatrices(shadowCamera.matrixWorldInverse, object.matrixWorld);
              _renderer.renderImmediateObject(shadowCamera, _lights, fog, _depthMaterial, object);
            }
          }
        }
        var clearColor = _renderer.getClearColor(),
            clearAlpha = _renderer.getClearAlpha();
        _gl.clearColor(clearColor.r, clearColor.g, clearColor.b, clearAlpha);
        _gl.enable(_gl.BLEND);
        if (_renderer.shadowMapCullFace === THREE.CullFaceFront) {
          _gl.cullFace(_gl.BACK);
        }
        _renderer.resetGLState();
      };
      function projectObject(scene, object, shadowCamera) {
        if (object.visible) {
          var webglObjects = _webglObjects[object.id];
          if (webglObjects && object.castShadow && (object.frustumCulled === false || _frustum.intersectsObject(object) === true)) {
            for (var i = 0,
                l = webglObjects.length; i < l; i++) {
              var webglObject = webglObjects[i];
              object._modelViewMatrix.multiplyMatrices(shadowCamera.matrixWorldInverse, object.matrixWorld);
              _renderList.push(webglObject);
            }
          }
          for (var i = 0,
              l = object.children.length; i < l; i++) {
            projectObject(scene, object.children[i], shadowCamera);
          }
        }
      }
      function createVirtualLight(light, cascade) {
        var virtualLight = new THREE.DirectionalLight();
        virtualLight.isVirtual = true;
        virtualLight.onlyShadow = true;
        virtualLight.castShadow = true;
        virtualLight.shadowCameraNear = light.shadowCameraNear;
        virtualLight.shadowCameraFar = light.shadowCameraFar;
        virtualLight.shadowCameraLeft = light.shadowCameraLeft;
        virtualLight.shadowCameraRight = light.shadowCameraRight;
        virtualLight.shadowCameraBottom = light.shadowCameraBottom;
        virtualLight.shadowCameraTop = light.shadowCameraTop;
        virtualLight.shadowCameraVisible = light.shadowCameraVisible;
        virtualLight.shadowDarkness = light.shadowDarkness;
        virtualLight.shadowBias = light.shadowCascadeBias[cascade];
        virtualLight.shadowMapWidth = light.shadowCascadeWidth[cascade];
        virtualLight.shadowMapHeight = light.shadowCascadeHeight[cascade];
        virtualLight.pointsWorld = [];
        virtualLight.pointsFrustum = [];
        var pointsWorld = virtualLight.pointsWorld,
            pointsFrustum = virtualLight.pointsFrustum;
        for (var i = 0; i < 8; i++) {
          pointsWorld[i] = new THREE.Vector3();
          pointsFrustum[i] = new THREE.Vector3();
        }
        var nearZ = light.shadowCascadeNearZ[cascade];
        var farZ = light.shadowCascadeFarZ[cascade];
        pointsFrustum[0].set(-1, -1, nearZ);
        pointsFrustum[1].set(1, -1, nearZ);
        pointsFrustum[2].set(-1, 1, nearZ);
        pointsFrustum[3].set(1, 1, nearZ);
        pointsFrustum[4].set(-1, -1, farZ);
        pointsFrustum[5].set(1, -1, farZ);
        pointsFrustum[6].set(-1, 1, farZ);
        pointsFrustum[7].set(1, 1, farZ);
        return virtualLight;
      }
      function updateVirtualLight(light, cascade) {
        var virtualLight = light.shadowCascadeArray[cascade];
        virtualLight.position.copy(light.position);
        virtualLight.target.position.copy(light.target.position);
        virtualLight.lookAt(virtualLight.target);
        virtualLight.shadowCameraVisible = light.shadowCameraVisible;
        virtualLight.shadowDarkness = light.shadowDarkness;
        virtualLight.shadowBias = light.shadowCascadeBias[cascade];
        var nearZ = light.shadowCascadeNearZ[cascade];
        var farZ = light.shadowCascadeFarZ[cascade];
        var pointsFrustum = virtualLight.pointsFrustum;
        pointsFrustum[0].z = nearZ;
        pointsFrustum[1].z = nearZ;
        pointsFrustum[2].z = nearZ;
        pointsFrustum[3].z = nearZ;
        pointsFrustum[4].z = farZ;
        pointsFrustum[5].z = farZ;
        pointsFrustum[6].z = farZ;
        pointsFrustum[7].z = farZ;
      }
      function updateShadowCamera(camera, light) {
        var shadowCamera = light.shadowCamera,
            pointsFrustum = light.pointsFrustum,
            pointsWorld = light.pointsWorld;
        _min.set(Infinity, Infinity, Infinity);
        _max.set(-Infinity, -Infinity, -Infinity);
        for (var i = 0; i < 8; i++) {
          var p = pointsWorld[i];
          p.copy(pointsFrustum[i]);
          p.unproject(camera);
          p.applyMatrix4(shadowCamera.matrixWorldInverse);
          if (p.x < _min.x)
            _min.x = p.x;
          if (p.x > _max.x)
            _max.x = p.x;
          if (p.y < _min.y)
            _min.y = p.y;
          if (p.y > _max.y)
            _max.y = p.y;
          if (p.z < _min.z)
            _min.z = p.z;
          if (p.z > _max.z)
            _max.z = p.z;
        }
        shadowCamera.left = _min.x;
        shadowCamera.right = _max.x;
        shadowCamera.top = _max.y;
        shadowCamera.bottom = _min.y;
        shadowCamera.updateProjectionMatrix();
      }
      function getObjectMaterial(object) {
        return object.material instanceof THREE.MeshFaceMaterial ? object.material.materials[0] : object.material;
      }
      ;
    };
    THREE.SpritePlugin = function(renderer, sprites) {
      var gl = renderer.context;
      var vertexBuffer,
          elementBuffer;
      var program,
          attributes,
          uniforms;
      var texture;
      var spritePosition = new THREE.Vector3();
      var spriteRotation = new THREE.Quaternion();
      var spriteScale = new THREE.Vector3();
      var init = function() {
        var vertices = new Float32Array([-0.5, -0.5, 0, 0, 0.5, -0.5, 1, 0, 0.5, 0.5, 1, 1, -0.5, 0.5, 0, 1]);
        var faces = new Uint16Array([0, 1, 2, 0, 2, 3]);
        vertexBuffer = gl.createBuffer();
        elementBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, vertexBuffer);
        gl.bufferData(gl.ARRAY_BUFFER, vertices, gl.STATIC_DRAW);
        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, elementBuffer);
        gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, faces, gl.STATIC_DRAW);
        program = createProgram();
        attributes = {
          position: gl.getAttribLocation(program, 'position'),
          uv: gl.getAttribLocation(program, 'uv')
        };
        uniforms = {
          uvOffset: gl.getUniformLocation(program, 'uvOffset'),
          uvScale: gl.getUniformLocation(program, 'uvScale'),
          rotation: gl.getUniformLocation(program, 'rotation'),
          scale: gl.getUniformLocation(program, 'scale'),
          color: gl.getUniformLocation(program, 'color'),
          map: gl.getUniformLocation(program, 'map'),
          opacity: gl.getUniformLocation(program, 'opacity'),
          modelViewMatrix: gl.getUniformLocation(program, 'modelViewMatrix'),
          projectionMatrix: gl.getUniformLocation(program, 'projectionMatrix'),
          fogType: gl.getUniformLocation(program, 'fogType'),
          fogDensity: gl.getUniformLocation(program, 'fogDensity'),
          fogNear: gl.getUniformLocation(program, 'fogNear'),
          fogFar: gl.getUniformLocation(program, 'fogFar'),
          fogColor: gl.getUniformLocation(program, 'fogColor'),
          alphaTest: gl.getUniformLocation(program, 'alphaTest')
        };
        var canvas = document.createElement('canvas');
        canvas.width = 8;
        canvas.height = 8;
        var context = canvas.getContext('2d');
        context.fillStyle = 'white';
        context.fillRect(0, 0, 8, 8);
        texture = new THREE.Texture(canvas);
        texture.needsUpdate = true;
      };
      this.render = function(scene, camera) {
        if (sprites.length === 0)
          return ;
        if (program === undefined) {
          init();
        }
        gl.useProgram(program);
        gl.enableVertexAttribArray(attributes.position);
        gl.enableVertexAttribArray(attributes.uv);
        gl.disable(gl.CULL_FACE);
        gl.enable(gl.BLEND);
        gl.bindBuffer(gl.ARRAY_BUFFER, vertexBuffer);
        gl.vertexAttribPointer(attributes.position, 2, gl.FLOAT, false, 2 * 8, 0);
        gl.vertexAttribPointer(attributes.uv, 2, gl.FLOAT, false, 2 * 8, 8);
        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, elementBuffer);
        gl.uniformMatrix4fv(uniforms.projectionMatrix, false, camera.projectionMatrix.elements);
        gl.activeTexture(gl.TEXTURE0);
        gl.uniform1i(uniforms.map, 0);
        var oldFogType = 0;
        var sceneFogType = 0;
        var fog = scene.fog;
        if (fog) {
          gl.uniform3f(uniforms.fogColor, fog.color.r, fog.color.g, fog.color.b);
          if (fog instanceof THREE.Fog) {
            gl.uniform1f(uniforms.fogNear, fog.near);
            gl.uniform1f(uniforms.fogFar, fog.far);
            gl.uniform1i(uniforms.fogType, 1);
            oldFogType = 1;
            sceneFogType = 1;
          } else if (fog instanceof THREE.FogExp2) {
            gl.uniform1f(uniforms.fogDensity, fog.density);
            gl.uniform1i(uniforms.fogType, 2);
            oldFogType = 2;
            sceneFogType = 2;
          }
        } else {
          gl.uniform1i(uniforms.fogType, 0);
          oldFogType = 0;
          sceneFogType = 0;
        }
        for (var i = 0,
            l = sprites.length; i < l; i++) {
          var sprite = sprites[i];
          sprite._modelViewMatrix.multiplyMatrices(camera.matrixWorldInverse, sprite.matrixWorld);
          sprite.z = -sprite._modelViewMatrix.elements[14];
        }
        sprites.sort(painterSortStable);
        var scale = [];
        for (var i = 0,
            l = sprites.length; i < l; i++) {
          var sprite = sprites[i];
          var material = sprite.material;
          gl.uniform1f(uniforms.alphaTest, material.alphaTest);
          gl.uniformMatrix4fv(uniforms.modelViewMatrix, false, sprite._modelViewMatrix.elements);
          sprite.matrixWorld.decompose(spritePosition, spriteRotation, spriteScale);
          scale[0] = spriteScale.x;
          scale[1] = spriteScale.y;
          var fogType = 0;
          if (scene.fog && material.fog) {
            fogType = sceneFogType;
          }
          if (oldFogType !== fogType) {
            gl.uniform1i(uniforms.fogType, fogType);
            oldFogType = fogType;
          }
          if (material.map !== null) {
            gl.uniform2f(uniforms.uvOffset, material.map.offset.x, material.map.offset.y);
            gl.uniform2f(uniforms.uvScale, material.map.repeat.x, material.map.repeat.y);
          } else {
            gl.uniform2f(uniforms.uvOffset, 0, 0);
            gl.uniform2f(uniforms.uvScale, 1, 1);
          }
          gl.uniform1f(uniforms.opacity, material.opacity);
          gl.uniform3f(uniforms.color, material.color.r, material.color.g, material.color.b);
          gl.uniform1f(uniforms.rotation, material.rotation);
          gl.uniform2fv(uniforms.scale, scale);
          renderer.state.setBlending(material.blending, material.blendEquation, material.blendSrc, material.blendDst);
          renderer.state.setDepthTest(material.depthTest);
          renderer.state.setDepthWrite(material.depthWrite);
          if (material.map && material.map.image && material.map.image.width) {
            renderer.setTexture(material.map, 0);
          } else {
            renderer.setTexture(texture, 0);
          }
          gl.drawElements(gl.TRIANGLES, 6, gl.UNSIGNED_SHORT, 0);
        }
        gl.enable(gl.CULL_FACE);
        renderer.resetGLState();
      };
      function createProgram() {
        var program = gl.createProgram();
        var vertexShader = gl.createShader(gl.VERTEX_SHADER);
        var fragmentShader = gl.createShader(gl.FRAGMENT_SHADER);
        gl.shaderSource(vertexShader, ['precision ' + renderer.getPrecision() + ' float;', 'uniform mat4 modelViewMatrix;', 'uniform mat4 projectionMatrix;', 'uniform float rotation;', 'uniform vec2 scale;', 'uniform vec2 uvOffset;', 'uniform vec2 uvScale;', 'attribute vec2 position;', 'attribute vec2 uv;', 'varying vec2 vUV;', 'void main() {', 'vUV = uvOffset + uv * uvScale;', 'vec2 alignedPosition = position * scale;', 'vec2 rotatedPosition;', 'rotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;', 'rotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;', 'vec4 finalPosition;', 'finalPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );', 'finalPosition.xy += rotatedPosition;', 'finalPosition = projectionMatrix * finalPosition;', 'gl_Position = finalPosition;', '}'].join('\n'));
        gl.shaderSource(fragmentShader, ['precision ' + renderer.getPrecision() + ' float;', 'uniform vec3 color;', 'uniform sampler2D map;', 'uniform float opacity;', 'uniform int fogType;', 'uniform vec3 fogColor;', 'uniform float fogDensity;', 'uniform float fogNear;', 'uniform float fogFar;', 'uniform float alphaTest;', 'varying vec2 vUV;', 'void main() {', 'vec4 texture = texture2D( map, vUV );', 'if ( texture.a < alphaTest ) discard;', 'gl_FragColor = vec4( color * texture.xyz, texture.a * opacity );', 'if ( fogType > 0 ) {', 'float depth = gl_FragCoord.z / gl_FragCoord.w;', 'float fogFactor = 0.0;', 'if ( fogType == 1 ) {', 'fogFactor = smoothstep( fogNear, fogFar, depth );', '} else {', 'const float LOG2 = 1.442695;', 'float fogFactor = exp2( - fogDensity * fogDensity * depth * depth * LOG2 );', 'fogFactor = 1.0 - clamp( fogFactor, 0.0, 1.0 );', '}', 'gl_FragColor = mix( gl_FragColor, vec4( fogColor, gl_FragColor.w ), fogFactor );', '}', '}'].join('\n'));
        gl.compileShader(vertexShader);
        gl.compileShader(fragmentShader);
        gl.attachShader(program, vertexShader);
        gl.attachShader(program, fragmentShader);
        gl.linkProgram(program);
        return program;
      }
      ;
      function painterSortStable(a, b) {
        if (a.z !== b.z) {
          return b.z - a.z;
        } else {
          return b.id - a.id;
        }
      }
      ;
    };
    THREE.GeometryUtils = {
      merge: function(geometry1, geometry2, materialIndexOffset) {
        THREE.warn('THREE.GeometryUtils: .merge() has been moved to Geometry. Use geometry.merge( geometry2, matrix, materialIndexOffset ) instead.');
        var matrix;
        if (geometry2 instanceof THREE.Mesh) {
          geometry2.matrixAutoUpdate && geometry2.updateMatrix();
          matrix = geometry2.matrix;
          geometry2 = geometry2.geometry;
        }
        geometry1.merge(geometry2, matrix, materialIndexOffset);
      },
      center: function(geometry) {
        THREE.warn('THREE.GeometryUtils: .center() has been moved to Geometry. Use geometry.center() instead.');
        return geometry.center();
      }
    };
    THREE.ImageUtils = {
      crossOrigin: undefined,
      loadTexture: function(url, mapping, onLoad, onError) {
        var loader = new THREE.ImageLoader();
        loader.crossOrigin = this.crossOrigin;
        var texture = new THREE.Texture(undefined, mapping);
        loader.load(url, function(image) {
          texture.image = image;
          texture.needsUpdate = true;
          if (onLoad)
            onLoad(texture);
        }, undefined, function(event) {
          if (onError)
            onError(event);
        });
        texture.sourceFile = url;
        return texture;
      },
      loadTextureCube: function(array, mapping, onLoad, onError) {
        var images = [];
        var loader = new THREE.ImageLoader();
        loader.crossOrigin = this.crossOrigin;
        var texture = new THREE.CubeTexture(images, mapping);
        texture.flipY = false;
        var loaded = 0;
        var loadTexture = function(i) {
          loader.load(array[i], function(image) {
            texture.images[i] = image;
            loaded += 1;
            if (loaded === 6) {
              texture.needsUpdate = true;
              if (onLoad)
                onLoad(texture);
            }
          }, undefined, onError);
        };
        for (var i = 0,
            il = array.length; i < il; ++i) {
          loadTexture(i);
        }
        return texture;
      },
      loadCompressedTexture: function() {
        THREE.error('THREE.ImageUtils.loadCompressedTexture has been removed. Use THREE.DDSLoader instead.');
      },
      loadCompressedTextureCube: function() {
        THREE.error('THREE.ImageUtils.loadCompressedTextureCube has been removed. Use THREE.DDSLoader instead.');
      },
      getNormalMap: function(image, depth) {
        var cross = function(a, b) {
          return [a[1] * b[2] - a[2] * b[1], a[2] * b[0] - a[0] * b[2], a[0] * b[1] - a[1] * b[0]];
        };
        var subtract = function(a, b) {
          return [a[0] - b[0], a[1] - b[1], a[2] - b[2]];
        };
        var normalize = function(a) {
          var l = Math.sqrt(a[0] * a[0] + a[1] * a[1] + a[2] * a[2]);
          return [a[0] / l, a[1] / l, a[2] / l];
        };
        depth = depth | 1;
        var width = image.width;
        var height = image.height;
        var canvas = document.createElement('canvas');
        canvas.width = width;
        canvas.height = height;
        var context = canvas.getContext('2d');
        context.drawImage(image, 0, 0);
        var data = context.getImageData(0, 0, width, height).data;
        var imageData = context.createImageData(width, height);
        var output = imageData.data;
        for (var x = 0; x < width; x++) {
          for (var y = 0; y < height; y++) {
            var ly = y - 1 < 0 ? 0 : y - 1;
            var uy = y + 1 > height - 1 ? height - 1 : y + 1;
            var lx = x - 1 < 0 ? 0 : x - 1;
            var ux = x + 1 > width - 1 ? width - 1 : x + 1;
            var points = [];
            var origin = [0, 0, data[(y * width + x) * 4] / 255 * depth];
            points.push([-1, 0, data[(y * width + lx) * 4] / 255 * depth]);
            points.push([-1, -1, data[(ly * width + lx) * 4] / 255 * depth]);
            points.push([0, -1, data[(ly * width + x) * 4] / 255 * depth]);
            points.push([1, -1, data[(ly * width + ux) * 4] / 255 * depth]);
            points.push([1, 0, data[(y * width + ux) * 4] / 255 * depth]);
            points.push([1, 1, data[(uy * width + ux) * 4] / 255 * depth]);
            points.push([0, 1, data[(uy * width + x) * 4] / 255 * depth]);
            points.push([-1, 1, data[(uy * width + lx) * 4] / 255 * depth]);
            var normals = [];
            var num_points = points.length;
            for (var i = 0; i < num_points; i++) {
              var v1 = points[i];
              var v2 = points[(i + 1) % num_points];
              v1 = subtract(v1, origin);
              v2 = subtract(v2, origin);
              normals.push(normalize(cross(v1, v2)));
            }
            var normal = [0, 0, 0];
            for (var i = 0; i < normals.length; i++) {
              normal[0] += normals[i][0];
              normal[1] += normals[i][1];
              normal[2] += normals[i][2];
            }
            normal[0] /= normals.length;
            normal[1] /= normals.length;
            normal[2] /= normals.length;
            var idx = (y * width + x) * 4;
            output[idx] = ((normal[0] + 1.0) / 2.0 * 255) | 0;
            output[idx + 1] = ((normal[1] + 1.0) / 2.0 * 255) | 0;
            output[idx + 2] = (normal[2] * 255) | 0;
            output[idx + 3] = 255;
          }
        }
        context.putImageData(imageData, 0, 0);
        return canvas;
      },
      generateDataTexture: function(width, height, color) {
        var size = width * height;
        var data = new Uint8Array(3 * size);
        var r = Math.floor(color.r * 255);
        var g = Math.floor(color.g * 255);
        var b = Math.floor(color.b * 255);
        for (var i = 0; i < size; i++) {
          data[i * 3] = r;
          data[i * 3 + 1] = g;
          data[i * 3 + 2] = b;
        }
        var texture = new THREE.DataTexture(data, width, height, THREE.RGBFormat);
        texture.needsUpdate = true;
        return texture;
      }
    };
    THREE.SceneUtils = {
      createMultiMaterialObject: function(geometry, materials) {
        var group = new THREE.Object3D();
        for (var i = 0,
            l = materials.length; i < l; i++) {
          group.add(new THREE.Mesh(geometry, materials[i]));
        }
        return group;
      },
      detach: function(child, parent, scene) {
        child.applyMatrix(parent.matrixWorld);
        parent.remove(child);
        scene.add(child);
      },
      attach: function(child, scene, parent) {
        var matrixWorldInverse = new THREE.Matrix4();
        matrixWorldInverse.getInverse(parent.matrixWorld);
        child.applyMatrix(matrixWorldInverse);
        scene.remove(child);
        parent.add(child);
      }
    };
    THREE.FontUtils = {
      faces: {},
      face: 'helvetiker',
      weight: 'normal',
      style: 'normal',
      size: 150,
      divisions: 10,
      getFace: function() {
        try {
          return this.faces[this.face][this.weight][this.style];
        } catch (e) {
          throw "The font " + this.face + " with " + this.weight + " weight and " + this.style + " style is missing.";
        }
        ;
      },
      loadFace: function(data) {
        var family = data.familyName.toLowerCase();
        var ThreeFont = this;
        ThreeFont.faces[family] = ThreeFont.faces[family] || {};
        ThreeFont.faces[family][data.cssFontWeight] = ThreeFont.faces[family][data.cssFontWeight] || {};
        ThreeFont.faces[family][data.cssFontWeight][data.cssFontStyle] = data;
        ThreeFont.faces[family][data.cssFontWeight][data.cssFontStyle] = data;
        return data;
      },
      drawText: function(text) {
        var i,
            face = this.getFace(),
            scale = this.size / face.resolution,
            offset = 0,
            chars = String(text).split(''),
            length = chars.length;
        var fontPaths = [];
        for (i = 0; i < length; i++) {
          var path = new THREE.Path();
          var ret = this.extractGlyphPoints(chars[i], face, scale, offset, path);
          offset += ret.offset;
          fontPaths.push(ret.path);
        }
        var width = offset / 2;
        return {
          paths: fontPaths,
          offset: width
        };
      },
      extractGlyphPoints: function(c, face, scale, offset, path) {
        var pts = [];
        var i,
            i2,
            divisions,
            outline,
            action,
            length,
            scaleX,
            scaleY,
            x,
            y,
            cpx,
            cpy,
            cpx0,
            cpy0,
            cpx1,
            cpy1,
            cpx2,
            cpy2,
            laste,
            glyph = face.glyphs[c] || face.glyphs['?'];
        if (!glyph)
          return ;
        if (glyph.o) {
          outline = glyph._cachedOutline || (glyph._cachedOutline = glyph.o.split(' '));
          length = outline.length;
          scaleX = scale;
          scaleY = scale;
          for (i = 0; i < length; ) {
            action = outline[i++];
            switch (action) {
              case 'm':
                x = outline[i++] * scaleX + offset;
                y = outline[i++] * scaleY;
                path.moveTo(x, y);
                break;
              case 'l':
                x = outline[i++] * scaleX + offset;
                y = outline[i++] * scaleY;
                path.lineTo(x, y);
                break;
              case 'q':
                cpx = outline[i++] * scaleX + offset;
                cpy = outline[i++] * scaleY;
                cpx1 = outline[i++] * scaleX + offset;
                cpy1 = outline[i++] * scaleY;
                path.quadraticCurveTo(cpx1, cpy1, cpx, cpy);
                laste = pts[pts.length - 1];
                if (laste) {
                  cpx0 = laste.x;
                  cpy0 = laste.y;
                  for (i2 = 1, divisions = this.divisions; i2 <= divisions; i2++) {
                    var t = i2 / divisions;
                    THREE.Shape.Utils.b2(t, cpx0, cpx1, cpx);
                    THREE.Shape.Utils.b2(t, cpy0, cpy1, cpy);
                  }
                }
                break;
              case 'b':
                cpx = outline[i++] * scaleX + offset;
                cpy = outline[i++] * scaleY;
                cpx1 = outline[i++] * scaleX + offset;
                cpy1 = outline[i++] * scaleY;
                cpx2 = outline[i++] * scaleX + offset;
                cpy2 = outline[i++] * scaleY;
                path.bezierCurveTo(cpx1, cpy1, cpx2, cpy2, cpx, cpy);
                laste = pts[pts.length - 1];
                if (laste) {
                  cpx0 = laste.x;
                  cpy0 = laste.y;
                  for (i2 = 1, divisions = this.divisions; i2 <= divisions; i2++) {
                    var t = i2 / divisions;
                    THREE.Shape.Utils.b3(t, cpx0, cpx1, cpx2, cpx);
                    THREE.Shape.Utils.b3(t, cpy0, cpy1, cpy2, cpy);
                  }
                }
                break;
            }
          }
        }
        return {
          offset: glyph.ha * scale,
          path: path
        };
      }
    };
    THREE.FontUtils.generateShapes = function(text, parameters) {
      parameters = parameters || {};
      var size = parameters.size !== undefined ? parameters.size : 100;
      var curveSegments = parameters.curveSegments !== undefined ? parameters.curveSegments : 4;
      var font = parameters.font !== undefined ? parameters.font : 'helvetiker';
      var weight = parameters.weight !== undefined ? parameters.weight : 'normal';
      var style = parameters.style !== undefined ? parameters.style : 'normal';
      THREE.FontUtils.size = size;
      THREE.FontUtils.divisions = curveSegments;
      THREE.FontUtils.face = font;
      THREE.FontUtils.weight = weight;
      THREE.FontUtils.style = style;
      var data = THREE.FontUtils.drawText(text);
      var paths = data.paths;
      var shapes = [];
      for (var p = 0,
          pl = paths.length; p < pl; p++) {
        Array.prototype.push.apply(shapes, paths[p].toShapes());
      }
      return shapes;
    };
    (function(namespace) {
      var EPSILON = 0.0000000001;
      var process = function(contour, indices) {
        var n = contour.length;
        if (n < 3)
          return null;
        var result = [],
            verts = [],
            vertIndices = [];
        var u,
            v,
            w;
        if (area(contour) > 0.0) {
          for (v = 0; v < n; v++)
            verts[v] = v;
        } else {
          for (v = 0; v < n; v++)
            verts[v] = (n - 1) - v;
        }
        var nv = n;
        var count = 2 * nv;
        for (v = nv - 1; nv > 2; ) {
          if ((count--) <= 0) {
            THREE.warn('THREE.FontUtils: Warning, unable to triangulate polygon! in Triangulate.process()');
            if (indices)
              return vertIndices;
            return result;
          }
          u = v;
          if (nv <= u)
            u = 0;
          v = u + 1;
          if (nv <= v)
            v = 0;
          w = v + 1;
          if (nv <= w)
            w = 0;
          if (snip(contour, u, v, w, nv, verts)) {
            var a,
                b,
                c,
                s,
                t;
            a = verts[u];
            b = verts[v];
            c = verts[w];
            result.push([contour[a], contour[b], contour[c]]);
            vertIndices.push([verts[u], verts[v], verts[w]]);
            for (s = v, t = v + 1; t < nv; s++, t++) {
              verts[s] = verts[t];
            }
            nv--;
            count = 2 * nv;
          }
        }
        if (indices)
          return vertIndices;
        return result;
      };
      var area = function(contour) {
        var n = contour.length;
        var a = 0.0;
        for (var p = n - 1,
            q = 0; q < n; p = q++) {
          a += contour[p].x * contour[q].y - contour[q].x * contour[p].y;
        }
        return a * 0.5;
      };
      var snip = function(contour, u, v, w, n, verts) {
        var p;
        var ax,
            ay,
            bx,
            by;
        var cx,
            cy,
            px,
            py;
        ax = contour[verts[u]].x;
        ay = contour[verts[u]].y;
        bx = contour[verts[v]].x;
        by = contour[verts[v]].y;
        cx = contour[verts[w]].x;
        cy = contour[verts[w]].y;
        if (EPSILON > (((bx - ax) * (cy - ay)) - ((by - ay) * (cx - ax))))
          return false;
        var aX,
            aY,
            bX,
            bY,
            cX,
            cY;
        var apx,
            apy,
            bpx,
            bpy,
            cpx,
            cpy;
        var cCROSSap,
            bCROSScp,
            aCROSSbp;
        aX = cx - bx;
        aY = cy - by;
        bX = ax - cx;
        bY = ay - cy;
        cX = bx - ax;
        cY = by - ay;
        for (p = 0; p < n; p++) {
          px = contour[verts[p]].x;
          py = contour[verts[p]].y;
          if (((px === ax) && (py === ay)) || ((px === bx) && (py === by)) || ((px === cx) && (py === cy)))
            continue;
          apx = px - ax;
          apy = py - ay;
          bpx = px - bx;
          bpy = py - by;
          cpx = px - cx;
          cpy = py - cy;
          aCROSSbp = aX * bpy - aY * bpx;
          cCROSSap = cX * apy - cY * apx;
          bCROSScp = bX * cpy - bY * cpx;
          if ((aCROSSbp >= -EPSILON) && (bCROSScp >= -EPSILON) && (cCROSSap >= -EPSILON))
            return false;
        }
        return true;
      };
      namespace.Triangulate = process;
      namespace.Triangulate.area = area;
      return namespace;
    })(THREE.FontUtils);
    self._typeface_js = {
      faces: THREE.FontUtils.faces,
      loadFace: THREE.FontUtils.loadFace
    };
    THREE.typeface_js = self._typeface_js;
    THREE.Audio = function(listener) {
      THREE.Object3D.call(this);
      this.type = 'Audio';
      this.context = listener.context;
      this.source = this.context.createBufferSource();
      this.source.onended = this.onEnded.bind(this);
      this.gain = this.context.createGain();
      this.gain.connect(this.context.destination);
      this.panner = this.context.createPanner();
      this.panner.connect(this.gain);
      this.autoplay = false;
      this.startTime = 0;
      this.isPlaying = false;
    };
    THREE.Audio.prototype = Object.create(THREE.Object3D.prototype);
    THREE.Audio.prototype.constructor = THREE.Audio;
    THREE.Audio.prototype.load = function(file) {
      var scope = this;
      var request = new XMLHttpRequest();
      request.open('GET', file, true);
      request.responseType = 'arraybuffer';
      request.onload = function(e) {
        scope.context.decodeAudioData(this.response, function(buffer) {
          scope.source.buffer = buffer;
          if (scope.autoplay)
            scope.play();
        });
      };
      request.send();
      return this;
    };
    THREE.Audio.prototype.play = function() {
      if (this.isPlaying === true) {
        THREE.warn('THREE.Audio: Audio is already playing.');
        return ;
      }
      var source = this.context.createBufferSource();
      source.buffer = this.source.buffer;
      source.loop = this.source.loop;
      source.onended = this.source.onended;
      source.connect(this.panner);
      source.start(0, this.startTime);
      this.isPlaying = true;
      this.source = source;
    };
    THREE.Audio.prototype.pause = function() {
      this.source.stop();
      this.startTime = this.context.currentTime;
    };
    THREE.Audio.prototype.stop = function() {
      this.source.stop();
      this.startTime = 0;
    };
    THREE.Audio.prototype.onEnded = function() {
      this.isPlaying = false;
    };
    THREE.Audio.prototype.setLoop = function(value) {
      this.source.loop = value;
    };
    THREE.Audio.prototype.setRefDistance = function(value) {
      this.panner.refDistance = value;
    };
    THREE.Audio.prototype.setRolloffFactor = function(value) {
      this.panner.rolloffFactor = value;
    };
    THREE.Audio.prototype.setVolume = function(value) {
      this.gain.gain.value = value;
    };
    THREE.Audio.prototype.updateMatrixWorld = (function() {
      var position = new THREE.Vector3();
      return function(force) {
        THREE.Object3D.prototype.updateMatrixWorld.call(this, force);
        position.setFromMatrixPosition(this.matrixWorld);
        this.panner.setPosition(position.x, position.y, position.z);
      };
    })();
    THREE.AudioListener = function() {
      THREE.Object3D.call(this);
      this.type = 'AudioListener';
      this.context = new (window.AudioContext || window.webkitAudioContext)();
    };
    THREE.AudioListener.prototype = Object.create(THREE.Object3D.prototype);
    THREE.AudioListener.prototype.constructor = THREE.AudioListener;
    THREE.AudioListener.prototype.updateMatrixWorld = (function() {
      var position = new THREE.Vector3();
      var quaternion = new THREE.Quaternion();
      var scale = new THREE.Vector3();
      var orientation = new THREE.Vector3();
      var velocity = new THREE.Vector3();
      var positionPrev = new THREE.Vector3();
      return function(force) {
        THREE.Object3D.prototype.updateMatrixWorld.call(this, force);
        var listener = this.context.listener;
        var up = this.up;
        this.matrixWorld.decompose(position, quaternion, scale);
        orientation.set(0, 0, -1).applyQuaternion(quaternion);
        velocity.subVectors(position, positionPrev);
        listener.setPosition(position.x, position.y, position.z);
        listener.setOrientation(orientation.x, orientation.y, orientation.z, up.x, up.y, up.z);
        listener.setVelocity(velocity.x, velocity.y, velocity.z);
        positionPrev.copy(position);
      };
    })();
    THREE.Curve = function() {};
    THREE.Curve.prototype.getPoint = function(t) {
      THREE.warn("THREE.Curve: Warning, getPoint() not implemented!");
      return null;
    };
    THREE.Curve.prototype.getPointAt = function(u) {
      var t = this.getUtoTmapping(u);
      return this.getPoint(t);
    };
    THREE.Curve.prototype.getPoints = function(divisions) {
      if (!divisions)
        divisions = 5;
      var d,
          pts = [];
      for (d = 0; d <= divisions; d++) {
        pts.push(this.getPoint(d / divisions));
      }
      return pts;
    };
    THREE.Curve.prototype.getSpacedPoints = function(divisions) {
      if (!divisions)
        divisions = 5;
      var d,
          pts = [];
      for (d = 0; d <= divisions; d++) {
        pts.push(this.getPointAt(d / divisions));
      }
      return pts;
    };
    THREE.Curve.prototype.getLength = function() {
      var lengths = this.getLengths();
      return lengths[lengths.length - 1];
    };
    THREE.Curve.prototype.getLengths = function(divisions) {
      if (!divisions)
        divisions = (this.__arcLengthDivisions) ? (this.__arcLengthDivisions) : 200;
      if (this.cacheArcLengths && (this.cacheArcLengths.length == divisions + 1) && !this.needsUpdate) {
        return this.cacheArcLengths;
      }
      this.needsUpdate = false;
      var cache = [];
      var current,
          last = this.getPoint(0);
      var p,
          sum = 0;
      cache.push(0);
      for (p = 1; p <= divisions; p++) {
        current = this.getPoint(p / divisions);
        sum += current.distanceTo(last);
        cache.push(sum);
        last = current;
      }
      this.cacheArcLengths = cache;
      return cache;
    };
    THREE.Curve.prototype.updateArcLengths = function() {
      this.needsUpdate = true;
      this.getLengths();
    };
    THREE.Curve.prototype.getUtoTmapping = function(u, distance) {
      var arcLengths = this.getLengths();
      var i = 0,
          il = arcLengths.length;
      var targetArcLength;
      if (distance) {
        targetArcLength = distance;
      } else {
        targetArcLength = u * arcLengths[il - 1];
      }
      var low = 0,
          high = il - 1,
          comparison;
      while (low <= high) {
        i = Math.floor(low + (high - low) / 2);
        comparison = arcLengths[i] - targetArcLength;
        if (comparison < 0) {
          low = i + 1;
        } else if (comparison > 0) {
          high = i - 1;
        } else {
          high = i;
          break;
        }
      }
      i = high;
      if (arcLengths[i] == targetArcLength) {
        var t = i / (il - 1);
        return t;
      }
      var lengthBefore = arcLengths[i];
      var lengthAfter = arcLengths[i + 1];
      var segmentLength = lengthAfter - lengthBefore;
      var segmentFraction = (targetArcLength - lengthBefore) / segmentLength;
      var t = (i + segmentFraction) / (il - 1);
      return t;
    };
    THREE.Curve.prototype.getTangent = function(t) {
      var delta = 0.0001;
      var t1 = t - delta;
      var t2 = t + delta;
      if (t1 < 0)
        t1 = 0;
      if (t2 > 1)
        t2 = 1;
      var pt1 = this.getPoint(t1);
      var pt2 = this.getPoint(t2);
      var vec = pt2.clone().sub(pt1);
      return vec.normalize();
    };
    THREE.Curve.prototype.getTangentAt = function(u) {
      var t = this.getUtoTmapping(u);
      return this.getTangent(t);
    };
    THREE.Curve.Utils = {
      tangentQuadraticBezier: function(t, p0, p1, p2) {
        return 2 * (1 - t) * (p1 - p0) + 2 * t * (p2 - p1);
      },
      tangentCubicBezier: function(t, p0, p1, p2, p3) {
        return -3 * p0 * (1 - t) * (1 - t) + 3 * p1 * (1 - t) * (1 - t) - 6 * t * p1 * (1 - t) + 6 * t * p2 * (1 - t) - 3 * t * t * p2 + 3 * t * t * p3;
      },
      tangentSpline: function(t, p0, p1, p2, p3) {
        var h00 = 6 * t * t - 6 * t;
        var h10 = 3 * t * t - 4 * t + 1;
        var h01 = -6 * t * t + 6 * t;
        var h11 = 3 * t * t - 2 * t;
        return h00 + h10 + h01 + h11;
      },
      interpolate: function(p0, p1, p2, p3, t) {
        var v0 = (p2 - p0) * 0.5;
        var v1 = (p3 - p1) * 0.5;
        var t2 = t * t;
        var t3 = t * t2;
        return (2 * p1 - 2 * p2 + v0 + v1) * t3 + (-3 * p1 + 3 * p2 - 2 * v0 - v1) * t2 + v0 * t + p1;
      }
    };
    THREE.Curve.create = function(constructor, getPointFunc) {
      constructor.prototype = Object.create(THREE.Curve.prototype);
      constructor.prototype.constructor = constructor;
      constructor.prototype.getPoint = getPointFunc;
      return constructor;
    };
    THREE.CurvePath = function() {
      this.curves = [];
      this.bends = [];
      this.autoClose = false;
    };
    THREE.CurvePath.prototype = Object.create(THREE.Curve.prototype);
    THREE.CurvePath.prototype.constructor = THREE.CurvePath;
    THREE.CurvePath.prototype.add = function(curve) {
      this.curves.push(curve);
    };
    THREE.CurvePath.prototype.checkConnection = function() {};
    THREE.CurvePath.prototype.closePath = function() {
      var startPoint = this.curves[0].getPoint(0);
      var endPoint = this.curves[this.curves.length - 1].getPoint(1);
      if (!startPoint.equals(endPoint)) {
        this.curves.push(new THREE.LineCurve(endPoint, startPoint));
      }
    };
    THREE.CurvePath.prototype.getPoint = function(t) {
      var d = t * this.getLength();
      var curveLengths = this.getCurveLengths();
      var i = 0,
          diff,
          curve;
      while (i < curveLengths.length) {
        if (curveLengths[i] >= d) {
          diff = curveLengths[i] - d;
          curve = this.curves[i];
          var u = 1 - diff / curve.getLength();
          return curve.getPointAt(u);
        }
        i++;
      }
      return null;
    };
    THREE.CurvePath.prototype.getLength = function() {
      var lens = this.getCurveLengths();
      return lens[lens.length - 1];
    };
    THREE.CurvePath.prototype.getCurveLengths = function() {
      if (this.cacheLengths && this.cacheLengths.length == this.curves.length) {
        return this.cacheLengths;
      }
      ;
      var lengths = [],
          sums = 0;
      var i,
          il = this.curves.length;
      for (i = 0; i < il; i++) {
        sums += this.curves[i].getLength();
        lengths.push(sums);
      }
      this.cacheLengths = lengths;
      return lengths;
    };
    THREE.CurvePath.prototype.getBoundingBox = function() {
      var points = this.getPoints();
      var maxX,
          maxY,
          maxZ;
      var minX,
          minY,
          minZ;
      maxX = maxY = Number.NEGATIVE_INFINITY;
      minX = minY = Number.POSITIVE_INFINITY;
      var p,
          i,
          il,
          sum;
      var v3 = points[0] instanceof THREE.Vector3;
      sum = v3 ? new THREE.Vector3() : new THREE.Vector2();
      for (i = 0, il = points.length; i < il; i++) {
        p = points[i];
        if (p.x > maxX)
          maxX = p.x;
        else if (p.x < minX)
          minX = p.x;
        if (p.y > maxY)
          maxY = p.y;
        else if (p.y < minY)
          minY = p.y;
        if (v3) {
          if (p.z > maxZ)
            maxZ = p.z;
          else if (p.z < minZ)
            minZ = p.z;
        }
        sum.add(p);
      }
      var ret = {
        minX: minX,
        minY: minY,
        maxX: maxX,
        maxY: maxY
      };
      if (v3) {
        ret.maxZ = maxZ;
        ret.minZ = minZ;
      }
      return ret;
    };
    THREE.CurvePath.prototype.createPointsGeometry = function(divisions) {
      var pts = this.getPoints(divisions, true);
      return this.createGeometry(pts);
    };
    THREE.CurvePath.prototype.createSpacedPointsGeometry = function(divisions) {
      var pts = this.getSpacedPoints(divisions, true);
      return this.createGeometry(pts);
    };
    THREE.CurvePath.prototype.createGeometry = function(points) {
      var geometry = new THREE.Geometry();
      for (var i = 0; i < points.length; i++) {
        geometry.vertices.push(new THREE.Vector3(points[i].x, points[i].y, points[i].z || 0));
      }
      return geometry;
    };
    THREE.CurvePath.prototype.addWrapPath = function(bendpath) {
      this.bends.push(bendpath);
    };
    THREE.CurvePath.prototype.getTransformedPoints = function(segments, bends) {
      var oldPts = this.getPoints(segments);
      var i,
          il;
      if (!bends) {
        bends = this.bends;
      }
      for (i = 0, il = bends.length; i < il; i++) {
        oldPts = this.getWrapPoints(oldPts, bends[i]);
      }
      return oldPts;
    };
    THREE.CurvePath.prototype.getTransformedSpacedPoints = function(segments, bends) {
      var oldPts = this.getSpacedPoints(segments);
      var i,
          il;
      if (!bends) {
        bends = this.bends;
      }
      for (i = 0, il = bends.length; i < il; i++) {
        oldPts = this.getWrapPoints(oldPts, bends[i]);
      }
      return oldPts;
    };
    THREE.CurvePath.prototype.getWrapPoints = function(oldPts, path) {
      var bounds = this.getBoundingBox();
      var i,
          il,
          p,
          oldX,
          oldY,
          xNorm;
      for (i = 0, il = oldPts.length; i < il; i++) {
        p = oldPts[i];
        oldX = p.x;
        oldY = p.y;
        xNorm = oldX / bounds.maxX;
        xNorm = path.getUtoTmapping(xNorm, oldX);
        var pathPt = path.getPoint(xNorm);
        var normal = path.getTangent(xNorm);
        normal.set(-normal.y, normal.x).multiplyScalar(oldY);
        p.x = pathPt.x + normal.x;
        p.y = pathPt.y + normal.y;
      }
      return oldPts;
    };
    THREE.Gyroscope = function() {
      THREE.Object3D.call(this);
    };
    THREE.Gyroscope.prototype = Object.create(THREE.Object3D.prototype);
    THREE.Gyroscope.prototype.constructor = THREE.Gyroscope;
    THREE.Gyroscope.prototype.updateMatrixWorld = (function() {
      var translationObject = new THREE.Vector3();
      var quaternionObject = new THREE.Quaternion();
      var scaleObject = new THREE.Vector3();
      var translationWorld = new THREE.Vector3();
      var quaternionWorld = new THREE.Quaternion();
      var scaleWorld = new THREE.Vector3();
      return function(force) {
        this.matrixAutoUpdate && this.updateMatrix();
        if (this.matrixWorldNeedsUpdate || force) {
          if (this.parent) {
            this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix);
            this.matrixWorld.decompose(translationWorld, quaternionWorld, scaleWorld);
            this.matrix.decompose(translationObject, quaternionObject, scaleObject);
            this.matrixWorld.compose(translationWorld, quaternionObject, scaleWorld);
          } else {
            this.matrixWorld.copy(this.matrix);
          }
          this.matrixWorldNeedsUpdate = false;
          force = true;
        }
        for (var i = 0,
            l = this.children.length; i < l; i++) {
          this.children[i].updateMatrixWorld(force);
        }
      };
    }());
    THREE.Path = function(points) {
      THREE.CurvePath.call(this);
      this.actions = [];
      if (points) {
        this.fromPoints(points);
      }
    };
    THREE.Path.prototype = Object.create(THREE.CurvePath.prototype);
    THREE.Path.prototype.constructor = THREE.Path;
    THREE.PathActions = {
      MOVE_TO: 'moveTo',
      LINE_TO: 'lineTo',
      QUADRATIC_CURVE_TO: 'quadraticCurveTo',
      BEZIER_CURVE_TO: 'bezierCurveTo',
      CSPLINE_THRU: 'splineThru',
      ARC: 'arc',
      ELLIPSE: 'ellipse'
    };
    THREE.Path.prototype.fromPoints = function(vectors) {
      this.moveTo(vectors[0].x, vectors[0].y);
      for (var v = 1,
          vlen = vectors.length; v < vlen; v++) {
        this.lineTo(vectors[v].x, vectors[v].y);
      }
      ;
    };
    THREE.Path.prototype.moveTo = function(x, y) {
      var args = Array.prototype.slice.call(arguments);
      this.actions.push({
        action: THREE.PathActions.MOVE_TO,
        args: args
      });
    };
    THREE.Path.prototype.lineTo = function(x, y) {
      var args = Array.prototype.slice.call(arguments);
      var lastargs = this.actions[this.actions.length - 1].args;
      var x0 = lastargs[lastargs.length - 2];
      var y0 = lastargs[lastargs.length - 1];
      var curve = new THREE.LineCurve(new THREE.Vector2(x0, y0), new THREE.Vector2(x, y));
      this.curves.push(curve);
      this.actions.push({
        action: THREE.PathActions.LINE_TO,
        args: args
      });
    };
    THREE.Path.prototype.quadraticCurveTo = function(aCPx, aCPy, aX, aY) {
      var args = Array.prototype.slice.call(arguments);
      var lastargs = this.actions[this.actions.length - 1].args;
      var x0 = lastargs[lastargs.length - 2];
      var y0 = lastargs[lastargs.length - 1];
      var curve = new THREE.QuadraticBezierCurve(new THREE.Vector2(x0, y0), new THREE.Vector2(aCPx, aCPy), new THREE.Vector2(aX, aY));
      this.curves.push(curve);
      this.actions.push({
        action: THREE.PathActions.QUADRATIC_CURVE_TO,
        args: args
      });
    };
    THREE.Path.prototype.bezierCurveTo = function(aCP1x, aCP1y, aCP2x, aCP2y, aX, aY) {
      var args = Array.prototype.slice.call(arguments);
      var lastargs = this.actions[this.actions.length - 1].args;
      var x0 = lastargs[lastargs.length - 2];
      var y0 = lastargs[lastargs.length - 1];
      var curve = new THREE.CubicBezierCurve(new THREE.Vector2(x0, y0), new THREE.Vector2(aCP1x, aCP1y), new THREE.Vector2(aCP2x, aCP2y), new THREE.Vector2(aX, aY));
      this.curves.push(curve);
      this.actions.push({
        action: THREE.PathActions.BEZIER_CURVE_TO,
        args: args
      });
    };
    THREE.Path.prototype.splineThru = function(pts) {
      var args = Array.prototype.slice.call(arguments);
      var lastargs = this.actions[this.actions.length - 1].args;
      var x0 = lastargs[lastargs.length - 2];
      var y0 = lastargs[lastargs.length - 1];
      var npts = [new THREE.Vector2(x0, y0)];
      Array.prototype.push.apply(npts, pts);
      var curve = new THREE.SplineCurve(npts);
      this.curves.push(curve);
      this.actions.push({
        action: THREE.PathActions.CSPLINE_THRU,
        args: args
      });
    };
    THREE.Path.prototype.arc = function(aX, aY, aRadius, aStartAngle, aEndAngle, aClockwise) {
      var lastargs = this.actions[this.actions.length - 1].args;
      var x0 = lastargs[lastargs.length - 2];
      var y0 = lastargs[lastargs.length - 1];
      this.absarc(aX + x0, aY + y0, aRadius, aStartAngle, aEndAngle, aClockwise);
    };
    THREE.Path.prototype.absarc = function(aX, aY, aRadius, aStartAngle, aEndAngle, aClockwise) {
      this.absellipse(aX, aY, aRadius, aRadius, aStartAngle, aEndAngle, aClockwise);
    };
    THREE.Path.prototype.ellipse = function(aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise) {
      var lastargs = this.actions[this.actions.length - 1].args;
      var x0 = lastargs[lastargs.length - 2];
      var y0 = lastargs[lastargs.length - 1];
      this.absellipse(aX + x0, aY + y0, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise);
    };
    THREE.Path.prototype.absellipse = function(aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise) {
      var args = Array.prototype.slice.call(arguments);
      var curve = new THREE.EllipseCurve(aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise);
      this.curves.push(curve);
      var lastPoint = curve.getPoint(1);
      args.push(lastPoint.x);
      args.push(lastPoint.y);
      this.actions.push({
        action: THREE.PathActions.ELLIPSE,
        args: args
      });
    };
    THREE.Path.prototype.getSpacedPoints = function(divisions, closedPath) {
      if (!divisions)
        divisions = 40;
      var points = [];
      for (var i = 0; i < divisions; i++) {
        points.push(this.getPoint(i / divisions));
      }
      return points;
    };
    THREE.Path.prototype.getPoints = function(divisions, closedPath) {
      if (this.useSpacedPoints) {
        console.log('tata');
        return this.getSpacedPoints(divisions, closedPath);
      }
      divisions = divisions || 12;
      var points = [];
      var i,
          il,
          item,
          action,
          args;
      var cpx,
          cpy,
          cpx2,
          cpy2,
          cpx1,
          cpy1,
          cpx0,
          cpy0,
          laste,
          j,
          t,
          tx,
          ty;
      for (i = 0, il = this.actions.length; i < il; i++) {
        item = this.actions[i];
        action = item.action;
        args = item.args;
        switch (action) {
          case THREE.PathActions.MOVE_TO:
            points.push(new THREE.Vector2(args[0], args[1]));
            break;
          case THREE.PathActions.LINE_TO:
            points.push(new THREE.Vector2(args[0], args[1]));
            break;
          case THREE.PathActions.QUADRATIC_CURVE_TO:
            cpx = args[2];
            cpy = args[3];
            cpx1 = args[0];
            cpy1 = args[1];
            if (points.length > 0) {
              laste = points[points.length - 1];
              cpx0 = laste.x;
              cpy0 = laste.y;
            } else {
              laste = this.actions[i - 1].args;
              cpx0 = laste[laste.length - 2];
              cpy0 = laste[laste.length - 1];
            }
            for (j = 1; j <= divisions; j++) {
              t = j / divisions;
              tx = THREE.Shape.Utils.b2(t, cpx0, cpx1, cpx);
              ty = THREE.Shape.Utils.b2(t, cpy0, cpy1, cpy);
              points.push(new THREE.Vector2(tx, ty));
            }
            break;
          case THREE.PathActions.BEZIER_CURVE_TO:
            cpx = args[4];
            cpy = args[5];
            cpx1 = args[0];
            cpy1 = args[1];
            cpx2 = args[2];
            cpy2 = args[3];
            if (points.length > 0) {
              laste = points[points.length - 1];
              cpx0 = laste.x;
              cpy0 = laste.y;
            } else {
              laste = this.actions[i - 1].args;
              cpx0 = laste[laste.length - 2];
              cpy0 = laste[laste.length - 1];
            }
            for (j = 1; j <= divisions; j++) {
              t = j / divisions;
              tx = THREE.Shape.Utils.b3(t, cpx0, cpx1, cpx2, cpx);
              ty = THREE.Shape.Utils.b3(t, cpy0, cpy1, cpy2, cpy);
              points.push(new THREE.Vector2(tx, ty));
            }
            break;
          case THREE.PathActions.CSPLINE_THRU:
            laste = this.actions[i - 1].args;
            var last = new THREE.Vector2(laste[laste.length - 2], laste[laste.length - 1]);
            var spts = [last];
            var n = divisions * args[0].length;
            spts = spts.concat(args[0]);
            var spline = new THREE.SplineCurve(spts);
            for (j = 1; j <= n; j++) {
              points.push(spline.getPointAt(j / n));
            }
            break;
          case THREE.PathActions.ARC:
            var aX = args[0],
                aY = args[1],
                aRadius = args[2],
                aStartAngle = args[3],
                aEndAngle = args[4],
                aClockwise = !!args[5];
            var deltaAngle = aEndAngle - aStartAngle;
            var angle;
            var tdivisions = divisions * 2;
            for (j = 1; j <= tdivisions; j++) {
              t = j / tdivisions;
              if (!aClockwise) {
                t = 1 - t;
              }
              angle = aStartAngle + t * deltaAngle;
              tx = aX + aRadius * Math.cos(angle);
              ty = aY + aRadius * Math.sin(angle);
              points.push(new THREE.Vector2(tx, ty));
            }
            break;
          case THREE.PathActions.ELLIPSE:
            var aX = args[0],
                aY = args[1],
                xRadius = args[2],
                yRadius = args[3],
                aStartAngle = args[4],
                aEndAngle = args[5],
                aClockwise = !!args[6];
            var deltaAngle = aEndAngle - aStartAngle;
            var angle;
            var tdivisions = divisions * 2;
            for (j = 1; j <= tdivisions; j++) {
              t = j / tdivisions;
              if (!aClockwise) {
                t = 1 - t;
              }
              angle = aStartAngle + t * deltaAngle;
              tx = aX + xRadius * Math.cos(angle);
              ty = aY + yRadius * Math.sin(angle);
              points.push(new THREE.Vector2(tx, ty));
            }
            break;
        }
      }
      var lastPoint = points[points.length - 1];
      var EPSILON = 0.0000000001;
      if (Math.abs(lastPoint.x - points[0].x) < EPSILON && Math.abs(lastPoint.y - points[0].y) < EPSILON)
        points.splice(points.length - 1, 1);
      if (closedPath) {
        points.push(points[0]);
      }
      return points;
    };
    THREE.Path.prototype.toShapes = function(isCCW, noHoles) {
      function extractSubpaths(inActions) {
        var i,
            il,
            item,
            action,
            args;
        var subPaths = [],
            lastPath = new THREE.Path();
        for (i = 0, il = inActions.length; i < il; i++) {
          item = inActions[i];
          args = item.args;
          action = item.action;
          if (action == THREE.PathActions.MOVE_TO) {
            if (lastPath.actions.length != 0) {
              subPaths.push(lastPath);
              lastPath = new THREE.Path();
            }
          }
          lastPath[action].apply(lastPath, args);
        }
        if (lastPath.actions.length != 0) {
          subPaths.push(lastPath);
        }
        return subPaths;
      }
      function toShapesNoHoles(inSubpaths) {
        var shapes = [];
        for (var i = 0,
            il = inSubpaths.length; i < il; i++) {
          var tmpPath = inSubpaths[i];
          var tmpShape = new THREE.Shape();
          tmpShape.actions = tmpPath.actions;
          tmpShape.curves = tmpPath.curves;
          shapes.push(tmpShape);
        }
        return shapes;
      }
      ;
      function isPointInsidePolygon(inPt, inPolygon) {
        var EPSILON = 0.0000000001;
        var polyLen = inPolygon.length;
        var inside = false;
        for (var p = polyLen - 1,
            q = 0; q < polyLen; p = q++) {
          var edgeLowPt = inPolygon[p];
          var edgeHighPt = inPolygon[q];
          var edgeDx = edgeHighPt.x - edgeLowPt.x;
          var edgeDy = edgeHighPt.y - edgeLowPt.y;
          if (Math.abs(edgeDy) > EPSILON) {
            if (edgeDy < 0) {
              edgeLowPt = inPolygon[q];
              edgeDx = -edgeDx;
              edgeHighPt = inPolygon[p];
              edgeDy = -edgeDy;
            }
            if ((inPt.y < edgeLowPt.y) || (inPt.y > edgeHighPt.y))
              continue;
            if (inPt.y == edgeLowPt.y) {
              if (inPt.x == edgeLowPt.x)
                return true;
            } else {
              var perpEdge = edgeDy * (inPt.x - edgeLowPt.x) - edgeDx * (inPt.y - edgeLowPt.y);
              if (perpEdge == 0)
                return true;
              if (perpEdge < 0)
                continue;
              inside = !inside;
            }
          } else {
            if (inPt.y != edgeLowPt.y)
              continue;
            if (((edgeHighPt.x <= inPt.x) && (inPt.x <= edgeLowPt.x)) || ((edgeLowPt.x <= inPt.x) && (inPt.x <= edgeHighPt.x)))
              return true;
          }
        }
        return inside;
      }
      var subPaths = extractSubpaths(this.actions);
      if (subPaths.length == 0)
        return [];
      if (noHoles === true)
        return toShapesNoHoles(subPaths);
      var solid,
          tmpPath,
          tmpShape,
          shapes = [];
      if (subPaths.length == 1) {
        tmpPath = subPaths[0];
        tmpShape = new THREE.Shape();
        tmpShape.actions = tmpPath.actions;
        tmpShape.curves = tmpPath.curves;
        shapes.push(tmpShape);
        return shapes;
      }
      var holesFirst = !THREE.Shape.Utils.isClockWise(subPaths[0].getPoints());
      holesFirst = isCCW ? !holesFirst : holesFirst;
      var betterShapeHoles = [];
      var newShapes = [];
      var newShapeHoles = [];
      var mainIdx = 0;
      var tmpPoints;
      newShapes[mainIdx] = undefined;
      newShapeHoles[mainIdx] = [];
      var i,
          il;
      for (i = 0, il = subPaths.length; i < il; i++) {
        tmpPath = subPaths[i];
        tmpPoints = tmpPath.getPoints();
        solid = THREE.Shape.Utils.isClockWise(tmpPoints);
        solid = isCCW ? !solid : solid;
        if (solid) {
          if ((!holesFirst) && (newShapes[mainIdx]))
            mainIdx++;
          newShapes[mainIdx] = {
            s: new THREE.Shape(),
            p: tmpPoints
          };
          newShapes[mainIdx].s.actions = tmpPath.actions;
          newShapes[mainIdx].s.curves = tmpPath.curves;
          if (holesFirst)
            mainIdx++;
          newShapeHoles[mainIdx] = [];
        } else {
          newShapeHoles[mainIdx].push({
            h: tmpPath,
            p: tmpPoints[0]
          });
        }
      }
      if (!newShapes[0])
        return toShapesNoHoles(subPaths);
      if (newShapes.length > 1) {
        var ambigious = false;
        var toChange = [];
        for (var sIdx = 0,
            sLen = newShapes.length; sIdx < sLen; sIdx++) {
          betterShapeHoles[sIdx] = [];
        }
        for (var sIdx = 0,
            sLen = newShapes.length; sIdx < sLen; sIdx++) {
          var sho = newShapeHoles[sIdx];
          for (var hIdx = 0; hIdx < sho.length; hIdx++) {
            var ho = sho[hIdx];
            var hole_unassigned = true;
            for (var s2Idx = 0; s2Idx < newShapes.length; s2Idx++) {
              if (isPointInsidePolygon(ho.p, newShapes[s2Idx].p)) {
                if (sIdx != s2Idx)
                  toChange.push({
                    froms: sIdx,
                    tos: s2Idx,
                    hole: hIdx
                  });
                if (hole_unassigned) {
                  hole_unassigned = false;
                  betterShapeHoles[s2Idx].push(ho);
                } else {
                  ambigious = true;
                }
              }
            }
            if (hole_unassigned) {
              betterShapeHoles[sIdx].push(ho);
            }
          }
        }
        if (toChange.length > 0) {
          if (!ambigious)
            newShapeHoles = betterShapeHoles;
        }
      }
      var tmpHoles,
          j,
          jl;
      for (i = 0, il = newShapes.length; i < il; i++) {
        tmpShape = newShapes[i].s;
        shapes.push(tmpShape);
        tmpHoles = newShapeHoles[i];
        for (j = 0, jl = tmpHoles.length; j < jl; j++) {
          tmpShape.holes.push(tmpHoles[j].h);
        }
      }
      return shapes;
    };
    THREE.Shape = function() {
      THREE.Path.apply(this, arguments);
      this.holes = [];
    };
    THREE.Shape.prototype = Object.create(THREE.Path.prototype);
    THREE.Shape.prototype.constructor = THREE.Shape;
    THREE.Shape.prototype.extrude = function(options) {
      var extruded = new THREE.ExtrudeGeometry(this, options);
      return extruded;
    };
    THREE.Shape.prototype.makeGeometry = function(options) {
      var geometry = new THREE.ShapeGeometry(this, options);
      return geometry;
    };
    THREE.Shape.prototype.getPointsHoles = function(divisions) {
      var i,
          il = this.holes.length,
          holesPts = [];
      for (i = 0; i < il; i++) {
        holesPts[i] = this.holes[i].getTransformedPoints(divisions, this.bends);
      }
      return holesPts;
    };
    THREE.Shape.prototype.getSpacedPointsHoles = function(divisions) {
      var i,
          il = this.holes.length,
          holesPts = [];
      for (i = 0; i < il; i++) {
        holesPts[i] = this.holes[i].getTransformedSpacedPoints(divisions, this.bends);
      }
      return holesPts;
    };
    THREE.Shape.prototype.extractAllPoints = function(divisions) {
      return {
        shape: this.getTransformedPoints(divisions),
        holes: this.getPointsHoles(divisions)
      };
    };
    THREE.Shape.prototype.extractPoints = function(divisions) {
      if (this.useSpacedPoints) {
        return this.extractAllSpacedPoints(divisions);
      }
      return this.extractAllPoints(divisions);
    };
    THREE.Shape.prototype.extractAllSpacedPoints = function(divisions) {
      return {
        shape: this.getTransformedSpacedPoints(divisions),
        holes: this.getSpacedPointsHoles(divisions)
      };
    };
    THREE.Shape.Utils = {
      triangulateShape: function(contour, holes) {
        function point_in_segment_2D_colin(inSegPt1, inSegPt2, inOtherPt) {
          if (inSegPt1.x != inSegPt2.x) {
            if (inSegPt1.x < inSegPt2.x) {
              return ((inSegPt1.x <= inOtherPt.x) && (inOtherPt.x <= inSegPt2.x));
            } else {
              return ((inSegPt2.x <= inOtherPt.x) && (inOtherPt.x <= inSegPt1.x));
            }
          } else {
            if (inSegPt1.y < inSegPt2.y) {
              return ((inSegPt1.y <= inOtherPt.y) && (inOtherPt.y <= inSegPt2.y));
            } else {
              return ((inSegPt2.y <= inOtherPt.y) && (inOtherPt.y <= inSegPt1.y));
            }
          }
        }
        function intersect_segments_2D(inSeg1Pt1, inSeg1Pt2, inSeg2Pt1, inSeg2Pt2, inExcludeAdjacentSegs) {
          var EPSILON = 0.0000000001;
          var seg1dx = inSeg1Pt2.x - inSeg1Pt1.x,
              seg1dy = inSeg1Pt2.y - inSeg1Pt1.y;
          var seg2dx = inSeg2Pt2.x - inSeg2Pt1.x,
              seg2dy = inSeg2Pt2.y - inSeg2Pt1.y;
          var seg1seg2dx = inSeg1Pt1.x - inSeg2Pt1.x;
          var seg1seg2dy = inSeg1Pt1.y - inSeg2Pt1.y;
          var limit = seg1dy * seg2dx - seg1dx * seg2dy;
          var perpSeg1 = seg1dy * seg1seg2dx - seg1dx * seg1seg2dy;
          if (Math.abs(limit) > EPSILON) {
            var perpSeg2;
            if (limit > 0) {
              if ((perpSeg1 < 0) || (perpSeg1 > limit))
                return [];
              perpSeg2 = seg2dy * seg1seg2dx - seg2dx * seg1seg2dy;
              if ((perpSeg2 < 0) || (perpSeg2 > limit))
                return [];
            } else {
              if ((perpSeg1 > 0) || (perpSeg1 < limit))
                return [];
              perpSeg2 = seg2dy * seg1seg2dx - seg2dx * seg1seg2dy;
              if ((perpSeg2 > 0) || (perpSeg2 < limit))
                return [];
            }
            if (perpSeg2 == 0) {
              if ((inExcludeAdjacentSegs) && ((perpSeg1 == 0) || (perpSeg1 == limit)))
                return [];
              return [inSeg1Pt1];
            }
            if (perpSeg2 == limit) {
              if ((inExcludeAdjacentSegs) && ((perpSeg1 == 0) || (perpSeg1 == limit)))
                return [];
              return [inSeg1Pt2];
            }
            if (perpSeg1 == 0)
              return [inSeg2Pt1];
            if (perpSeg1 == limit)
              return [inSeg2Pt2];
            var factorSeg1 = perpSeg2 / limit;
            return [{
              x: inSeg1Pt1.x + factorSeg1 * seg1dx,
              y: inSeg1Pt1.y + factorSeg1 * seg1dy
            }];
          } else {
            if ((perpSeg1 != 0) || (seg2dy * seg1seg2dx != seg2dx * seg1seg2dy))
              return [];
            var seg1Pt = ((seg1dx == 0) && (seg1dy == 0));
            var seg2Pt = ((seg2dx == 0) && (seg2dy == 0));
            if (seg1Pt && seg2Pt) {
              if ((inSeg1Pt1.x != inSeg2Pt1.x) || (inSeg1Pt1.y != inSeg2Pt1.y))
                return [];
              return [inSeg1Pt1];
            }
            if (seg1Pt) {
              if (!point_in_segment_2D_colin(inSeg2Pt1, inSeg2Pt2, inSeg1Pt1))
                return [];
              return [inSeg1Pt1];
            }
            if (seg2Pt) {
              if (!point_in_segment_2D_colin(inSeg1Pt1, inSeg1Pt2, inSeg2Pt1))
                return [];
              return [inSeg2Pt1];
            }
            var seg1min,
                seg1max,
                seg1minVal,
                seg1maxVal;
            var seg2min,
                seg2max,
                seg2minVal,
                seg2maxVal;
            if (seg1dx != 0) {
              if (inSeg1Pt1.x < inSeg1Pt2.x) {
                seg1min = inSeg1Pt1;
                seg1minVal = inSeg1Pt1.x;
                seg1max = inSeg1Pt2;
                seg1maxVal = inSeg1Pt2.x;
              } else {
                seg1min = inSeg1Pt2;
                seg1minVal = inSeg1Pt2.x;
                seg1max = inSeg1Pt1;
                seg1maxVal = inSeg1Pt1.x;
              }
              if (inSeg2Pt1.x < inSeg2Pt2.x) {
                seg2min = inSeg2Pt1;
                seg2minVal = inSeg2Pt1.x;
                seg2max = inSeg2Pt2;
                seg2maxVal = inSeg2Pt2.x;
              } else {
                seg2min = inSeg2Pt2;
                seg2minVal = inSeg2Pt2.x;
                seg2max = inSeg2Pt1;
                seg2maxVal = inSeg2Pt1.x;
              }
            } else {
              if (inSeg1Pt1.y < inSeg1Pt2.y) {
                seg1min = inSeg1Pt1;
                seg1minVal = inSeg1Pt1.y;
                seg1max = inSeg1Pt2;
                seg1maxVal = inSeg1Pt2.y;
              } else {
                seg1min = inSeg1Pt2;
                seg1minVal = inSeg1Pt2.y;
                seg1max = inSeg1Pt1;
                seg1maxVal = inSeg1Pt1.y;
              }
              if (inSeg2Pt1.y < inSeg2Pt2.y) {
                seg2min = inSeg2Pt1;
                seg2minVal = inSeg2Pt1.y;
                seg2max = inSeg2Pt2;
                seg2maxVal = inSeg2Pt2.y;
              } else {
                seg2min = inSeg2Pt2;
                seg2minVal = inSeg2Pt2.y;
                seg2max = inSeg2Pt1;
                seg2maxVal = inSeg2Pt1.y;
              }
            }
            if (seg1minVal <= seg2minVal) {
              if (seg1maxVal < seg2minVal)
                return [];
              if (seg1maxVal == seg2minVal) {
                if (inExcludeAdjacentSegs)
                  return [];
                return [seg2min];
              }
              if (seg1maxVal <= seg2maxVal)
                return [seg2min, seg1max];
              return [seg2min, seg2max];
            } else {
              if (seg1minVal > seg2maxVal)
                return [];
              if (seg1minVal == seg2maxVal) {
                if (inExcludeAdjacentSegs)
                  return [];
                return [seg1min];
              }
              if (seg1maxVal <= seg2maxVal)
                return [seg1min, seg1max];
              return [seg1min, seg2max];
            }
          }
        }
        function isPointInsideAngle(inVertex, inLegFromPt, inLegToPt, inOtherPt) {
          var EPSILON = 0.0000000001;
          var legFromPtX = inLegFromPt.x - inVertex.x,
              legFromPtY = inLegFromPt.y - inVertex.y;
          var legToPtX = inLegToPt.x - inVertex.x,
              legToPtY = inLegToPt.y - inVertex.y;
          var otherPtX = inOtherPt.x - inVertex.x,
              otherPtY = inOtherPt.y - inVertex.y;
          var from2toAngle = legFromPtX * legToPtY - legFromPtY * legToPtX;
          var from2otherAngle = legFromPtX * otherPtY - legFromPtY * otherPtX;
          if (Math.abs(from2toAngle) > EPSILON) {
            var other2toAngle = otherPtX * legToPtY - otherPtY * legToPtX;
            if (from2toAngle > 0) {
              return ((from2otherAngle >= 0) && (other2toAngle >= 0));
            } else {
              return ((from2otherAngle >= 0) || (other2toAngle >= 0));
            }
          } else {
            return (from2otherAngle > 0);
          }
        }
        function removeHoles(contour, holes) {
          var shape = contour.concat();
          var hole;
          function isCutLineInsideAngles(inShapeIdx, inHoleIdx) {
            var lastShapeIdx = shape.length - 1;
            var prevShapeIdx = inShapeIdx - 1;
            if (prevShapeIdx < 0)
              prevShapeIdx = lastShapeIdx;
            var nextShapeIdx = inShapeIdx + 1;
            if (nextShapeIdx > lastShapeIdx)
              nextShapeIdx = 0;
            var insideAngle = isPointInsideAngle(shape[inShapeIdx], shape[prevShapeIdx], shape[nextShapeIdx], hole[inHoleIdx]);
            if (!insideAngle) {
              return false;
            }
            var lastHoleIdx = hole.length - 1;
            var prevHoleIdx = inHoleIdx - 1;
            if (prevHoleIdx < 0)
              prevHoleIdx = lastHoleIdx;
            var nextHoleIdx = inHoleIdx + 1;
            if (nextHoleIdx > lastHoleIdx)
              nextHoleIdx = 0;
            insideAngle = isPointInsideAngle(hole[inHoleIdx], hole[prevHoleIdx], hole[nextHoleIdx], shape[inShapeIdx]);
            if (!insideAngle) {
              return false;
            }
            return true;
          }
          function intersectsShapeEdge(inShapePt, inHolePt) {
            var sIdx,
                nextIdx,
                intersection;
            for (sIdx = 0; sIdx < shape.length; sIdx++) {
              nextIdx = sIdx + 1;
              nextIdx %= shape.length;
              intersection = intersect_segments_2D(inShapePt, inHolePt, shape[sIdx], shape[nextIdx], true);
              if (intersection.length > 0)
                return true;
            }
            return false;
          }
          var indepHoles = [];
          function intersectsHoleEdge(inShapePt, inHolePt) {
            var ihIdx,
                chkHole,
                hIdx,
                nextIdx,
                intersection;
            for (ihIdx = 0; ihIdx < indepHoles.length; ihIdx++) {
              chkHole = holes[indepHoles[ihIdx]];
              for (hIdx = 0; hIdx < chkHole.length; hIdx++) {
                nextIdx = hIdx + 1;
                nextIdx %= chkHole.length;
                intersection = intersect_segments_2D(inShapePt, inHolePt, chkHole[hIdx], chkHole[nextIdx], true);
                if (intersection.length > 0)
                  return true;
              }
            }
            return false;
          }
          var holeIndex,
              shapeIndex,
              shapePt,
              holePt,
              holeIdx,
              cutKey,
              failedCuts = [],
              tmpShape1,
              tmpShape2,
              tmpHole1,
              tmpHole2;
          for (var h = 0,
              hl = holes.length; h < hl; h++) {
            indepHoles.push(h);
          }
          var minShapeIndex = 0;
          var counter = indepHoles.length * 2;
          while (indepHoles.length > 0) {
            counter--;
            if (counter < 0) {
              console.log("Infinite Loop! Holes left:" + indepHoles.length + ", Probably Hole outside Shape!");
              break;
            }
            for (shapeIndex = minShapeIndex; shapeIndex < shape.length; shapeIndex++) {
              shapePt = shape[shapeIndex];
              holeIndex = -1;
              for (var h = 0; h < indepHoles.length; h++) {
                holeIdx = indepHoles[h];
                cutKey = shapePt.x + ":" + shapePt.y + ":" + holeIdx;
                if (failedCuts[cutKey] !== undefined)
                  continue;
                hole = holes[holeIdx];
                for (var h2 = 0; h2 < hole.length; h2++) {
                  holePt = hole[h2];
                  if (!isCutLineInsideAngles(shapeIndex, h2))
                    continue;
                  if (intersectsShapeEdge(shapePt, holePt))
                    continue;
                  if (intersectsHoleEdge(shapePt, holePt))
                    continue;
                  holeIndex = h2;
                  indepHoles.splice(h, 1);
                  tmpShape1 = shape.slice(0, shapeIndex + 1);
                  tmpShape2 = shape.slice(shapeIndex);
                  tmpHole1 = hole.slice(holeIndex);
                  tmpHole2 = hole.slice(0, holeIndex + 1);
                  shape = tmpShape1.concat(tmpHole1).concat(tmpHole2).concat(tmpShape2);
                  minShapeIndex = shapeIndex;
                  break;
                }
                if (holeIndex >= 0)
                  break;
                failedCuts[cutKey] = true;
              }
              if (holeIndex >= 0)
                break;
            }
          }
          return shape;
        }
        var i,
            il,
            f,
            face,
            key,
            index,
            allPointsMap = {};
        var allpoints = contour.concat();
        for (var h = 0,
            hl = holes.length; h < hl; h++) {
          Array.prototype.push.apply(allpoints, holes[h]);
        }
        for (i = 0, il = allpoints.length; i < il; i++) {
          key = allpoints[i].x + ":" + allpoints[i].y;
          if (allPointsMap[key] !== undefined) {
            THREE.warn("THREE.Shape: Duplicate point", key);
          }
          allPointsMap[key] = i;
        }
        var shapeWithoutHoles = removeHoles(contour, holes);
        var triangles = THREE.FontUtils.Triangulate(shapeWithoutHoles, false);
        for (i = 0, il = triangles.length; i < il; i++) {
          face = triangles[i];
          for (f = 0; f < 3; f++) {
            key = face[f].x + ":" + face[f].y;
            index = allPointsMap[key];
            if (index !== undefined) {
              face[f] = index;
            }
          }
        }
        return triangles.concat();
      },
      isClockWise: function(pts) {
        return THREE.FontUtils.Triangulate.area(pts) < 0;
      },
      b2p0: function(t, p) {
        var k = 1 - t;
        return k * k * p;
      },
      b2p1: function(t, p) {
        return 2 * (1 - t) * t * p;
      },
      b2p2: function(t, p) {
        return t * t * p;
      },
      b2: function(t, p0, p1, p2) {
        return this.b2p0(t, p0) + this.b2p1(t, p1) + this.b2p2(t, p2);
      },
      b3p0: function(t, p) {
        var k = 1 - t;
        return k * k * k * p;
      },
      b3p1: function(t, p) {
        var k = 1 - t;
        return 3 * k * k * t * p;
      },
      b3p2: function(t, p) {
        var k = 1 - t;
        return 3 * k * t * t * p;
      },
      b3p3: function(t, p) {
        return t * t * t * p;
      },
      b3: function(t, p0, p1, p2, p3) {
        return this.b3p0(t, p0) + this.b3p1(t, p1) + this.b3p2(t, p2) + this.b3p3(t, p3);
      }
    };
    THREE.LineCurve = function(v1, v2) {
      this.v1 = v1;
      this.v2 = v2;
    };
    THREE.LineCurve.prototype = Object.create(THREE.Curve.prototype);
    THREE.LineCurve.prototype.constructor = THREE.LineCurve;
    THREE.LineCurve.prototype.getPoint = function(t) {
      var point = this.v2.clone().sub(this.v1);
      point.multiplyScalar(t).add(this.v1);
      return point;
    };
    THREE.LineCurve.prototype.getPointAt = function(u) {
      return this.getPoint(u);
    };
    THREE.LineCurve.prototype.getTangent = function(t) {
      var tangent = this.v2.clone().sub(this.v1);
      return tangent.normalize();
    };
    THREE.QuadraticBezierCurve = function(v0, v1, v2) {
      this.v0 = v0;
      this.v1 = v1;
      this.v2 = v2;
    };
    THREE.QuadraticBezierCurve.prototype = Object.create(THREE.Curve.prototype);
    THREE.QuadraticBezierCurve.prototype.constructor = THREE.QuadraticBezierCurve;
    THREE.QuadraticBezierCurve.prototype.getPoint = function(t) {
      var vector = new THREE.Vector2();
      vector.x = THREE.Shape.Utils.b2(t, this.v0.x, this.v1.x, this.v2.x);
      vector.y = THREE.Shape.Utils.b2(t, this.v0.y, this.v1.y, this.v2.y);
      return vector;
    };
    THREE.QuadraticBezierCurve.prototype.getTangent = function(t) {
      var vector = new THREE.Vector2();
      vector.x = THREE.Curve.Utils.tangentQuadraticBezier(t, this.v0.x, this.v1.x, this.v2.x);
      vector.y = THREE.Curve.Utils.tangentQuadraticBezier(t, this.v0.y, this.v1.y, this.v2.y);
      return vector.normalize();
    };
    THREE.CubicBezierCurve = function(v0, v1, v2, v3) {
      this.v0 = v0;
      this.v1 = v1;
      this.v2 = v2;
      this.v3 = v3;
    };
    THREE.CubicBezierCurve.prototype = Object.create(THREE.Curve.prototype);
    THREE.CubicBezierCurve.prototype.constructor = THREE.CubicBezierCurve;
    THREE.CubicBezierCurve.prototype.getPoint = function(t) {
      var tx,
          ty;
      tx = THREE.Shape.Utils.b3(t, this.v0.x, this.v1.x, this.v2.x, this.v3.x);
      ty = THREE.Shape.Utils.b3(t, this.v0.y, this.v1.y, this.v2.y, this.v3.y);
      return new THREE.Vector2(tx, ty);
    };
    THREE.CubicBezierCurve.prototype.getTangent = function(t) {
      var tx,
          ty;
      tx = THREE.Curve.Utils.tangentCubicBezier(t, this.v0.x, this.v1.x, this.v2.x, this.v3.x);
      ty = THREE.Curve.Utils.tangentCubicBezier(t, this.v0.y, this.v1.y, this.v2.y, this.v3.y);
      var tangent = new THREE.Vector2(tx, ty);
      tangent.normalize();
      return tangent;
    };
    THREE.SplineCurve = function(points) {
      this.points = (points == undefined) ? [] : points;
    };
    THREE.SplineCurve.prototype = Object.create(THREE.Curve.prototype);
    THREE.SplineCurve.prototype.constructor = THREE.SplineCurve;
    THREE.SplineCurve.prototype.getPoint = function(t) {
      var points = this.points;
      var point = (points.length - 1) * t;
      var intPoint = Math.floor(point);
      var weight = point - intPoint;
      var point0 = points[intPoint == 0 ? intPoint : intPoint - 1];
      var point1 = points[intPoint];
      var point2 = points[intPoint > points.length - 2 ? points.length - 1 : intPoint + 1];
      var point3 = points[intPoint > points.length - 3 ? points.length - 1 : intPoint + 2];
      var vector = new THREE.Vector2();
      vector.x = THREE.Curve.Utils.interpolate(point0.x, point1.x, point2.x, point3.x, weight);
      vector.y = THREE.Curve.Utils.interpolate(point0.y, point1.y, point2.y, point3.y, weight);
      return vector;
    };
    THREE.EllipseCurve = function(aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise) {
      this.aX = aX;
      this.aY = aY;
      this.xRadius = xRadius;
      this.yRadius = yRadius;
      this.aStartAngle = aStartAngle;
      this.aEndAngle = aEndAngle;
      this.aClockwise = aClockwise;
    };
    THREE.EllipseCurve.prototype = Object.create(THREE.Curve.prototype);
    THREE.EllipseCurve.prototype.constructor = THREE.EllipseCurve;
    THREE.EllipseCurve.prototype.getPoint = function(t) {
      var deltaAngle = this.aEndAngle - this.aStartAngle;
      if (deltaAngle < 0)
        deltaAngle += Math.PI * 2;
      if (deltaAngle > Math.PI * 2)
        deltaAngle -= Math.PI * 2;
      var angle;
      if (this.aClockwise === true) {
        angle = this.aEndAngle + (1 - t) * (Math.PI * 2 - deltaAngle);
      } else {
        angle = this.aStartAngle + t * deltaAngle;
      }
      var vector = new THREE.Vector2();
      vector.x = this.aX + this.xRadius * Math.cos(angle);
      vector.y = this.aY + this.yRadius * Math.sin(angle);
      return vector;
    };
    THREE.ArcCurve = function(aX, aY, aRadius, aStartAngle, aEndAngle, aClockwise) {
      THREE.EllipseCurve.call(this, aX, aY, aRadius, aRadius, aStartAngle, aEndAngle, aClockwise);
    };
    THREE.ArcCurve.prototype = Object.create(THREE.EllipseCurve.prototype);
    THREE.ArcCurve.prototype.constructor = THREE.ArcCurve;
    THREE.LineCurve3 = THREE.Curve.create(function(v1, v2) {
      this.v1 = v1;
      this.v2 = v2;
    }, function(t) {
      var vector = new THREE.Vector3();
      vector.subVectors(this.v2, this.v1);
      vector.multiplyScalar(t);
      vector.add(this.v1);
      return vector;
    });
    THREE.QuadraticBezierCurve3 = THREE.Curve.create(function(v0, v1, v2) {
      this.v0 = v0;
      this.v1 = v1;
      this.v2 = v2;
    }, function(t) {
      var vector = new THREE.Vector3();
      vector.x = THREE.Shape.Utils.b2(t, this.v0.x, this.v1.x, this.v2.x);
      vector.y = THREE.Shape.Utils.b2(t, this.v0.y, this.v1.y, this.v2.y);
      vector.z = THREE.Shape.Utils.b2(t, this.v0.z, this.v1.z, this.v2.z);
      return vector;
    });
    THREE.CubicBezierCurve3 = THREE.Curve.create(function(v0, v1, v2, v3) {
      this.v0 = v0;
      this.v1 = v1;
      this.v2 = v2;
      this.v3 = v3;
    }, function(t) {
      var vector = new THREE.Vector3();
      vector.x = THREE.Shape.Utils.b3(t, this.v0.x, this.v1.x, this.v2.x, this.v3.x);
      vector.y = THREE.Shape.Utils.b3(t, this.v0.y, this.v1.y, this.v2.y, this.v3.y);
      vector.z = THREE.Shape.Utils.b3(t, this.v0.z, this.v1.z, this.v2.z, this.v3.z);
      return vector;
    });
    THREE.SplineCurve3 = THREE.Curve.create(function(points) {
      this.points = (points == undefined) ? [] : points;
    }, function(t) {
      var points = this.points;
      var point = (points.length - 1) * t;
      var intPoint = Math.floor(point);
      var weight = point - intPoint;
      var point0 = points[intPoint == 0 ? intPoint : intPoint - 1];
      var point1 = points[intPoint];
      var point2 = points[intPoint > points.length - 2 ? points.length - 1 : intPoint + 1];
      var point3 = points[intPoint > points.length - 3 ? points.length - 1 : intPoint + 2];
      var vector = new THREE.Vector3();
      vector.x = THREE.Curve.Utils.interpolate(point0.x, point1.x, point2.x, point3.x, weight);
      vector.y = THREE.Curve.Utils.interpolate(point0.y, point1.y, point2.y, point3.y, weight);
      vector.z = THREE.Curve.Utils.interpolate(point0.z, point1.z, point2.z, point3.z, weight);
      return vector;
    });
    THREE.ClosedSplineCurve3 = THREE.Curve.create(function(points) {
      this.points = (points == undefined) ? [] : points;
    }, function(t) {
      var points = this.points;
      var point = (points.length - 0) * t;
      var intPoint = Math.floor(point);
      var weight = point - intPoint;
      intPoint += intPoint > 0 ? 0 : (Math.floor(Math.abs(intPoint) / points.length) + 1) * points.length;
      var point0 = points[(intPoint - 1) % points.length];
      var point1 = points[(intPoint) % points.length];
      var point2 = points[(intPoint + 1) % points.length];
      var point3 = points[(intPoint + 2) % points.length];
      var vector = new THREE.Vector3();
      vector.x = THREE.Curve.Utils.interpolate(point0.x, point1.x, point2.x, point3.x, weight);
      vector.y = THREE.Curve.Utils.interpolate(point0.y, point1.y, point2.y, point3.y, weight);
      vector.z = THREE.Curve.Utils.interpolate(point0.z, point1.z, point2.z, point3.z, weight);
      return vector;
    });
    THREE.AnimationHandler = {
      LINEAR: 0,
      CATMULLROM: 1,
      CATMULLROM_FORWARD: 2,
      add: function() {
        THREE.warn('THREE.AnimationHandler.add() has been deprecated.');
      },
      get: function() {
        THREE.warn('THREE.AnimationHandler.get() has been deprecated.');
      },
      remove: function() {
        THREE.warn('THREE.AnimationHandler.remove() has been deprecated.');
      },
      animations: [],
      init: function(data) {
        if (data.initialized === true)
          return data;
        for (var h = 0; h < data.hierarchy.length; h++) {
          for (var k = 0; k < data.hierarchy[h].keys.length; k++) {
            if (data.hierarchy[h].keys[k].time < 0) {
              data.hierarchy[h].keys[k].time = 0;
            }
            if (data.hierarchy[h].keys[k].rot !== undefined && !(data.hierarchy[h].keys[k].rot instanceof THREE.Quaternion)) {
              var quat = data.hierarchy[h].keys[k].rot;
              data.hierarchy[h].keys[k].rot = new THREE.Quaternion().fromArray(quat);
            }
          }
          if (data.hierarchy[h].keys.length && data.hierarchy[h].keys[0].morphTargets !== undefined) {
            var usedMorphTargets = {};
            for (var k = 0; k < data.hierarchy[h].keys.length; k++) {
              for (var m = 0; m < data.hierarchy[h].keys[k].morphTargets.length; m++) {
                var morphTargetName = data.hierarchy[h].keys[k].morphTargets[m];
                usedMorphTargets[morphTargetName] = -1;
              }
            }
            data.hierarchy[h].usedMorphTargets = usedMorphTargets;
            for (var k = 0; k < data.hierarchy[h].keys.length; k++) {
              var influences = {};
              for (var morphTargetName in usedMorphTargets) {
                for (var m = 0; m < data.hierarchy[h].keys[k].morphTargets.length; m++) {
                  if (data.hierarchy[h].keys[k].morphTargets[m] === morphTargetName) {
                    influences[morphTargetName] = data.hierarchy[h].keys[k].morphTargetsInfluences[m];
                    break;
                  }
                }
                if (m === data.hierarchy[h].keys[k].morphTargets.length) {
                  influences[morphTargetName] = 0;
                }
              }
              data.hierarchy[h].keys[k].morphTargetsInfluences = influences;
            }
          }
          for (var k = 1; k < data.hierarchy[h].keys.length; k++) {
            if (data.hierarchy[h].keys[k].time === data.hierarchy[h].keys[k - 1].time) {
              data.hierarchy[h].keys.splice(k, 1);
              k--;
            }
          }
          for (var k = 0; k < data.hierarchy[h].keys.length; k++) {
            data.hierarchy[h].keys[k].index = k;
          }
        }
        data.initialized = true;
        return data;
      },
      parse: function(root) {
        var parseRecurseHierarchy = function(root, hierarchy) {
          hierarchy.push(root);
          for (var c = 0; c < root.children.length; c++)
            parseRecurseHierarchy(root.children[c], hierarchy);
        };
        var hierarchy = [];
        if (root instanceof THREE.SkinnedMesh) {
          for (var b = 0; b < root.skeleton.bones.length; b++) {
            hierarchy.push(root.skeleton.bones[b]);
          }
        } else {
          parseRecurseHierarchy(root, hierarchy);
        }
        return hierarchy;
      },
      play: function(animation) {
        if (this.animations.indexOf(animation) === -1) {
          this.animations.push(animation);
        }
      },
      stop: function(animation) {
        var index = this.animations.indexOf(animation);
        if (index !== -1) {
          this.animations.splice(index, 1);
        }
      },
      update: function(deltaTimeMS) {
        for (var i = 0; i < this.animations.length; i++) {
          this.animations[i].resetBlendWeights();
        }
        for (var i = 0; i < this.animations.length; i++) {
          this.animations[i].update(deltaTimeMS);
        }
      }
    };
    THREE.Animation = function(root, data) {
      this.root = root;
      this.data = THREE.AnimationHandler.init(data);
      this.hierarchy = THREE.AnimationHandler.parse(root);
      this.currentTime = 0;
      this.timeScale = 1;
      this.isPlaying = false;
      this.loop = true;
      this.weight = 0;
      this.interpolationType = THREE.AnimationHandler.LINEAR;
    };
    THREE.Animation.prototype = {
      constructor: THREE.Animation,
      keyTypes: ["pos", "rot", "scl"],
      play: function(startTime, weight) {
        this.currentTime = startTime !== undefined ? startTime : 0;
        this.weight = weight !== undefined ? weight : 1;
        this.isPlaying = true;
        this.reset();
        THREE.AnimationHandler.play(this);
      },
      stop: function() {
        this.isPlaying = false;
        THREE.AnimationHandler.stop(this);
      },
      reset: function() {
        for (var h = 0,
            hl = this.hierarchy.length; h < hl; h++) {
          var object = this.hierarchy[h];
          if (object.animationCache === undefined) {
            object.animationCache = {
              animations: {},
              blending: {
                positionWeight: 0.0,
                quaternionWeight: 0.0,
                scaleWeight: 0.0
              }
            };
          }
          var name = this.data.name;
          var animations = object.animationCache.animations;
          var animationCache = animations[name];
          if (animationCache === undefined) {
            animationCache = {
              prevKey: {
                pos: 0,
                rot: 0,
                scl: 0
              },
              nextKey: {
                pos: 0,
                rot: 0,
                scl: 0
              },
              originalMatrix: object.matrix
            };
            animations[name] = animationCache;
          }
          for (var t = 0; t < 3; t++) {
            var type = this.keyTypes[t];
            var prevKey = this.data.hierarchy[h].keys[0];
            var nextKey = this.getNextKeyWith(type, h, 1);
            while (nextKey.time < this.currentTime && nextKey.index > prevKey.index) {
              prevKey = nextKey;
              nextKey = this.getNextKeyWith(type, h, nextKey.index + 1);
            }
            animationCache.prevKey[type] = prevKey;
            animationCache.nextKey[type] = nextKey;
          }
        }
      },
      resetBlendWeights: function() {
        for (var h = 0,
            hl = this.hierarchy.length; h < hl; h++) {
          var object = this.hierarchy[h];
          var animationCache = object.animationCache;
          if (animationCache !== undefined) {
            var blending = animationCache.blending;
            blending.positionWeight = 0.0;
            blending.quaternionWeight = 0.0;
            blending.scaleWeight = 0.0;
          }
        }
      },
      update: (function() {
        var points = [];
        var target = new THREE.Vector3();
        var newVector = new THREE.Vector3();
        var newQuat = new THREE.Quaternion();
        var interpolateCatmullRom = function(points, scale) {
          var c = [],
              v3 = [],
              point,
              intPoint,
              weight,
              w2,
              w3,
              pa,
              pb,
              pc,
              pd;
          point = (points.length - 1) * scale;
          intPoint = Math.floor(point);
          weight = point - intPoint;
          c[0] = intPoint === 0 ? intPoint : intPoint - 1;
          c[1] = intPoint;
          c[2] = intPoint > points.length - 2 ? intPoint : intPoint + 1;
          c[3] = intPoint > points.length - 3 ? intPoint : intPoint + 2;
          pa = points[c[0]];
          pb = points[c[1]];
          pc = points[c[2]];
          pd = points[c[3]];
          w2 = weight * weight;
          w3 = weight * w2;
          v3[0] = interpolate(pa[0], pb[0], pc[0], pd[0], weight, w2, w3);
          v3[1] = interpolate(pa[1], pb[1], pc[1], pd[1], weight, w2, w3);
          v3[2] = interpolate(pa[2], pb[2], pc[2], pd[2], weight, w2, w3);
          return v3;
        };
        var interpolate = function(p0, p1, p2, p3, t, t2, t3) {
          var v0 = (p2 - p0) * 0.5,
              v1 = (p3 - p1) * 0.5;
          return (2 * (p1 - p2) + v0 + v1) * t3 + (-3 * (p1 - p2) - 2 * v0 - v1) * t2 + v0 * t + p1;
        };
        return function(delta) {
          if (this.isPlaying === false)
            return ;
          this.currentTime += delta * this.timeScale;
          if (this.weight === 0)
            return ;
          var duration = this.data.length;
          if (this.currentTime > duration || this.currentTime < 0) {
            if (this.loop) {
              this.currentTime %= duration;
              if (this.currentTime < 0)
                this.currentTime += duration;
              this.reset();
            } else {
              this.stop();
            }
          }
          for (var h = 0,
              hl = this.hierarchy.length; h < hl; h++) {
            var object = this.hierarchy[h];
            var animationCache = object.animationCache.animations[this.data.name];
            var blending = object.animationCache.blending;
            for (var t = 0; t < 3; t++) {
              var type = this.keyTypes[t];
              var prevKey = animationCache.prevKey[type];
              var nextKey = animationCache.nextKey[type];
              if ((this.timeScale > 0 && nextKey.time <= this.currentTime) || (this.timeScale < 0 && prevKey.time >= this.currentTime)) {
                prevKey = this.data.hierarchy[h].keys[0];
                nextKey = this.getNextKeyWith(type, h, 1);
                while (nextKey.time < this.currentTime && nextKey.index > prevKey.index) {
                  prevKey = nextKey;
                  nextKey = this.getNextKeyWith(type, h, nextKey.index + 1);
                }
                animationCache.prevKey[type] = prevKey;
                animationCache.nextKey[type] = nextKey;
              }
              var scale = (this.currentTime - prevKey.time) / (nextKey.time - prevKey.time);
              var prevXYZ = prevKey[type];
              var nextXYZ = nextKey[type];
              if (scale < 0)
                scale = 0;
              if (scale > 1)
                scale = 1;
              if (type === "pos") {
                if (this.interpolationType === THREE.AnimationHandler.LINEAR) {
                  newVector.x = prevXYZ[0] + (nextXYZ[0] - prevXYZ[0]) * scale;
                  newVector.y = prevXYZ[1] + (nextXYZ[1] - prevXYZ[1]) * scale;
                  newVector.z = prevXYZ[2] + (nextXYZ[2] - prevXYZ[2]) * scale;
                  var proportionalWeight = this.weight / (this.weight + blending.positionWeight);
                  object.position.lerp(newVector, proportionalWeight);
                  blending.positionWeight += this.weight;
                } else if (this.interpolationType === THREE.AnimationHandler.CATMULLROM || this.interpolationType === THREE.AnimationHandler.CATMULLROM_FORWARD) {
                  points[0] = this.getPrevKeyWith("pos", h, prevKey.index - 1)["pos"];
                  points[1] = prevXYZ;
                  points[2] = nextXYZ;
                  points[3] = this.getNextKeyWith("pos", h, nextKey.index + 1)["pos"];
                  scale = scale * 0.33 + 0.33;
                  var currentPoint = interpolateCatmullRom(points, scale);
                  var proportionalWeight = this.weight / (this.weight + blending.positionWeight);
                  blending.positionWeight += this.weight;
                  var vector = object.position;
                  vector.x = vector.x + (currentPoint[0] - vector.x) * proportionalWeight;
                  vector.y = vector.y + (currentPoint[1] - vector.y) * proportionalWeight;
                  vector.z = vector.z + (currentPoint[2] - vector.z) * proportionalWeight;
                  if (this.interpolationType === THREE.AnimationHandler.CATMULLROM_FORWARD) {
                    var forwardPoint = interpolateCatmullRom(points, scale * 1.01);
                    target.set(forwardPoint[0], forwardPoint[1], forwardPoint[2]);
                    target.sub(vector);
                    target.y = 0;
                    target.normalize();
                    var angle = Math.atan2(target.x, target.z);
                    object.rotation.set(0, angle, 0);
                  }
                }
              } else if (type === "rot") {
                THREE.Quaternion.slerp(prevXYZ, nextXYZ, newQuat, scale);
                if (blending.quaternionWeight === 0) {
                  object.quaternion.copy(newQuat);
                  blending.quaternionWeight = this.weight;
                } else {
                  var proportionalWeight = this.weight / (this.weight + blending.quaternionWeight);
                  THREE.Quaternion.slerp(object.quaternion, newQuat, object.quaternion, proportionalWeight);
                  blending.quaternionWeight += this.weight;
                }
              } else if (type === "scl") {
                newVector.x = prevXYZ[0] + (nextXYZ[0] - prevXYZ[0]) * scale;
                newVector.y = prevXYZ[1] + (nextXYZ[1] - prevXYZ[1]) * scale;
                newVector.z = prevXYZ[2] + (nextXYZ[2] - prevXYZ[2]) * scale;
                var proportionalWeight = this.weight / (this.weight + blending.scaleWeight);
                object.scale.lerp(newVector, proportionalWeight);
                blending.scaleWeight += this.weight;
              }
            }
          }
          return true;
        };
      })(),
      getNextKeyWith: function(type, h, key) {
        var keys = this.data.hierarchy[h].keys;
        if (this.interpolationType === THREE.AnimationHandler.CATMULLROM || this.interpolationType === THREE.AnimationHandler.CATMULLROM_FORWARD) {
          key = key < keys.length - 1 ? key : keys.length - 1;
        } else {
          key = key % keys.length;
        }
        for (; key < keys.length; key++) {
          if (keys[key][type] !== undefined) {
            return keys[key];
          }
        }
        return this.data.hierarchy[h].keys[0];
      },
      getPrevKeyWith: function(type, h, key) {
        var keys = this.data.hierarchy[h].keys;
        if (this.interpolationType === THREE.AnimationHandler.CATMULLROM || this.interpolationType === THREE.AnimationHandler.CATMULLROM_FORWARD) {
          key = key > 0 ? key : 0;
        } else {
          key = key >= 0 ? key : key + keys.length;
        }
        for (; key >= 0; key--) {
          if (keys[key][type] !== undefined) {
            return keys[key];
          }
        }
        return this.data.hierarchy[h].keys[keys.length - 1];
      }
    };
    THREE.KeyFrameAnimation = function(data) {
      this.root = data.node;
      this.data = THREE.AnimationHandler.init(data);
      this.hierarchy = THREE.AnimationHandler.parse(this.root);
      this.currentTime = 0;
      this.timeScale = 0.001;
      this.isPlaying = false;
      this.isPaused = true;
      this.loop = true;
      for (var h = 0,
          hl = this.hierarchy.length; h < hl; h++) {
        var keys = this.data.hierarchy[h].keys,
            sids = this.data.hierarchy[h].sids,
            obj = this.hierarchy[h];
        if (keys.length && sids) {
          for (var s = 0; s < sids.length; s++) {
            var sid = sids[s],
                next = this.getNextKeyWith(sid, h, 0);
            if (next) {
              next.apply(sid);
            }
          }
          obj.matrixAutoUpdate = false;
          this.data.hierarchy[h].node.updateMatrix();
          obj.matrixWorldNeedsUpdate = true;
        }
      }
    };
    THREE.KeyFrameAnimation.prototype = {
      constructor: THREE.KeyFrameAnimation,
      play: function(startTime) {
        this.currentTime = startTime !== undefined ? startTime : 0;
        if (this.isPlaying === false) {
          this.isPlaying = true;
          var h,
              hl = this.hierarchy.length,
              object,
              node;
          for (h = 0; h < hl; h++) {
            object = this.hierarchy[h];
            node = this.data.hierarchy[h];
            if (node.animationCache === undefined) {
              node.animationCache = {};
              node.animationCache.prevKey = null;
              node.animationCache.nextKey = null;
              node.animationCache.originalMatrix = object.matrix;
            }
            var keys = this.data.hierarchy[h].keys;
            if (keys.length) {
              node.animationCache.prevKey = keys[0];
              node.animationCache.nextKey = keys[1];
              this.startTime = Math.min(keys[0].time, this.startTime);
              this.endTime = Math.max(keys[keys.length - 1].time, this.endTime);
            }
          }
          this.update(0);
        }
        this.isPaused = false;
        THREE.AnimationHandler.play(this);
      },
      stop: function() {
        this.isPlaying = false;
        this.isPaused = false;
        THREE.AnimationHandler.stop(this);
        for (var h = 0; h < this.data.hierarchy.length; h++) {
          var obj = this.hierarchy[h];
          var node = this.data.hierarchy[h];
          if (node.animationCache !== undefined) {
            var original = node.animationCache.originalMatrix;
            original.copy(obj.matrix);
            obj.matrix = original;
            delete node.animationCache;
          }
        }
      },
      update: function(delta) {
        if (this.isPlaying === false)
          return ;
        this.currentTime += delta * this.timeScale;
        var duration = this.data.length;
        if (this.loop === true && this.currentTime > duration) {
          this.currentTime %= duration;
        }
        this.currentTime = Math.min(this.currentTime, duration);
        for (var h = 0,
            hl = this.hierarchy.length; h < hl; h++) {
          var object = this.hierarchy[h];
          var node = this.data.hierarchy[h];
          var keys = node.keys,
              animationCache = node.animationCache;
          if (keys.length) {
            var prevKey = animationCache.prevKey;
            var nextKey = animationCache.nextKey;
            if (nextKey.time <= this.currentTime) {
              while (nextKey.time < this.currentTime && nextKey.index > prevKey.index) {
                prevKey = nextKey;
                nextKey = keys[prevKey.index + 1];
              }
              animationCache.prevKey = prevKey;
              animationCache.nextKey = nextKey;
            }
            if (nextKey.time >= this.currentTime) {
              prevKey.interpolate(nextKey, this.currentTime);
            } else {
              prevKey.interpolate(nextKey, nextKey.time);
            }
            this.data.hierarchy[h].node.updateMatrix();
            object.matrixWorldNeedsUpdate = true;
          }
        }
      },
      getNextKeyWith: function(sid, h, key) {
        var keys = this.data.hierarchy[h].keys;
        key = key % keys.length;
        for (; key < keys.length; key++) {
          if (keys[key].hasTarget(sid)) {
            return keys[key];
          }
        }
        return keys[0];
      },
      getPrevKeyWith: function(sid, h, key) {
        var keys = this.data.hierarchy[h].keys;
        key = key >= 0 ? key : key + keys.length;
        for (; key >= 0; key--) {
          if (keys[key].hasTarget(sid)) {
            return keys[key];
          }
        }
        return keys[keys.length - 1];
      }
    };
    THREE.MorphAnimation = function(mesh) {
      this.mesh = mesh;
      this.frames = mesh.morphTargetInfluences.length;
      this.currentTime = 0;
      this.duration = 1000;
      this.loop = true;
      this.lastFrame = 0;
      this.currentFrame = 0;
      this.isPlaying = false;
    };
    THREE.MorphAnimation.prototype = {
      constructor: THREE.MorphAnimation,
      play: function() {
        this.isPlaying = true;
      },
      pause: function() {
        this.isPlaying = false;
      },
      update: function(delta) {
        if (this.isPlaying === false)
          return ;
        this.currentTime += delta;
        if (this.loop === true && this.currentTime > this.duration) {
          this.currentTime %= this.duration;
        }
        this.currentTime = Math.min(this.currentTime, this.duration);
        var interpolation = this.duration / this.frames;
        var frame = Math.floor(this.currentTime / interpolation);
        var influences = this.mesh.morphTargetInfluences;
        if (frame != this.currentFrame) {
          influences[this.lastFrame] = 0;
          influences[this.currentFrame] = 1;
          influences[frame] = 0;
          this.lastFrame = this.currentFrame;
          this.currentFrame = frame;
        }
        influences[frame] = (this.currentTime % interpolation) / interpolation;
        influences[this.lastFrame] = 1 - influences[frame];
      }
    };
    THREE.BoxGeometry = function(width, height, depth, widthSegments, heightSegments, depthSegments) {
      THREE.Geometry.call(this);
      this.type = 'BoxGeometry';
      this.parameters = {
        width: width,
        height: height,
        depth: depth,
        widthSegments: widthSegments,
        heightSegments: heightSegments,
        depthSegments: depthSegments
      };
      this.widthSegments = widthSegments || 1;
      this.heightSegments = heightSegments || 1;
      this.depthSegments = depthSegments || 1;
      var scope = this;
      var width_half = width / 2;
      var height_half = height / 2;
      var depth_half = depth / 2;
      buildPlane('z', 'y', -1, -1, depth, height, width_half, 0);
      buildPlane('z', 'y', 1, -1, depth, height, -width_half, 1);
      buildPlane('x', 'z', 1, 1, width, depth, height_half, 2);
      buildPlane('x', 'z', 1, -1, width, depth, -height_half, 3);
      buildPlane('x', 'y', 1, -1, width, height, depth_half, 4);
      buildPlane('x', 'y', -1, -1, width, height, -depth_half, 5);
      function buildPlane(u, v, udir, vdir, width, height, depth, materialIndex) {
        var w,
            ix,
            iy,
            gridX = scope.widthSegments,
            gridY = scope.heightSegments,
            width_half = width / 2,
            height_half = height / 2,
            offset = scope.vertices.length;
        if ((u === 'x' && v === 'y') || (u === 'y' && v === 'x')) {
          w = 'z';
        } else if ((u === 'x' && v === 'z') || (u === 'z' && v === 'x')) {
          w = 'y';
          gridY = scope.depthSegments;
        } else if ((u === 'z' && v === 'y') || (u === 'y' && v === 'z')) {
          w = 'x';
          gridX = scope.depthSegments;
        }
        var gridX1 = gridX + 1,
            gridY1 = gridY + 1,
            segment_width = width / gridX,
            segment_height = height / gridY,
            normal = new THREE.Vector3();
        normal[w] = depth > 0 ? 1 : -1;
        for (iy = 0; iy < gridY1; iy++) {
          for (ix = 0; ix < gridX1; ix++) {
            var vector = new THREE.Vector3();
            vector[u] = (ix * segment_width - width_half) * udir;
            vector[v] = (iy * segment_height - height_half) * vdir;
            vector[w] = depth;
            scope.vertices.push(vector);
          }
        }
        for (iy = 0; iy < gridY; iy++) {
          for (ix = 0; ix < gridX; ix++) {
            var a = ix + gridX1 * iy;
            var b = ix + gridX1 * (iy + 1);
            var c = (ix + 1) + gridX1 * (iy + 1);
            var d = (ix + 1) + gridX1 * iy;
            var uva = new THREE.Vector2(ix / gridX, 1 - iy / gridY);
            var uvb = new THREE.Vector2(ix / gridX, 1 - (iy + 1) / gridY);
            var uvc = new THREE.Vector2((ix + 1) / gridX, 1 - (iy + 1) / gridY);
            var uvd = new THREE.Vector2((ix + 1) / gridX, 1 - iy / gridY);
            var face = new THREE.Face3(a + offset, b + offset, d + offset);
            face.normal.copy(normal);
            face.vertexNormals.push(normal.clone(), normal.clone(), normal.clone());
            face.materialIndex = materialIndex;
            scope.faces.push(face);
            scope.faceVertexUvs[0].push([uva, uvb, uvd]);
            face = new THREE.Face3(b + offset, c + offset, d + offset);
            face.normal.copy(normal);
            face.vertexNormals.push(normal.clone(), normal.clone(), normal.clone());
            face.materialIndex = materialIndex;
            scope.faces.push(face);
            scope.faceVertexUvs[0].push([uvb.clone(), uvc, uvd.clone()]);
          }
        }
      }
      this.mergeVertices();
    };
    THREE.BoxGeometry.prototype = Object.create(THREE.Geometry.prototype);
    THREE.BoxGeometry.prototype.constructor = THREE.BoxGeometry;
    THREE.CircleGeometry = function(radius, segments, thetaStart, thetaLength) {
      THREE.Geometry.call(this);
      this.type = 'CircleGeometry';
      this.parameters = {
        radius: radius,
        segments: segments,
        thetaStart: thetaStart,
        thetaLength: thetaLength
      };
      radius = radius || 50;
      segments = segments !== undefined ? Math.max(3, segments) : 8;
      thetaStart = thetaStart !== undefined ? thetaStart : 0;
      thetaLength = thetaLength !== undefined ? thetaLength : Math.PI * 2;
      var i,
          uvs = [],
          center = new THREE.Vector3(),
          centerUV = new THREE.Vector2(0.5, 0.5);
      this.vertices.push(center);
      uvs.push(centerUV);
      for (i = 0; i <= segments; i++) {
        var vertex = new THREE.Vector3();
        var segment = thetaStart + i / segments * thetaLength;
        vertex.x = radius * Math.cos(segment);
        vertex.y = radius * Math.sin(segment);
        this.vertices.push(vertex);
        uvs.push(new THREE.Vector2((vertex.x / radius + 1) / 2, (vertex.y / radius + 1) / 2));
      }
      var n = new THREE.Vector3(0, 0, 1);
      for (i = 1; i <= segments; i++) {
        this.faces.push(new THREE.Face3(i, i + 1, 0, [n.clone(), n.clone(), n.clone()]));
        this.faceVertexUvs[0].push([uvs[i].clone(), uvs[i + 1].clone(), centerUV.clone()]);
      }
      this.computeFaceNormals();
      this.boundingSphere = new THREE.Sphere(new THREE.Vector3(), radius);
    };
    THREE.CircleGeometry.prototype = Object.create(THREE.Geometry.prototype);
    THREE.CircleGeometry.prototype.constructor = THREE.CircleGeometry;
    THREE.CubeGeometry = function(width, height, depth, widthSegments, heightSegments, depthSegments) {
      THREE.warn('THREE.CubeGeometry has been renamed to THREE.BoxGeometry.');
      return new THREE.BoxGeometry(width, height, depth, widthSegments, heightSegments, depthSegments);
    };
    THREE.CylinderGeometry = function(radiusTop, radiusBottom, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength) {
      THREE.Geometry.call(this);
      this.type = 'CylinderGeometry';
      this.parameters = {
        radiusTop: radiusTop,
        radiusBottom: radiusBottom,
        height: height,
        radialSegments: radialSegments,
        heightSegments: heightSegments,
        openEnded: openEnded,
        thetaStart: thetaStart,
        thetaLength: thetaLength
      };
      radiusTop = radiusTop !== undefined ? radiusTop : 20;
      radiusBottom = radiusBottom !== undefined ? radiusBottom : 20;
      height = height !== undefined ? height : 100;
      radialSegments = radialSegments || 8;
      heightSegments = heightSegments || 1;
      openEnded = openEnded !== undefined ? openEnded : false;
      thetaStart = thetaStart !== undefined ? thetaStart : 0;
      thetaLength = thetaLength !== undefined ? thetaLength : 2 * Math.PI;
      var heightHalf = height / 2;
      var x,
          y,
          vertices = [],
          uvs = [];
      for (y = 0; y <= heightSegments; y++) {
        var verticesRow = [];
        var uvsRow = [];
        var v = y / heightSegments;
        var radius = v * (radiusBottom - radiusTop) + radiusTop;
        for (x = 0; x <= radialSegments; x++) {
          var u = x / radialSegments;
          var vertex = new THREE.Vector3();
          vertex.x = radius * Math.sin(u * thetaLength + thetaStart);
          vertex.y = -v * height + heightHalf;
          vertex.z = radius * Math.cos(u * thetaLength + thetaStart);
          this.vertices.push(vertex);
          verticesRow.push(this.vertices.length - 1);
          uvsRow.push(new THREE.Vector2(u, 1 - v));
        }
        vertices.push(verticesRow);
        uvs.push(uvsRow);
      }
      var tanTheta = (radiusBottom - radiusTop) / height;
      var na,
          nb;
      for (x = 0; x < radialSegments; x++) {
        if (radiusTop !== 0) {
          na = this.vertices[vertices[0][x]].clone();
          nb = this.vertices[vertices[0][x + 1]].clone();
        } else {
          na = this.vertices[vertices[1][x]].clone();
          nb = this.vertices[vertices[1][x + 1]].clone();
        }
        na.setY(Math.sqrt(na.x * na.x + na.z * na.z) * tanTheta).normalize();
        nb.setY(Math.sqrt(nb.x * nb.x + nb.z * nb.z) * tanTheta).normalize();
        for (y = 0; y < heightSegments; y++) {
          var v1 = vertices[y][x];
          var v2 = vertices[y + 1][x];
          var v3 = vertices[y + 1][x + 1];
          var v4 = vertices[y][x + 1];
          var n1 = na.clone();
          var n2 = na.clone();
          var n3 = nb.clone();
          var n4 = nb.clone();
          var uv1 = uvs[y][x].clone();
          var uv2 = uvs[y + 1][x].clone();
          var uv3 = uvs[y + 1][x + 1].clone();
          var uv4 = uvs[y][x + 1].clone();
          this.faces.push(new THREE.Face3(v1, v2, v4, [n1, n2, n4]));
          this.faceVertexUvs[0].push([uv1, uv2, uv4]);
          this.faces.push(new THREE.Face3(v2, v3, v4, [n2.clone(), n3, n4.clone()]));
          this.faceVertexUvs[0].push([uv2.clone(), uv3, uv4.clone()]);
        }
      }
      if (openEnded === false && radiusTop > 0) {
        this.vertices.push(new THREE.Vector3(0, heightHalf, 0));
        for (x = 0; x < radialSegments; x++) {
          var v1 = vertices[0][x];
          var v2 = vertices[0][x + 1];
          var v3 = this.vertices.length - 1;
          var n1 = new THREE.Vector3(0, 1, 0);
          var n2 = new THREE.Vector3(0, 1, 0);
          var n3 = new THREE.Vector3(0, 1, 0);
          var uv1 = uvs[0][x].clone();
          var uv2 = uvs[0][x + 1].clone();
          var uv3 = new THREE.Vector2(uv2.x, 0);
          this.faces.push(new THREE.Face3(v1, v2, v3, [n1, n2, n3]));
          this.faceVertexUvs[0].push([uv1, uv2, uv3]);
        }
      }
      if (openEnded === false && radiusBottom > 0) {
        this.vertices.push(new THREE.Vector3(0, -heightHalf, 0));
        for (x = 0; x < radialSegments; x++) {
          var v1 = vertices[heightSegments][x + 1];
          var v2 = vertices[heightSegments][x];
          var v3 = this.vertices.length - 1;
          var n1 = new THREE.Vector3(0, -1, 0);
          var n2 = new THREE.Vector3(0, -1, 0);
          var n3 = new THREE.Vector3(0, -1, 0);
          var uv1 = uvs[heightSegments][x + 1].clone();
          var uv2 = uvs[heightSegments][x].clone();
          var uv3 = new THREE.Vector2(uv2.x, 1);
          this.faces.push(new THREE.Face3(v1, v2, v3, [n1, n2, n3]));
          this.faceVertexUvs[0].push([uv1, uv2, uv3]);
        }
      }
      this.computeFaceNormals();
    };
    THREE.CylinderGeometry.prototype = Object.create(THREE.Geometry.prototype);
    THREE.CylinderGeometry.prototype.constructor = THREE.CylinderGeometry;
    THREE.ExtrudeGeometry = function(shapes, options) {
      if (typeof(shapes) === "undefined") {
        shapes = [];
        return ;
      }
      THREE.Geometry.call(this);
      this.type = 'ExtrudeGeometry';
      shapes = shapes instanceof Array ? shapes : [shapes];
      this.addShapeList(shapes, options);
      this.computeFaceNormals();
    };
    THREE.ExtrudeGeometry.prototype = Object.create(THREE.Geometry.prototype);
    THREE.ExtrudeGeometry.prototype.constructor = THREE.ExtrudeGeometry;
    THREE.ExtrudeGeometry.prototype.addShapeList = function(shapes, options) {
      var sl = shapes.length;
      for (var s = 0; s < sl; s++) {
        var shape = shapes[s];
        this.addShape(shape, options);
      }
    };
    THREE.ExtrudeGeometry.prototype.addShape = function(shape, options) {
      var amount = options.amount !== undefined ? options.amount : 100;
      var bevelThickness = options.bevelThickness !== undefined ? options.bevelThickness : 6;
      var bevelSize = options.bevelSize !== undefined ? options.bevelSize : bevelThickness - 2;
      var bevelSegments = options.bevelSegments !== undefined ? options.bevelSegments : 3;
      var bevelEnabled = options.bevelEnabled !== undefined ? options.bevelEnabled : true;
      var curveSegments = options.curveSegments !== undefined ? options.curveSegments : 12;
      var steps = options.steps !== undefined ? options.steps : 1;
      var extrudePath = options.extrudePath;
      var extrudePts,
          extrudeByPath = false;
      var material = options.material;
      var extrudeMaterial = options.extrudeMaterial;
      var uvgen = options.UVGenerator !== undefined ? options.UVGenerator : THREE.ExtrudeGeometry.WorldUVGenerator;
      var splineTube,
          binormal,
          normal,
          position2;
      if (extrudePath) {
        extrudePts = extrudePath.getSpacedPoints(steps);
        extrudeByPath = true;
        bevelEnabled = false;
        splineTube = options.frames !== undefined ? options.frames : new THREE.TubeGeometry.FrenetFrames(extrudePath, steps, false);
        binormal = new THREE.Vector3();
        normal = new THREE.Vector3();
        position2 = new THREE.Vector3();
      }
      if (!bevelEnabled) {
        bevelSegments = 0;
        bevelThickness = 0;
        bevelSize = 0;
      }
      var ahole,
          h,
          hl;
      var scope = this;
      var shapesOffset = this.vertices.length;
      var shapePoints = shape.extractPoints(curveSegments);
      var vertices = shapePoints.shape;
      var holes = shapePoints.holes;
      var reverse = !THREE.Shape.Utils.isClockWise(vertices);
      if (reverse) {
        vertices = vertices.reverse();
        for (h = 0, hl = holes.length; h < hl; h++) {
          ahole = holes[h];
          if (THREE.Shape.Utils.isClockWise(ahole)) {
            holes[h] = ahole.reverse();
          }
        }
        reverse = false;
      }
      var faces = THREE.Shape.Utils.triangulateShape(vertices, holes);
      var contour = vertices;
      for (h = 0, hl = holes.length; h < hl; h++) {
        ahole = holes[h];
        vertices = vertices.concat(ahole);
      }
      function scalePt2(pt, vec, size) {
        if (!vec)
          THREE.error("THREE.ExtrudeGeometry: vec does not exist");
        return vec.clone().multiplyScalar(size).add(pt);
      }
      var b,
          bs,
          t,
          z,
          vert,
          vlen = vertices.length,
          face,
          flen = faces.length;
      function getBevelVec(inPt, inPrev, inNext) {
        var EPSILON = 0.0000000001;
        var v_trans_x,
            v_trans_y,
            shrink_by = 1;
        var v_prev_x = inPt.x - inPrev.x,
            v_prev_y = inPt.y - inPrev.y;
        var v_next_x = inNext.x - inPt.x,
            v_next_y = inNext.y - inPt.y;
        var v_prev_lensq = (v_prev_x * v_prev_x + v_prev_y * v_prev_y);
        var colinear0 = (v_prev_x * v_next_y - v_prev_y * v_next_x);
        if (Math.abs(colinear0) > EPSILON) {
          var v_prev_len = Math.sqrt(v_prev_lensq);
          var v_next_len = Math.sqrt(v_next_x * v_next_x + v_next_y * v_next_y);
          var ptPrevShift_x = (inPrev.x - v_prev_y / v_prev_len);
          var ptPrevShift_y = (inPrev.y + v_prev_x / v_prev_len);
          var ptNextShift_x = (inNext.x - v_next_y / v_next_len);
          var ptNextShift_y = (inNext.y + v_next_x / v_next_len);
          var sf = ((ptNextShift_x - ptPrevShift_x) * v_next_y - (ptNextShift_y - ptPrevShift_y) * v_next_x) / (v_prev_x * v_next_y - v_prev_y * v_next_x);
          v_trans_x = (ptPrevShift_x + v_prev_x * sf - inPt.x);
          v_trans_y = (ptPrevShift_y + v_prev_y * sf - inPt.y);
          var v_trans_lensq = (v_trans_x * v_trans_x + v_trans_y * v_trans_y);
          if (v_trans_lensq <= 2) {
            return new THREE.Vector2(v_trans_x, v_trans_y);
          } else {
            shrink_by = Math.sqrt(v_trans_lensq / 2);
          }
        } else {
          var direction_eq = false;
          if (v_prev_x > EPSILON) {
            if (v_next_x > EPSILON) {
              direction_eq = true;
            }
          } else {
            if (v_prev_x < -EPSILON) {
              if (v_next_x < -EPSILON) {
                direction_eq = true;
              }
            } else {
              if (Math.sign(v_prev_y) == Math.sign(v_next_y)) {
                direction_eq = true;
              }
            }
          }
          if (direction_eq) {
            v_trans_x = -v_prev_y;
            v_trans_y = v_prev_x;
            shrink_by = Math.sqrt(v_prev_lensq);
          } else {
            v_trans_x = v_prev_x;
            v_trans_y = v_prev_y;
            shrink_by = Math.sqrt(v_prev_lensq / 2);
          }
        }
        return new THREE.Vector2(v_trans_x / shrink_by, v_trans_y / shrink_by);
      }
      var contourMovements = [];
      for (var i = 0,
          il = contour.length,
          j = il - 1,
          k = i + 1; i < il; i++, j++, k++) {
        if (j === il)
          j = 0;
        if (k === il)
          k = 0;
        contourMovements[i] = getBevelVec(contour[i], contour[j], contour[k]);
      }
      var holesMovements = [],
          oneHoleMovements,
          verticesMovements = contourMovements.concat();
      for (h = 0, hl = holes.length; h < hl; h++) {
        ahole = holes[h];
        oneHoleMovements = [];
        for (i = 0, il = ahole.length, j = il - 1, k = i + 1; i < il; i++, j++, k++) {
          if (j === il)
            j = 0;
          if (k === il)
            k = 0;
          oneHoleMovements[i] = getBevelVec(ahole[i], ahole[j], ahole[k]);
        }
        holesMovements.push(oneHoleMovements);
        verticesMovements = verticesMovements.concat(oneHoleMovements);
      }
      for (b = 0; b < bevelSegments; b++) {
        t = b / bevelSegments;
        z = bevelThickness * (1 - t);
        bs = bevelSize * (Math.sin(t * Math.PI / 2));
        for (i = 0, il = contour.length; i < il; i++) {
          vert = scalePt2(contour[i], contourMovements[i], bs);
          v(vert.x, vert.y, -z);
        }
        for (h = 0, hl = holes.length; h < hl; h++) {
          ahole = holes[h];
          oneHoleMovements = holesMovements[h];
          for (i = 0, il = ahole.length; i < il; i++) {
            vert = scalePt2(ahole[i], oneHoleMovements[i], bs);
            v(vert.x, vert.y, -z);
          }
        }
      }
      bs = bevelSize;
      for (i = 0; i < vlen; i++) {
        vert = bevelEnabled ? scalePt2(vertices[i], verticesMovements[i], bs) : vertices[i];
        if (!extrudeByPath) {
          v(vert.x, vert.y, 0);
        } else {
          normal.copy(splineTube.normals[0]).multiplyScalar(vert.x);
          binormal.copy(splineTube.binormals[0]).multiplyScalar(vert.y);
          position2.copy(extrudePts[0]).add(normal).add(binormal);
          v(position2.x, position2.y, position2.z);
        }
      }
      var s;
      for (s = 1; s <= steps; s++) {
        for (i = 0; i < vlen; i++) {
          vert = bevelEnabled ? scalePt2(vertices[i], verticesMovements[i], bs) : vertices[i];
          if (!extrudeByPath) {
            v(vert.x, vert.y, amount / steps * s);
          } else {
            normal.copy(splineTube.normals[s]).multiplyScalar(vert.x);
            binormal.copy(splineTube.binormals[s]).multiplyScalar(vert.y);
            position2.copy(extrudePts[s]).add(normal).add(binormal);
            v(position2.x, position2.y, position2.z);
          }
        }
      }
      for (b = bevelSegments - 1; b >= 0; b--) {
        t = b / bevelSegments;
        z = bevelThickness * (1 - t);
        bs = bevelSize * Math.sin(t * Math.PI / 2);
        for (i = 0, il = contour.length; i < il; i++) {
          vert = scalePt2(contour[i], contourMovements[i], bs);
          v(vert.x, vert.y, amount + z);
        }
        for (h = 0, hl = holes.length; h < hl; h++) {
          ahole = holes[h];
          oneHoleMovements = holesMovements[h];
          for (i = 0, il = ahole.length; i < il; i++) {
            vert = scalePt2(ahole[i], oneHoleMovements[i], bs);
            if (!extrudeByPath) {
              v(vert.x, vert.y, amount + z);
            } else {
              v(vert.x, vert.y + extrudePts[steps - 1].y, extrudePts[steps - 1].x + z);
            }
          }
        }
      }
      buildLidFaces();
      buildSideFaces();
      function buildLidFaces() {
        if (bevelEnabled) {
          var layer = 0;
          var offset = vlen * layer;
          for (i = 0; i < flen; i++) {
            face = faces[i];
            f3(face[2] + offset, face[1] + offset, face[0] + offset);
          }
          layer = steps + bevelSegments * 2;
          offset = vlen * layer;
          for (i = 0; i < flen; i++) {
            face = faces[i];
            f3(face[0] + offset, face[1] + offset, face[2] + offset);
          }
        } else {
          for (i = 0; i < flen; i++) {
            face = faces[i];
            f3(face[2], face[1], face[0]);
          }
          for (i = 0; i < flen; i++) {
            face = faces[i];
            f3(face[0] + vlen * steps, face[1] + vlen * steps, face[2] + vlen * steps);
          }
        }
      }
      function buildSideFaces() {
        var layeroffset = 0;
        sidewalls(contour, layeroffset);
        layeroffset += contour.length;
        for (h = 0, hl = holes.length; h < hl; h++) {
          ahole = holes[h];
          sidewalls(ahole, layeroffset);
          layeroffset += ahole.length;
        }
      }
      function sidewalls(contour, layeroffset) {
        var j,
            k;
        i = contour.length;
        while (--i >= 0) {
          j = i;
          k = i - 1;
          if (k < 0)
            k = contour.length - 1;
          var s = 0,
              sl = steps + bevelSegments * 2;
          for (s = 0; s < sl; s++) {
            var slen1 = vlen * s;
            var slen2 = vlen * (s + 1);
            var a = layeroffset + j + slen1,
                b = layeroffset + k + slen1,
                c = layeroffset + k + slen2,
                d = layeroffset + j + slen2;
            f4(a, b, c, d, contour, s, sl, j, k);
          }
        }
      }
      function v(x, y, z) {
        scope.vertices.push(new THREE.Vector3(x, y, z));
      }
      function f3(a, b, c) {
        a += shapesOffset;
        b += shapesOffset;
        c += shapesOffset;
        scope.faces.push(new THREE.Face3(a, b, c, null, null, material));
        var uvs = uvgen.generateTopUV(scope, a, b, c);
        scope.faceVertexUvs[0].push(uvs);
      }
      function f4(a, b, c, d, wallContour, stepIndex, stepsLength, contourIndex1, contourIndex2) {
        a += shapesOffset;
        b += shapesOffset;
        c += shapesOffset;
        d += shapesOffset;
        scope.faces.push(new THREE.Face3(a, b, d, null, null, extrudeMaterial));
        scope.faces.push(new THREE.Face3(b, c, d, null, null, extrudeMaterial));
        var uvs = uvgen.generateSideWallUV(scope, a, b, c, d);
        scope.faceVertexUvs[0].push([uvs[0], uvs[1], uvs[3]]);
        scope.faceVertexUvs[0].push([uvs[1], uvs[2], uvs[3]]);
      }
    };
    THREE.ExtrudeGeometry.WorldUVGenerator = {
      generateTopUV: function(geometry, indexA, indexB, indexC) {
        var vertices = geometry.vertices;
        var a = vertices[indexA];
        var b = vertices[indexB];
        var c = vertices[indexC];
        return [new THREE.Vector2(a.x, a.y), new THREE.Vector2(b.x, b.y), new THREE.Vector2(c.x, c.y)];
      },
      generateSideWallUV: function(geometry, indexA, indexB, indexC, indexD) {
        var vertices = geometry.vertices;
        var a = vertices[indexA];
        var b = vertices[indexB];
        var c = vertices[indexC];
        var d = vertices[indexD];
        if (Math.abs(a.y - b.y) < 0.01) {
          return [new THREE.Vector2(a.x, 1 - a.z), new THREE.Vector2(b.x, 1 - b.z), new THREE.Vector2(c.x, 1 - c.z), new THREE.Vector2(d.x, 1 - d.z)];
        } else {
          return [new THREE.Vector2(a.y, 1 - a.z), new THREE.Vector2(b.y, 1 - b.z), new THREE.Vector2(c.y, 1 - c.z), new THREE.Vector2(d.y, 1 - d.z)];
        }
      }
    };
    THREE.ShapeGeometry = function(shapes, options) {
      THREE.Geometry.call(this);
      this.type = 'ShapeGeometry';
      if (shapes instanceof Array === false)
        shapes = [shapes];
      this.addShapeList(shapes, options);
      this.computeFaceNormals();
    };
    THREE.ShapeGeometry.prototype = Object.create(THREE.Geometry.prototype);
    THREE.ShapeGeometry.prototype.constructor = THREE.ShapeGeometry;
    THREE.ShapeGeometry.prototype.addShapeList = function(shapes, options) {
      for (var i = 0,
          l = shapes.length; i < l; i++) {
        this.addShape(shapes[i], options);
      }
      return this;
    };
    THREE.ShapeGeometry.prototype.addShape = function(shape, options) {
      if (options === undefined)
        options = {};
      var curveSegments = options.curveSegments !== undefined ? options.curveSegments : 12;
      var material = options.material;
      var uvgen = options.UVGenerator === undefined ? THREE.ExtrudeGeometry.WorldUVGenerator : options.UVGenerator;
      var i,
          l,
          hole;
      var shapesOffset = this.vertices.length;
      var shapePoints = shape.extractPoints(curveSegments);
      var vertices = shapePoints.shape;
      var holes = shapePoints.holes;
      var reverse = !THREE.Shape.Utils.isClockWise(vertices);
      if (reverse) {
        vertices = vertices.reverse();
        for (i = 0, l = holes.length; i < l; i++) {
          hole = holes[i];
          if (THREE.Shape.Utils.isClockWise(hole)) {
            holes[i] = hole.reverse();
          }
        }
        reverse = false;
      }
      var faces = THREE.Shape.Utils.triangulateShape(vertices, holes);
      var contour = vertices;
      for (i = 0, l = holes.length; i < l; i++) {
        hole = holes[i];
        vertices = vertices.concat(hole);
      }
      var vert,
          vlen = vertices.length;
      var face,
          flen = faces.length;
      for (i = 0; i < vlen; i++) {
        vert = vertices[i];
        this.vertices.push(new THREE.Vector3(vert.x, vert.y, 0));
      }
      for (i = 0; i < flen; i++) {
        face = faces[i];
        var a = face[0] + shapesOffset;
        var b = face[1] + shapesOffset;
        var c = face[2] + shapesOffset;
        this.faces.push(new THREE.Face3(a, b, c, null, null, material));
        this.faceVertexUvs[0].push(uvgen.generateTopUV(this, a, b, c));
      }
    };
    THREE.LatheGeometry = function(points, segments, phiStart, phiLength) {
      THREE.Geometry.call(this);
      this.type = 'LatheGeometry';
      this.parameters = {
        points: points,
        segments: segments,
        phiStart: phiStart,
        phiLength: phiLength
      };
      segments = segments || 12;
      phiStart = phiStart || 0;
      phiLength = phiLength || 2 * Math.PI;
      var inversePointLength = 1.0 / (points.length - 1);
      var inverseSegments = 1.0 / segments;
      for (var i = 0,
          il = segments; i <= il; i++) {
        var phi = phiStart + i * inverseSegments * phiLength;
        var c = Math.cos(phi),
            s = Math.sin(phi);
        for (var j = 0,
            jl = points.length; j < jl; j++) {
          var pt = points[j];
          var vertex = new THREE.Vector3();
          vertex.x = c * pt.x - s * pt.y;
          vertex.y = s * pt.x + c * pt.y;
          vertex.z = pt.z;
          this.vertices.push(vertex);
        }
      }
      var np = points.length;
      for (var i = 0,
          il = segments; i < il; i++) {
        for (var j = 0,
            jl = points.length - 1; j < jl; j++) {
          var base = j + np * i;
          var a = base;
          var b = base + np;
          var c = base + 1 + np;
          var d = base + 1;
          var u0 = i * inverseSegments;
          var v0 = j * inversePointLength;
          var u1 = u0 + inverseSegments;
          var v1 = v0 + inversePointLength;
          this.faces.push(new THREE.Face3(a, b, d));
          this.faceVertexUvs[0].push([new THREE.Vector2(u0, v0), new THREE.Vector2(u1, v0), new THREE.Vector2(u0, v1)]);
          this.faces.push(new THREE.Face3(b, c, d));
          this.faceVertexUvs[0].push([new THREE.Vector2(u1, v0), new THREE.Vector2(u1, v1), new THREE.Vector2(u0, v1)]);
        }
      }
      this.mergeVertices();
      this.computeFaceNormals();
      this.computeVertexNormals();
    };
    THREE.LatheGeometry.prototype = Object.create(THREE.Geometry.prototype);
    THREE.LatheGeometry.prototype.constructor = THREE.LatheGeometry;
    THREE.PlaneGeometry = function(width, height, widthSegments, heightSegments) {
      console.info('THREE.PlaneGeometry: Consider using THREE.PlaneBufferGeometry for lower memory footprint.');
      THREE.Geometry.call(this);
      this.type = 'PlaneGeometry';
      this.parameters = {
        width: width,
        height: height,
        widthSegments: widthSegments,
        heightSegments: heightSegments
      };
      this.fromBufferGeometry(new THREE.PlaneBufferGeometry(width, height, widthSegments, heightSegments));
    };
    THREE.PlaneGeometry.prototype = Object.create(THREE.Geometry.prototype);
    THREE.PlaneGeometry.prototype.constructor = THREE.PlaneGeometry;
    THREE.PlaneBufferGeometry = function(width, height, widthSegments, heightSegments) {
      THREE.BufferGeometry.call(this);
      this.type = 'PlaneBufferGeometry';
      this.parameters = {
        width: width,
        height: height,
        widthSegments: widthSegments,
        heightSegments: heightSegments
      };
      var width_half = width / 2;
      var height_half = height / 2;
      var gridX = widthSegments || 1;
      var gridY = heightSegments || 1;
      var gridX1 = gridX + 1;
      var gridY1 = gridY + 1;
      var segment_width = width / gridX;
      var segment_height = height / gridY;
      var vertices = new Float32Array(gridX1 * gridY1 * 3);
      var normals = new Float32Array(gridX1 * gridY1 * 3);
      var uvs = new Float32Array(gridX1 * gridY1 * 2);
      var offset = 0;
      var offset2 = 0;
      for (var iy = 0; iy < gridY1; iy++) {
        var y = iy * segment_height - height_half;
        for (var ix = 0; ix < gridX1; ix++) {
          var x = ix * segment_width - width_half;
          vertices[offset] = x;
          vertices[offset + 1] = -y;
          normals[offset + 2] = 1;
          uvs[offset2] = ix / gridX;
          uvs[offset2 + 1] = 1 - (iy / gridY);
          offset += 3;
          offset2 += 2;
        }
      }
      offset = 0;
      var indices = new ((vertices.length / 3) > 65535 ? Uint32Array : Uint16Array)(gridX * gridY * 6);
      for (var iy = 0; iy < gridY; iy++) {
        for (var ix = 0; ix < gridX; ix++) {
          var a = ix + gridX1 * iy;
          var b = ix + gridX1 * (iy + 1);
          var c = (ix + 1) + gridX1 * (iy + 1);
          var d = (ix + 1) + gridX1 * iy;
          indices[offset] = a;
          indices[offset + 1] = b;
          indices[offset + 2] = d;
          indices[offset + 3] = b;
          indices[offset + 4] = c;
          indices[offset + 5] = d;
          offset += 6;
        }
      }
      this.addAttribute('index', new THREE.BufferAttribute(indices, 1));
      this.addAttribute('position', new THREE.BufferAttribute(vertices, 3));
      this.addAttribute('normal', new THREE.BufferAttribute(normals, 3));
      this.addAttribute('uv', new THREE.BufferAttribute(uvs, 2));
    };
    THREE.PlaneBufferGeometry.prototype = Object.create(THREE.BufferGeometry.prototype);
    THREE.PlaneBufferGeometry.prototype.constructor = THREE.PlaneBufferGeometry;
    THREE.RingGeometry = function(innerRadius, outerRadius, thetaSegments, phiSegments, thetaStart, thetaLength) {
      THREE.Geometry.call(this);
      this.type = 'RingGeometry';
      this.parameters = {
        innerRadius: innerRadius,
        outerRadius: outerRadius,
        thetaSegments: thetaSegments,
        phiSegments: phiSegments,
        thetaStart: thetaStart,
        thetaLength: thetaLength
      };
      innerRadius = innerRadius || 0;
      outerRadius = outerRadius || 50;
      thetaStart = thetaStart !== undefined ? thetaStart : 0;
      thetaLength = thetaLength !== undefined ? thetaLength : Math.PI * 2;
      thetaSegments = thetaSegments !== undefined ? Math.max(3, thetaSegments) : 8;
      phiSegments = phiSegments !== undefined ? Math.max(1, phiSegments) : 8;
      var i,
          o,
          uvs = [],
          radius = innerRadius,
          radiusStep = ((outerRadius - innerRadius) / phiSegments);
      for (i = 0; i < phiSegments + 1; i++) {
        for (o = 0; o < thetaSegments + 1; o++) {
          var vertex = new THREE.Vector3();
          var segment = thetaStart + o / thetaSegments * thetaLength;
          vertex.x = radius * Math.cos(segment);
          vertex.y = radius * Math.sin(segment);
          this.vertices.push(vertex);
          uvs.push(new THREE.Vector2((vertex.x / outerRadius + 1) / 2, (vertex.y / outerRadius + 1) / 2));
        }
        radius += radiusStep;
      }
      var n = new THREE.Vector3(0, 0, 1);
      for (i = 0; i < phiSegments; i++) {
        var thetaSegment = i * (thetaSegments + 1);
        for (o = 0; o < thetaSegments; o++) {
          var segment = o + thetaSegment;
          var v1 = segment;
          var v2 = segment + thetaSegments + 1;
          var v3 = segment + thetaSegments + 2;
          this.faces.push(new THREE.Face3(v1, v2, v3, [n.clone(), n.clone(), n.clone()]));
          this.faceVertexUvs[0].push([uvs[v1].clone(), uvs[v2].clone(), uvs[v3].clone()]);
          v1 = segment;
          v2 = segment + thetaSegments + 2;
          v3 = segment + 1;
          this.faces.push(new THREE.Face3(v1, v2, v3, [n.clone(), n.clone(), n.clone()]));
          this.faceVertexUvs[0].push([uvs[v1].clone(), uvs[v2].clone(), uvs[v3].clone()]);
        }
      }
      this.computeFaceNormals();
      this.boundingSphere = new THREE.Sphere(new THREE.Vector3(), radius);
    };
    THREE.RingGeometry.prototype = Object.create(THREE.Geometry.prototype);
    THREE.RingGeometry.prototype.constructor = THREE.RingGeometry;
    THREE.SphereGeometry = function(radius, widthSegments, heightSegments, phiStart, phiLength, thetaStart, thetaLength) {
      THREE.Geometry.call(this);
      this.type = 'SphereGeometry';
      this.parameters = {
        radius: radius,
        widthSegments: widthSegments,
        heightSegments: heightSegments,
        phiStart: phiStart,
        phiLength: phiLength,
        thetaStart: thetaStart,
        thetaLength: thetaLength
      };
      radius = radius || 50;
      widthSegments = Math.max(3, Math.floor(widthSegments) || 8);
      heightSegments = Math.max(2, Math.floor(heightSegments) || 6);
      phiStart = phiStart !== undefined ? phiStart : 0;
      phiLength = phiLength !== undefined ? phiLength : Math.PI * 2;
      thetaStart = thetaStart !== undefined ? thetaStart : 0;
      thetaLength = thetaLength !== undefined ? thetaLength : Math.PI;
      var x,
          y,
          vertices = [],
          uvs = [];
      for (y = 0; y <= heightSegments; y++) {
        var verticesRow = [];
        var uvsRow = [];
        for (x = 0; x <= widthSegments; x++) {
          var u = x / widthSegments;
          var v = y / heightSegments;
          var vertex = new THREE.Vector3();
          vertex.x = -radius * Math.cos(phiStart + u * phiLength) * Math.sin(thetaStart + v * thetaLength);
          vertex.y = radius * Math.cos(thetaStart + v * thetaLength);
          vertex.z = radius * Math.sin(phiStart + u * phiLength) * Math.sin(thetaStart + v * thetaLength);
          this.vertices.push(vertex);
          verticesRow.push(this.vertices.length - 1);
          uvsRow.push(new THREE.Vector2(u, 1 - v));
        }
        vertices.push(verticesRow);
        uvs.push(uvsRow);
      }
      for (y = 0; y < heightSegments; y++) {
        for (x = 0; x < widthSegments; x++) {
          var v1 = vertices[y][x + 1];
          var v2 = vertices[y][x];
          var v3 = vertices[y + 1][x];
          var v4 = vertices[y + 1][x + 1];
          var n1 = this.vertices[v1].clone().normalize();
          var n2 = this.vertices[v2].clone().normalize();
          var n3 = this.vertices[v3].clone().normalize();
          var n4 = this.vertices[v4].clone().normalize();
          var uv1 = uvs[y][x + 1].clone();
          var uv2 = uvs[y][x].clone();
          var uv3 = uvs[y + 1][x].clone();
          var uv4 = uvs[y + 1][x + 1].clone();
          if (Math.abs(this.vertices[v1].y) === radius) {
            uv1.x = (uv1.x + uv2.x) / 2;
            this.faces.push(new THREE.Face3(v1, v3, v4, [n1, n3, n4]));
            this.faceVertexUvs[0].push([uv1, uv3, uv4]);
          } else if (Math.abs(this.vertices[v3].y) === radius) {
            uv3.x = (uv3.x + uv4.x) / 2;
            this.faces.push(new THREE.Face3(v1, v2, v3, [n1, n2, n3]));
            this.faceVertexUvs[0].push([uv1, uv2, uv3]);
          } else {
            this.faces.push(new THREE.Face3(v1, v2, v4, [n1, n2, n4]));
            this.faceVertexUvs[0].push([uv1, uv2, uv4]);
            this.faces.push(new THREE.Face3(v2, v3, v4, [n2.clone(), n3, n4.clone()]));
            this.faceVertexUvs[0].push([uv2.clone(), uv3, uv4.clone()]);
          }
        }
      }
      this.computeFaceNormals();
      this.boundingSphere = new THREE.Sphere(new THREE.Vector3(), radius);
    };
    THREE.SphereGeometry.prototype = Object.create(THREE.Geometry.prototype);
    THREE.SphereGeometry.prototype.constructor = THREE.SphereGeometry;
    THREE.TextGeometry = function(text, parameters) {
      parameters = parameters || {};
      var textShapes = THREE.FontUtils.generateShapes(text, parameters);
      parameters.amount = parameters.height !== undefined ? parameters.height : 50;
      if (parameters.bevelThickness === undefined)
        parameters.bevelThickness = 10;
      if (parameters.bevelSize === undefined)
        parameters.bevelSize = 8;
      if (parameters.bevelEnabled === undefined)
        parameters.bevelEnabled = false;
      THREE.ExtrudeGeometry.call(this, textShapes, parameters);
      this.type = 'TextGeometry';
    };
    THREE.TextGeometry.prototype = Object.create(THREE.ExtrudeGeometry.prototype);
    THREE.TextGeometry.prototype.constructor = THREE.TextGeometry;
    THREE.TorusGeometry = function(radius, tube, radialSegments, tubularSegments, arc) {
      THREE.Geometry.call(this);
      this.type = 'TorusGeometry';
      this.parameters = {
        radius: radius,
        tube: tube,
        radialSegments: radialSegments,
        tubularSegments: tubularSegments,
        arc: arc
      };
      radius = radius || 100;
      tube = tube || 40;
      radialSegments = radialSegments || 8;
      tubularSegments = tubularSegments || 6;
      arc = arc || Math.PI * 2;
      var center = new THREE.Vector3(),
          uvs = [],
          normals = [];
      for (var j = 0; j <= radialSegments; j++) {
        for (var i = 0; i <= tubularSegments; i++) {
          var u = i / tubularSegments * arc;
          var v = j / radialSegments * Math.PI * 2;
          center.x = radius * Math.cos(u);
          center.y = radius * Math.sin(u);
          var vertex = new THREE.Vector3();
          vertex.x = (radius + tube * Math.cos(v)) * Math.cos(u);
          vertex.y = (radius + tube * Math.cos(v)) * Math.sin(u);
          vertex.z = tube * Math.sin(v);
          this.vertices.push(vertex);
          uvs.push(new THREE.Vector2(i / tubularSegments, j / radialSegments));
          normals.push(vertex.clone().sub(center).normalize());
        }
      }
      for (var j = 1; j <= radialSegments; j++) {
        for (var i = 1; i <= tubularSegments; i++) {
          var a = (tubularSegments + 1) * j + i - 1;
          var b = (tubularSegments + 1) * (j - 1) + i - 1;
          var c = (tubularSegments + 1) * (j - 1) + i;
          var d = (tubularSegments + 1) * j + i;
          var face = new THREE.Face3(a, b, d, [normals[a].clone(), normals[b].clone(), normals[d].clone()]);
          this.faces.push(face);
          this.faceVertexUvs[0].push([uvs[a].clone(), uvs[b].clone(), uvs[d].clone()]);
          face = new THREE.Face3(b, c, d, [normals[b].clone(), normals[c].clone(), normals[d].clone()]);
          this.faces.push(face);
          this.faceVertexUvs[0].push([uvs[b].clone(), uvs[c].clone(), uvs[d].clone()]);
        }
      }
      this.computeFaceNormals();
    };
    THREE.TorusGeometry.prototype = Object.create(THREE.Geometry.prototype);
    THREE.TorusGeometry.prototype.constructor = THREE.TorusGeometry;
    THREE.TorusKnotGeometry = function(radius, tube, radialSegments, tubularSegments, p, q, heightScale) {
      THREE.Geometry.call(this);
      this.type = 'TorusKnotGeometry';
      this.parameters = {
        radius: radius,
        tube: tube,
        radialSegments: radialSegments,
        tubularSegments: tubularSegments,
        p: p,
        q: q,
        heightScale: heightScale
      };
      radius = radius || 100;
      tube = tube || 40;
      radialSegments = radialSegments || 64;
      tubularSegments = tubularSegments || 8;
      p = p || 2;
      q = q || 3;
      heightScale = heightScale || 1;
      var grid = new Array(radialSegments);
      var tang = new THREE.Vector3();
      var n = new THREE.Vector3();
      var bitan = new THREE.Vector3();
      for (var i = 0; i < radialSegments; ++i) {
        grid[i] = new Array(tubularSegments);
        var u = i / radialSegments * 2 * p * Math.PI;
        var p1 = getPos(u, q, p, radius, heightScale);
        var p2 = getPos(u + 0.01, q, p, radius, heightScale);
        tang.subVectors(p2, p1);
        n.addVectors(p2, p1);
        bitan.crossVectors(tang, n);
        n.crossVectors(bitan, tang);
        bitan.normalize();
        n.normalize();
        for (var j = 0; j < tubularSegments; ++j) {
          var v = j / tubularSegments * 2 * Math.PI;
          var cx = -tube * Math.cos(v);
          var cy = tube * Math.sin(v);
          var pos = new THREE.Vector3();
          pos.x = p1.x + cx * n.x + cy * bitan.x;
          pos.y = p1.y + cx * n.y + cy * bitan.y;
          pos.z = p1.z + cx * n.z + cy * bitan.z;
          grid[i][j] = this.vertices.push(pos) - 1;
        }
      }
      for (var i = 0; i < radialSegments; ++i) {
        for (var j = 0; j < tubularSegments; ++j) {
          var ip = (i + 1) % radialSegments;
          var jp = (j + 1) % tubularSegments;
          var a = grid[i][j];
          var b = grid[ip][j];
          var c = grid[ip][jp];
          var d = grid[i][jp];
          var uva = new THREE.Vector2(i / radialSegments, j / tubularSegments);
          var uvb = new THREE.Vector2((i + 1) / radialSegments, j / tubularSegments);
          var uvc = new THREE.Vector2((i + 1) / radialSegments, (j + 1) / tubularSegments);
          var uvd = new THREE.Vector2(i / radialSegments, (j + 1) / tubularSegments);
          this.faces.push(new THREE.Face3(a, b, d));
          this.faceVertexUvs[0].push([uva, uvb, uvd]);
          this.faces.push(new THREE.Face3(b, c, d));
          this.faceVertexUvs[0].push([uvb.clone(), uvc, uvd.clone()]);
        }
      }
      this.computeFaceNormals();
      this.computeVertexNormals();
      function getPos(u, in_q, in_p, radius, heightScale) {
        var cu = Math.cos(u);
        var su = Math.sin(u);
        var quOverP = in_q / in_p * u;
        var cs = Math.cos(quOverP);
        var tx = radius * (2 + cs) * 0.5 * cu;
        var ty = radius * (2 + cs) * su * 0.5;
        var tz = heightScale * radius * Math.sin(quOverP) * 0.5;
        return new THREE.Vector3(tx, ty, tz);
      }
    };
    THREE.TorusKnotGeometry.prototype = Object.create(THREE.Geometry.prototype);
    THREE.TorusKnotGeometry.prototype.constructor = THREE.TorusKnotGeometry;
    THREE.TubeGeometry = function(path, segments, radius, radialSegments, closed, taper) {
      THREE.Geometry.call(this);
      this.type = 'TubeGeometry';
      this.parameters = {
        path: path,
        segments: segments,
        radius: radius,
        radialSegments: radialSegments,
        closed: closed
      };
      segments = segments || 64;
      radius = radius || 1;
      radialSegments = radialSegments || 8;
      closed = closed || false;
      taper = taper || THREE.TubeGeometry.NoTaper;
      var grid = [];
      var scope = this,
          tangent,
          normal,
          binormal,
          numpoints = segments + 1,
          u,
          v,
          r,
          cx,
          cy,
          pos,
          pos2 = new THREE.Vector3(),
          i,
          j,
          ip,
          jp,
          a,
          b,
          c,
          d,
          uva,
          uvb,
          uvc,
          uvd;
      var frames = new THREE.TubeGeometry.FrenetFrames(path, segments, closed),
          tangents = frames.tangents,
          normals = frames.normals,
          binormals = frames.binormals;
      this.tangents = tangents;
      this.normals = normals;
      this.binormals = binormals;
      function vert(x, y, z) {
        return scope.vertices.push(new THREE.Vector3(x, y, z)) - 1;
      }
      for (i = 0; i < numpoints; i++) {
        grid[i] = [];
        u = i / (numpoints - 1);
        pos = path.getPointAt(u);
        tangent = tangents[i];
        normal = normals[i];
        binormal = binormals[i];
        r = radius * taper(u);
        for (j = 0; j < radialSegments; j++) {
          v = j / radialSegments * 2 * Math.PI;
          cx = -r * Math.cos(v);
          cy = r * Math.sin(v);
          pos2.copy(pos);
          pos2.x += cx * normal.x + cy * binormal.x;
          pos2.y += cx * normal.y + cy * binormal.y;
          pos2.z += cx * normal.z + cy * binormal.z;
          grid[i][j] = vert(pos2.x, pos2.y, pos2.z);
        }
      }
      for (i = 0; i < segments; i++) {
        for (j = 0; j < radialSegments; j++) {
          ip = (closed) ? (i + 1) % segments : i + 1;
          jp = (j + 1) % radialSegments;
          a = grid[i][j];
          b = grid[ip][j];
          c = grid[ip][jp];
          d = grid[i][jp];
          uva = new THREE.Vector2(i / segments, j / radialSegments);
          uvb = new THREE.Vector2((i + 1) / segments, j / radialSegments);
          uvc = new THREE.Vector2((i + 1) / segments, (j + 1) / radialSegments);
          uvd = new THREE.Vector2(i / segments, (j + 1) / radialSegments);
          this.faces.push(new THREE.Face3(a, b, d));
          this.faceVertexUvs[0].push([uva, uvb, uvd]);
          this.faces.push(new THREE.Face3(b, c, d));
          this.faceVertexUvs[0].push([uvb.clone(), uvc, uvd.clone()]);
        }
      }
      this.computeFaceNormals();
      this.computeVertexNormals();
    };
    THREE.TubeGeometry.prototype = Object.create(THREE.Geometry.prototype);
    THREE.TubeGeometry.prototype.constructor = THREE.TubeGeometry;
    THREE.TubeGeometry.NoTaper = function(u) {
      return 1;
    };
    THREE.TubeGeometry.SinusoidalTaper = function(u) {
      return Math.sin(Math.PI * u);
    };
    THREE.TubeGeometry.FrenetFrames = function(path, segments, closed) {
      var normal = new THREE.Vector3(),
          tangents = [],
          normals = [],
          binormals = [],
          vec = new THREE.Vector3(),
          mat = new THREE.Matrix4(),
          numpoints = segments + 1,
          theta,
          epsilon = 0.0001,
          smallest,
          tx,
          ty,
          tz,
          i,
          u;
      this.tangents = tangents;
      this.normals = normals;
      this.binormals = binormals;
      for (i = 0; i < numpoints; i++) {
        u = i / (numpoints - 1);
        tangents[i] = path.getTangentAt(u);
        tangents[i].normalize();
      }
      initialNormal3();
      function initialNormal3() {
        normals[0] = new THREE.Vector3();
        binormals[0] = new THREE.Vector3();
        smallest = Number.MAX_VALUE;
        tx = Math.abs(tangents[0].x);
        ty = Math.abs(tangents[0].y);
        tz = Math.abs(tangents[0].z);
        if (tx <= smallest) {
          smallest = tx;
          normal.set(1, 0, 0);
        }
        if (ty <= smallest) {
          smallest = ty;
          normal.set(0, 1, 0);
        }
        if (tz <= smallest) {
          normal.set(0, 0, 1);
        }
        vec.crossVectors(tangents[0], normal).normalize();
        normals[0].crossVectors(tangents[0], vec);
        binormals[0].crossVectors(tangents[0], normals[0]);
      }
      for (i = 1; i < numpoints; i++) {
        normals[i] = normals[i - 1].clone();
        binormals[i] = binormals[i - 1].clone();
        vec.crossVectors(tangents[i - 1], tangents[i]);
        if (vec.length() > epsilon) {
          vec.normalize();
          theta = Math.acos(THREE.Math.clamp(tangents[i - 1].dot(tangents[i]), -1, 1));
          normals[i].applyMatrix4(mat.makeRotationAxis(vec, theta));
        }
        binormals[i].crossVectors(tangents[i], normals[i]);
      }
      if (closed) {
        theta = Math.acos(THREE.Math.clamp(normals[0].dot(normals[numpoints - 1]), -1, 1));
        theta /= (numpoints - 1);
        if (tangents[0].dot(vec.crossVectors(normals[0], normals[numpoints - 1])) > 0) {
          theta = -theta;
        }
        for (i = 1; i < numpoints; i++) {
          normals[i].applyMatrix4(mat.makeRotationAxis(tangents[i], theta * i));
          binormals[i].crossVectors(tangents[i], normals[i]);
        }
      }
    };
    THREE.PolyhedronGeometry = function(vertices, indices, radius, detail) {
      THREE.Geometry.call(this);
      this.type = 'PolyhedronGeometry';
      this.parameters = {
        vertices: vertices,
        indices: indices,
        radius: radius,
        detail: detail
      };
      radius = radius || 1;
      detail = detail || 0;
      var that = this;
      for (var i = 0,
          l = vertices.length; i < l; i += 3) {
        prepare(new THREE.Vector3(vertices[i], vertices[i + 1], vertices[i + 2]));
      }
      var p = this.vertices;
      var faces = [];
      for (var i = 0,
          j = 0,
          l = indices.length; i < l; i += 3, j++) {
        var v1 = p[indices[i]];
        var v2 = p[indices[i + 1]];
        var v3 = p[indices[i + 2]];
        faces[j] = new THREE.Face3(v1.index, v2.index, v3.index, [v1.clone(), v2.clone(), v3.clone()]);
      }
      var centroid = new THREE.Vector3();
      for (var i = 0,
          l = faces.length; i < l; i++) {
        subdivide(faces[i], detail);
      }
      for (var i = 0,
          l = this.faceVertexUvs[0].length; i < l; i++) {
        var uvs = this.faceVertexUvs[0][i];
        var x0 = uvs[0].x;
        var x1 = uvs[1].x;
        var x2 = uvs[2].x;
        var max = Math.max(x0, Math.max(x1, x2));
        var min = Math.min(x0, Math.min(x1, x2));
        if (max > 0.9 && min < 0.1) {
          if (x0 < 0.2)
            uvs[0].x += 1;
          if (x1 < 0.2)
            uvs[1].x += 1;
          if (x2 < 0.2)
            uvs[2].x += 1;
        }
      }
      for (var i = 0,
          l = this.vertices.length; i < l; i++) {
        this.vertices[i].multiplyScalar(radius);
      }
      this.mergeVertices();
      this.computeFaceNormals();
      this.boundingSphere = new THREE.Sphere(new THREE.Vector3(), radius);
      function prepare(vector) {
        var vertex = vector.normalize().clone();
        vertex.index = that.vertices.push(vertex) - 1;
        var u = azimuth(vector) / 2 / Math.PI + 0.5;
        var v = inclination(vector) / Math.PI + 0.5;
        vertex.uv = new THREE.Vector2(u, 1 - v);
        return vertex;
      }
      function make(v1, v2, v3) {
        var face = new THREE.Face3(v1.index, v2.index, v3.index, [v1.clone(), v2.clone(), v3.clone()]);
        that.faces.push(face);
        centroid.copy(v1).add(v2).add(v3).divideScalar(3);
        var azi = azimuth(centroid);
        that.faceVertexUvs[0].push([correctUV(v1.uv, v1, azi), correctUV(v2.uv, v2, azi), correctUV(v3.uv, v3, azi)]);
      }
      function subdivide(face, detail) {
        var cols = Math.pow(2, detail);
        var a = prepare(that.vertices[face.a]);
        var b = prepare(that.vertices[face.b]);
        var c = prepare(that.vertices[face.c]);
        var v = [];
        for (var i = 0; i <= cols; i++) {
          v[i] = [];
          var aj = prepare(a.clone().lerp(c, i / cols));
          var bj = prepare(b.clone().lerp(c, i / cols));
          var rows = cols - i;
          for (var j = 0; j <= rows; j++) {
            if (j == 0 && i == cols) {
              v[i][j] = aj;
            } else {
              v[i][j] = prepare(aj.clone().lerp(bj, j / rows));
            }
          }
        }
        for (var i = 0; i < cols; i++) {
          for (var j = 0; j < 2 * (cols - i) - 1; j++) {
            var k = Math.floor(j / 2);
            if (j % 2 == 0) {
              make(v[i][k + 1], v[i + 1][k], v[i][k]);
            } else {
              make(v[i][k + 1], v[i + 1][k + 1], v[i + 1][k]);
            }
          }
        }
      }
      function azimuth(vector) {
        return Math.atan2(vector.z, -vector.x);
      }
      function inclination(vector) {
        return Math.atan2(-vector.y, Math.sqrt((vector.x * vector.x) + (vector.z * vector.z)));
      }
      function correctUV(uv, vector, azimuth) {
        if ((azimuth < 0) && (uv.x === 1))
          uv = new THREE.Vector2(uv.x - 1, uv.y);
        if ((vector.x === 0) && (vector.z === 0))
          uv = new THREE.Vector2(azimuth / 2 / Math.PI + 0.5, uv.y);
        return uv.clone();
      }
    };
    THREE.PolyhedronGeometry.prototype = Object.create(THREE.Geometry.prototype);
    THREE.PolyhedronGeometry.prototype.constructor = THREE.PolyhedronGeometry;
    THREE.DodecahedronGeometry = function(radius, detail) {
      this.parameters = {
        radius: radius,
        detail: detail
      };
      var t = (1 + Math.sqrt(5)) / 2;
      var r = 1 / t;
      var vertices = [-1, -1, -1, -1, -1, 1, -1, 1, -1, -1, 1, 1, 1, -1, -1, 1, -1, 1, 1, 1, -1, 1, 1, 1, 0, -r, -t, 0, -r, t, 0, r, -t, 0, r, t, -r, -t, 0, -r, t, 0, r, -t, 0, r, t, 0, -t, 0, -r, t, 0, -r, -t, 0, r, t, 0, r];
      var indices = [3, 11, 7, 3, 7, 15, 3, 15, 13, 7, 19, 17, 7, 17, 6, 7, 6, 15, 17, 4, 8, 17, 8, 10, 17, 10, 6, 8, 0, 16, 8, 16, 2, 8, 2, 10, 0, 12, 1, 0, 1, 18, 0, 18, 16, 6, 10, 2, 6, 2, 13, 6, 13, 15, 2, 16, 18, 2, 18, 3, 2, 3, 13, 18, 1, 9, 18, 9, 11, 18, 11, 3, 4, 14, 12, 4, 12, 0, 4, 0, 8, 11, 9, 5, 11, 5, 19, 11, 19, 7, 19, 5, 14, 19, 14, 4, 19, 4, 17, 1, 12, 14, 1, 14, 5, 1, 5, 9];
      THREE.PolyhedronGeometry.call(this, vertices, indices, radius, detail);
    };
    THREE.DodecahedronGeometry.prototype = Object.create(THREE.Geometry.prototype);
    THREE.DodecahedronGeometry.prototype.constructor = THREE.DodecahedronGeometry;
    THREE.IcosahedronGeometry = function(radius, detail) {
      var t = (1 + Math.sqrt(5)) / 2;
      var vertices = [-1, t, 0, 1, t, 0, -1, -t, 0, 1, -t, 0, 0, -1, t, 0, 1, t, 0, -1, -t, 0, 1, -t, t, 0, -1, t, 0, 1, -t, 0, -1, -t, 0, 1];
      var indices = [0, 11, 5, 0, 5, 1, 0, 1, 7, 0, 7, 10, 0, 10, 11, 1, 5, 9, 5, 11, 4, 11, 10, 2, 10, 7, 6, 7, 1, 8, 3, 9, 4, 3, 4, 2, 3, 2, 6, 3, 6, 8, 3, 8, 9, 4, 9, 5, 2, 4, 11, 6, 2, 10, 8, 6, 7, 9, 8, 1];
      THREE.PolyhedronGeometry.call(this, vertices, indices, radius, detail);
      this.type = 'IcosahedronGeometry';
      this.parameters = {
        radius: radius,
        detail: detail
      };
    };
    THREE.IcosahedronGeometry.prototype = Object.create(THREE.Geometry.prototype);
    THREE.IcosahedronGeometry.prototype.constructor = THREE.IcosahedronGeometry;
    THREE.OctahedronGeometry = function(radius, detail) {
      this.parameters = {
        radius: radius,
        detail: detail
      };
      var vertices = [1, 0, 0, -1, 0, 0, 0, 1, 0, 0, -1, 0, 0, 0, 1, 0, 0, -1];
      var indices = [0, 2, 4, 0, 4, 3, 0, 3, 5, 0, 5, 2, 1, 2, 5, 1, 5, 3, 1, 3, 4, 1, 4, 2];
      THREE.PolyhedronGeometry.call(this, vertices, indices, radius, detail);
      this.type = 'OctahedronGeometry';
      this.parameters = {
        radius: radius,
        detail: detail
      };
    };
    THREE.OctahedronGeometry.prototype = Object.create(THREE.Geometry.prototype);
    THREE.OctahedronGeometry.prototype.constructor = THREE.OctahedronGeometry;
    THREE.TetrahedronGeometry = function(radius, detail) {
      var vertices = [1, 1, 1, -1, -1, 1, -1, 1, -1, 1, -1, -1];
      var indices = [2, 1, 0, 0, 3, 2, 1, 3, 0, 2, 3, 1];
      THREE.PolyhedronGeometry.call(this, vertices, indices, radius, detail);
      this.type = 'TetrahedronGeometry';
      this.parameters = {
        radius: radius,
        detail: detail
      };
    };
    THREE.TetrahedronGeometry.prototype = Object.create(THREE.Geometry.prototype);
    THREE.TetrahedronGeometry.prototype.constructor = THREE.TetrahedronGeometry;
    THREE.ParametricGeometry = function(func, slices, stacks) {
      THREE.Geometry.call(this);
      this.type = 'ParametricGeometry';
      this.parameters = {
        func: func,
        slices: slices,
        stacks: stacks
      };
      var verts = this.vertices;
      var faces = this.faces;
      var uvs = this.faceVertexUvs[0];
      var i,
          j,
          p;
      var u,
          v;
      var sliceCount = slices + 1;
      for (i = 0; i <= stacks; i++) {
        v = i / stacks;
        for (j = 0; j <= slices; j++) {
          u = j / slices;
          p = func(u, v);
          verts.push(p);
        }
      }
      var a,
          b,
          c,
          d;
      var uva,
          uvb,
          uvc,
          uvd;
      for (i = 0; i < stacks; i++) {
        for (j = 0; j < slices; j++) {
          a = i * sliceCount + j;
          b = i * sliceCount + j + 1;
          c = (i + 1) * sliceCount + j + 1;
          d = (i + 1) * sliceCount + j;
          uva = new THREE.Vector2(j / slices, i / stacks);
          uvb = new THREE.Vector2((j + 1) / slices, i / stacks);
          uvc = new THREE.Vector2((j + 1) / slices, (i + 1) / stacks);
          uvd = new THREE.Vector2(j / slices, (i + 1) / stacks);
          faces.push(new THREE.Face3(a, b, d));
          uvs.push([uva, uvb, uvd]);
          faces.push(new THREE.Face3(b, c, d));
          uvs.push([uvb.clone(), uvc, uvd.clone()]);
        }
      }
      this.computeFaceNormals();
      this.computeVertexNormals();
    };
    THREE.ParametricGeometry.prototype = Object.create(THREE.Geometry.prototype);
    THREE.ParametricGeometry.prototype.constructor = THREE.ParametricGeometry;
    THREE.AxisHelper = function(size) {
      size = size || 1;
      var vertices = new Float32Array([0, 0, 0, size, 0, 0, 0, 0, 0, 0, size, 0, 0, 0, 0, 0, 0, size]);
      var colors = new Float32Array([1, 0, 0, 1, 0.6, 0, 0, 1, 0, 0.6, 1, 0, 0, 0, 1, 0, 0.6, 1]);
      var geometry = new THREE.BufferGeometry();
      geometry.addAttribute('position', new THREE.BufferAttribute(vertices, 3));
      geometry.addAttribute('color', new THREE.BufferAttribute(colors, 3));
      var material = new THREE.LineBasicMaterial({vertexColors: THREE.VertexColors});
      THREE.Line.call(this, geometry, material, THREE.LinePieces);
    };
    THREE.AxisHelper.prototype = Object.create(THREE.Line.prototype);
    THREE.AxisHelper.prototype.constructor = THREE.AxisHelper;
    THREE.ArrowHelper = (function() {
      var lineGeometry = new THREE.Geometry();
      lineGeometry.vertices.push(new THREE.Vector3(0, 0, 0), new THREE.Vector3(0, 1, 0));
      var coneGeometry = new THREE.CylinderGeometry(0, 0.5, 1, 5, 1);
      coneGeometry.applyMatrix(new THREE.Matrix4().makeTranslation(0, -0.5, 0));
      return function(dir, origin, length, color, headLength, headWidth) {
        THREE.Object3D.call(this);
        if (color === undefined)
          color = 0xffff00;
        if (length === undefined)
          length = 1;
        if (headLength === undefined)
          headLength = 0.2 * length;
        if (headWidth === undefined)
          headWidth = 0.2 * headLength;
        this.position.copy(origin);
        this.line = new THREE.Line(lineGeometry, new THREE.LineBasicMaterial({color: color}));
        this.line.matrixAutoUpdate = false;
        this.add(this.line);
        this.cone = new THREE.Mesh(coneGeometry, new THREE.MeshBasicMaterial({color: color}));
        this.cone.matrixAutoUpdate = false;
        this.add(this.cone);
        this.setDirection(dir);
        this.setLength(length, headLength, headWidth);
      };
    }());
    THREE.ArrowHelper.prototype = Object.create(THREE.Object3D.prototype);
    THREE.ArrowHelper.prototype.constructor = THREE.ArrowHelper;
    THREE.ArrowHelper.prototype.setDirection = (function() {
      var axis = new THREE.Vector3();
      var radians;
      return function(dir) {
        if (dir.y > 0.99999) {
          this.quaternion.set(0, 0, 0, 1);
        } else if (dir.y < -0.99999) {
          this.quaternion.set(1, 0, 0, 0);
        } else {
          axis.set(dir.z, 0, -dir.x).normalize();
          radians = Math.acos(dir.y);
          this.quaternion.setFromAxisAngle(axis, radians);
        }
      };
    }());
    THREE.ArrowHelper.prototype.setLength = function(length, headLength, headWidth) {
      if (headLength === undefined)
        headLength = 0.2 * length;
      if (headWidth === undefined)
        headWidth = 0.2 * headLength;
      this.line.scale.set(1, length - headLength, 1);
      this.line.updateMatrix();
      this.cone.scale.set(headWidth, headLength, headWidth);
      this.cone.position.y = length;
      this.cone.updateMatrix();
    };
    THREE.ArrowHelper.prototype.setColor = function(color) {
      this.line.material.color.set(color);
      this.cone.material.color.set(color);
    };
    THREE.BoxHelper = function(object) {
      var geometry = new THREE.BufferGeometry();
      geometry.addAttribute('position', new THREE.BufferAttribute(new Float32Array(72), 3));
      THREE.Line.call(this, geometry, new THREE.LineBasicMaterial({color: 0xffff00}), THREE.LinePieces);
      if (object !== undefined) {
        this.update(object);
      }
    };
    THREE.BoxHelper.prototype = Object.create(THREE.Line.prototype);
    THREE.BoxHelper.prototype.constructor = THREE.BoxHelper;
    THREE.BoxHelper.prototype.update = function(object) {
      var geometry = object.geometry;
      if (geometry.boundingBox === null) {
        geometry.computeBoundingBox();
      }
      var min = geometry.boundingBox.min;
      var max = geometry.boundingBox.max;
      var vertices = this.geometry.attributes.position.array;
      vertices[0] = max.x;
      vertices[1] = max.y;
      vertices[2] = max.z;
      vertices[3] = min.x;
      vertices[4] = max.y;
      vertices[5] = max.z;
      vertices[6] = min.x;
      vertices[7] = max.y;
      vertices[8] = max.z;
      vertices[9] = min.x;
      vertices[10] = min.y;
      vertices[11] = max.z;
      vertices[12] = min.x;
      vertices[13] = min.y;
      vertices[14] = max.z;
      vertices[15] = max.x;
      vertices[16] = min.y;
      vertices[17] = max.z;
      vertices[18] = max.x;
      vertices[19] = min.y;
      vertices[20] = max.z;
      vertices[21] = max.x;
      vertices[22] = max.y;
      vertices[23] = max.z;
      vertices[24] = max.x;
      vertices[25] = max.y;
      vertices[26] = min.z;
      vertices[27] = min.x;
      vertices[28] = max.y;
      vertices[29] = min.z;
      vertices[30] = min.x;
      vertices[31] = max.y;
      vertices[32] = min.z;
      vertices[33] = min.x;
      vertices[34] = min.y;
      vertices[35] = min.z;
      vertices[36] = min.x;
      vertices[37] = min.y;
      vertices[38] = min.z;
      vertices[39] = max.x;
      vertices[40] = min.y;
      vertices[41] = min.z;
      vertices[42] = max.x;
      vertices[43] = min.y;
      vertices[44] = min.z;
      vertices[45] = max.x;
      vertices[46] = max.y;
      vertices[47] = min.z;
      vertices[48] = max.x;
      vertices[49] = max.y;
      vertices[50] = max.z;
      vertices[51] = max.x;
      vertices[52] = max.y;
      vertices[53] = min.z;
      vertices[54] = min.x;
      vertices[55] = max.y;
      vertices[56] = max.z;
      vertices[57] = min.x;
      vertices[58] = max.y;
      vertices[59] = min.z;
      vertices[60] = min.x;
      vertices[61] = min.y;
      vertices[62] = max.z;
      vertices[63] = min.x;
      vertices[64] = min.y;
      vertices[65] = min.z;
      vertices[66] = max.x;
      vertices[67] = min.y;
      vertices[68] = max.z;
      vertices[69] = max.x;
      vertices[70] = min.y;
      vertices[71] = min.z;
      this.geometry.attributes.position.needsUpdate = true;
      this.geometry.computeBoundingSphere();
      this.matrix = object.matrixWorld;
      this.matrixAutoUpdate = false;
    };
    THREE.BoundingBoxHelper = function(object, hex) {
      var color = (hex !== undefined) ? hex : 0x888888;
      this.object = object;
      this.box = new THREE.Box3();
      THREE.Mesh.call(this, new THREE.BoxGeometry(1, 1, 1), new THREE.MeshBasicMaterial({
        color: color,
        wireframe: true
      }));
    };
    THREE.BoundingBoxHelper.prototype = Object.create(THREE.Mesh.prototype);
    THREE.BoundingBoxHelper.prototype.constructor = THREE.BoundingBoxHelper;
    THREE.BoundingBoxHelper.prototype.update = function() {
      this.box.setFromObject(this.object);
      this.box.size(this.scale);
      this.box.center(this.position);
    };
    THREE.CameraHelper = function(camera) {
      var geometry = new THREE.Geometry();
      var material = new THREE.LineBasicMaterial({
        color: 0xffffff,
        vertexColors: THREE.FaceColors
      });
      var pointMap = {};
      var hexFrustum = 0xffaa00;
      var hexCone = 0xff0000;
      var hexUp = 0x00aaff;
      var hexTarget = 0xffffff;
      var hexCross = 0x333333;
      addLine("n1", "n2", hexFrustum);
      addLine("n2", "n4", hexFrustum);
      addLine("n4", "n3", hexFrustum);
      addLine("n3", "n1", hexFrustum);
      addLine("f1", "f2", hexFrustum);
      addLine("f2", "f4", hexFrustum);
      addLine("f4", "f3", hexFrustum);
      addLine("f3", "f1", hexFrustum);
      addLine("n1", "f1", hexFrustum);
      addLine("n2", "f2", hexFrustum);
      addLine("n3", "f3", hexFrustum);
      addLine("n4", "f4", hexFrustum);
      addLine("p", "n1", hexCone);
      addLine("p", "n2", hexCone);
      addLine("p", "n3", hexCone);
      addLine("p", "n4", hexCone);
      addLine("u1", "u2", hexUp);
      addLine("u2", "u3", hexUp);
      addLine("u3", "u1", hexUp);
      addLine("c", "t", hexTarget);
      addLine("p", "c", hexCross);
      addLine("cn1", "cn2", hexCross);
      addLine("cn3", "cn4", hexCross);
      addLine("cf1", "cf2", hexCross);
      addLine("cf3", "cf4", hexCross);
      function addLine(a, b, hex) {
        addPoint(a, hex);
        addPoint(b, hex);
      }
      function addPoint(id, hex) {
        geometry.vertices.push(new THREE.Vector3());
        geometry.colors.push(new THREE.Color(hex));
        if (pointMap[id] === undefined) {
          pointMap[id] = [];
        }
        pointMap[id].push(geometry.vertices.length - 1);
      }
      THREE.Line.call(this, geometry, material, THREE.LinePieces);
      this.camera = camera;
      this.matrix = camera.matrixWorld;
      this.matrixAutoUpdate = false;
      this.pointMap = pointMap;
      this.update();
    };
    THREE.CameraHelper.prototype = Object.create(THREE.Line.prototype);
    THREE.CameraHelper.prototype.constructor = THREE.CameraHelper;
    THREE.CameraHelper.prototype.update = function() {
      var geometry,
          pointMap;
      var vector = new THREE.Vector3();
      var camera = new THREE.Camera();
      var setPoint = function(point, x, y, z) {
        vector.set(x, y, z).unproject(camera);
        var points = pointMap[point];
        if (points !== undefined) {
          for (var i = 0,
              il = points.length; i < il; i++) {
            geometry.vertices[points[i]].copy(vector);
          }
        }
      };
      return function() {
        geometry = this.geometry;
        pointMap = this.pointMap;
        var w = 1,
            h = 1;
        camera.projectionMatrix.copy(this.camera.projectionMatrix);
        setPoint("c", 0, 0, -1);
        setPoint("t", 0, 0, 1);
        setPoint("n1", -w, -h, -1);
        setPoint("n2", w, -h, -1);
        setPoint("n3", -w, h, -1);
        setPoint("n4", w, h, -1);
        setPoint("f1", -w, -h, 1);
        setPoint("f2", w, -h, 1);
        setPoint("f3", -w, h, 1);
        setPoint("f4", w, h, 1);
        setPoint("u1", w * 0.7, h * 1.1, -1);
        setPoint("u2", -w * 0.7, h * 1.1, -1);
        setPoint("u3", 0, h * 2, -1);
        setPoint("cf1", -w, 0, 1);
        setPoint("cf2", w, 0, 1);
        setPoint("cf3", 0, -h, 1);
        setPoint("cf4", 0, h, 1);
        setPoint("cn1", -w, 0, -1);
        setPoint("cn2", w, 0, -1);
        setPoint("cn3", 0, -h, -1);
        setPoint("cn4", 0, h, -1);
        geometry.verticesNeedUpdate = true;
      };
    }();
    THREE.DirectionalLightHelper = function(light, size) {
      THREE.Object3D.call(this);
      this.light = light;
      this.light.updateMatrixWorld();
      this.matrix = light.matrixWorld;
      this.matrixAutoUpdate = false;
      size = size || 1;
      var geometry = new THREE.Geometry();
      geometry.vertices.push(new THREE.Vector3(-size, size, 0), new THREE.Vector3(size, size, 0), new THREE.Vector3(size, -size, 0), new THREE.Vector3(-size, -size, 0), new THREE.Vector3(-size, size, 0));
      var material = new THREE.LineBasicMaterial({fog: false});
      material.color.copy(this.light.color).multiplyScalar(this.light.intensity);
      this.lightPlane = new THREE.Line(geometry, material);
      this.add(this.lightPlane);
      geometry = new THREE.Geometry();
      geometry.vertices.push(new THREE.Vector3(), new THREE.Vector3());
      material = new THREE.LineBasicMaterial({fog: false});
      material.color.copy(this.light.color).multiplyScalar(this.light.intensity);
      this.targetLine = new THREE.Line(geometry, material);
      this.add(this.targetLine);
      this.update();
    };
    THREE.DirectionalLightHelper.prototype = Object.create(THREE.Object3D.prototype);
    THREE.DirectionalLightHelper.prototype.constructor = THREE.DirectionalLightHelper;
    THREE.DirectionalLightHelper.prototype.dispose = function() {
      this.lightPlane.geometry.dispose();
      this.lightPlane.material.dispose();
      this.targetLine.geometry.dispose();
      this.targetLine.material.dispose();
    };
    THREE.DirectionalLightHelper.prototype.update = function() {
      var v1 = new THREE.Vector3();
      var v2 = new THREE.Vector3();
      var v3 = new THREE.Vector3();
      return function() {
        v1.setFromMatrixPosition(this.light.matrixWorld);
        v2.setFromMatrixPosition(this.light.target.matrixWorld);
        v3.subVectors(v2, v1);
        this.lightPlane.lookAt(v3);
        this.lightPlane.material.color.copy(this.light.color).multiplyScalar(this.light.intensity);
        this.targetLine.geometry.vertices[1].copy(v3);
        this.targetLine.geometry.verticesNeedUpdate = true;
        this.targetLine.material.color.copy(this.lightPlane.material.color);
      };
    }();
    THREE.EdgesHelper = function(object, hex, thresholdAngle) {
      var color = (hex !== undefined) ? hex : 0xffffff;
      thresholdAngle = (thresholdAngle !== undefined) ? thresholdAngle : 1;
      var thresholdDot = Math.cos(THREE.Math.degToRad(thresholdAngle));
      var edge = [0, 0],
          hash = {};
      var sortFunction = function(a, b) {
        return a - b;
      };
      var keys = ['a', 'b', 'c'];
      var geometry = new THREE.BufferGeometry();
      var geometry2;
      if (object.geometry instanceof THREE.BufferGeometry) {
        geometry2 = new THREE.Geometry();
        geometry2.fromBufferGeometry(object.geometry);
      } else {
        geometry2 = object.geometry.clone();
      }
      geometry2.mergeVertices();
      geometry2.computeFaceNormals();
      var vertices = geometry2.vertices;
      var faces = geometry2.faces;
      var numEdges = 0;
      for (var i = 0,
          l = faces.length; i < l; i++) {
        var face = faces[i];
        for (var j = 0; j < 3; j++) {
          edge[0] = face[keys[j]];
          edge[1] = face[keys[(j + 1) % 3]];
          edge.sort(sortFunction);
          var key = edge.toString();
          if (hash[key] === undefined) {
            hash[key] = {
              vert1: edge[0],
              vert2: edge[1],
              face1: i,
              face2: undefined
            };
            numEdges++;
          } else {
            hash[key].face2 = i;
          }
        }
      }
      var coords = new Float32Array(numEdges * 2 * 3);
      var index = 0;
      for (var key in hash) {
        var h = hash[key];
        if (h.face2 === undefined || faces[h.face1].normal.dot(faces[h.face2].normal) <= thresholdDot) {
          var vertex = vertices[h.vert1];
          coords[index++] = vertex.x;
          coords[index++] = vertex.y;
          coords[index++] = vertex.z;
          vertex = vertices[h.vert2];
          coords[index++] = vertex.x;
          coords[index++] = vertex.y;
          coords[index++] = vertex.z;
        }
      }
      geometry.addAttribute('position', new THREE.BufferAttribute(coords, 3));
      THREE.Line.call(this, geometry, new THREE.LineBasicMaterial({color: color}), THREE.LinePieces);
      this.matrix = object.matrixWorld;
      this.matrixAutoUpdate = false;
    };
    THREE.EdgesHelper.prototype = Object.create(THREE.Line.prototype);
    THREE.EdgesHelper.prototype.constructor = THREE.EdgesHelper;
    THREE.FaceNormalsHelper = function(object, size, hex, linewidth) {
      this.object = object;
      this.size = (size !== undefined) ? size : 1;
      var color = (hex !== undefined) ? hex : 0xffff00;
      var width = (linewidth !== undefined) ? linewidth : 1;
      var geometry = new THREE.Geometry();
      var faces = this.object.geometry.faces;
      for (var i = 0,
          l = faces.length; i < l; i++) {
        geometry.vertices.push(new THREE.Vector3(), new THREE.Vector3());
      }
      THREE.Line.call(this, geometry, new THREE.LineBasicMaterial({
        color: color,
        linewidth: width
      }), THREE.LinePieces);
      this.matrixAutoUpdate = false;
      this.normalMatrix = new THREE.Matrix3();
      this.update();
    };
    THREE.FaceNormalsHelper.prototype = Object.create(THREE.Line.prototype);
    THREE.FaceNormalsHelper.prototype.constructor = THREE.FaceNormalsHelper;
    THREE.FaceNormalsHelper.prototype.update = function() {
      var vertices = this.geometry.vertices;
      var object = this.object;
      var objectVertices = object.geometry.vertices;
      var objectFaces = object.geometry.faces;
      var objectWorldMatrix = object.matrixWorld;
      object.updateMatrixWorld(true);
      this.normalMatrix.getNormalMatrix(objectWorldMatrix);
      for (var i = 0,
          i2 = 0,
          l = objectFaces.length; i < l; i++, i2 += 2) {
        var face = objectFaces[i];
        vertices[i2].copy(objectVertices[face.a]).add(objectVertices[face.b]).add(objectVertices[face.c]).divideScalar(3).applyMatrix4(objectWorldMatrix);
        vertices[i2 + 1].copy(face.normal).applyMatrix3(this.normalMatrix).normalize().multiplyScalar(this.size).add(vertices[i2]);
      }
      this.geometry.verticesNeedUpdate = true;
      return this;
    };
    THREE.GridHelper = function(size, step) {
      var geometry = new THREE.Geometry();
      var material = new THREE.LineBasicMaterial({vertexColors: THREE.VertexColors});
      this.color1 = new THREE.Color(0x444444);
      this.color2 = new THREE.Color(0x888888);
      for (var i = -size; i <= size; i += step) {
        geometry.vertices.push(new THREE.Vector3(-size, 0, i), new THREE.Vector3(size, 0, i), new THREE.Vector3(i, 0, -size), new THREE.Vector3(i, 0, size));
        var color = i === 0 ? this.color1 : this.color2;
        geometry.colors.push(color, color, color, color);
      }
      THREE.Line.call(this, geometry, material, THREE.LinePieces);
    };
    THREE.GridHelper.prototype = Object.create(THREE.Line.prototype);
    THREE.GridHelper.prototype.constructor = THREE.GridHelper;
    THREE.GridHelper.prototype.setColors = function(colorCenterLine, colorGrid) {
      this.color1.set(colorCenterLine);
      this.color2.set(colorGrid);
      this.geometry.colorsNeedUpdate = true;
    };
    THREE.HemisphereLightHelper = function(light, sphereSize) {
      THREE.Object3D.call(this);
      this.light = light;
      this.light.updateMatrixWorld();
      this.matrix = light.matrixWorld;
      this.matrixAutoUpdate = false;
      this.colors = [new THREE.Color(), new THREE.Color()];
      var geometry = new THREE.SphereGeometry(sphereSize, 4, 2);
      geometry.applyMatrix(new THREE.Matrix4().makeRotationX(-Math.PI / 2));
      for (var i = 0,
          il = 8; i < il; i++) {
        geometry.faces[i].color = this.colors[i < 4 ? 0 : 1];
      }
      var material = new THREE.MeshBasicMaterial({
        vertexColors: THREE.FaceColors,
        wireframe: true
      });
      this.lightSphere = new THREE.Mesh(geometry, material);
      this.add(this.lightSphere);
      this.update();
    };
    THREE.HemisphereLightHelper.prototype = Object.create(THREE.Object3D.prototype);
    THREE.HemisphereLightHelper.prototype.constructor = THREE.HemisphereLightHelper;
    THREE.HemisphereLightHelper.prototype.dispose = function() {
      this.lightSphere.geometry.dispose();
      this.lightSphere.material.dispose();
    };
    THREE.HemisphereLightHelper.prototype.update = function() {
      var vector = new THREE.Vector3();
      return function() {
        this.colors[0].copy(this.light.color).multiplyScalar(this.light.intensity);
        this.colors[1].copy(this.light.groundColor).multiplyScalar(this.light.intensity);
        this.lightSphere.lookAt(vector.setFromMatrixPosition(this.light.matrixWorld).negate());
        this.lightSphere.geometry.colorsNeedUpdate = true;
      };
    }();
    THREE.PointLightHelper = function(light, sphereSize) {
      this.light = light;
      this.light.updateMatrixWorld();
      var geometry = new THREE.SphereGeometry(sphereSize, 4, 2);
      var material = new THREE.MeshBasicMaterial({
        wireframe: true,
        fog: false
      });
      material.color.copy(this.light.color).multiplyScalar(this.light.intensity);
      THREE.Mesh.call(this, geometry, material);
      this.matrix = this.light.matrixWorld;
      this.matrixAutoUpdate = false;
    };
    THREE.PointLightHelper.prototype = Object.create(THREE.Mesh.prototype);
    THREE.PointLightHelper.prototype.constructor = THREE.PointLightHelper;
    THREE.PointLightHelper.prototype.dispose = function() {
      this.geometry.dispose();
      this.material.dispose();
    };
    THREE.PointLightHelper.prototype.update = function() {
      this.material.color.copy(this.light.color).multiplyScalar(this.light.intensity);
    };
    THREE.SkeletonHelper = function(object) {
      this.bones = this.getBoneList(object);
      var geometry = new THREE.Geometry();
      for (var i = 0; i < this.bones.length; i++) {
        var bone = this.bones[i];
        if (bone.parent instanceof THREE.Bone) {
          geometry.vertices.push(new THREE.Vector3());
          geometry.vertices.push(new THREE.Vector3());
          geometry.colors.push(new THREE.Color(0, 0, 1));
          geometry.colors.push(new THREE.Color(0, 1, 0));
        }
      }
      var material = new THREE.LineBasicMaterial({
        vertexColors: THREE.VertexColors,
        depthTest: false,
        depthWrite: false,
        transparent: true
      });
      THREE.Line.call(this, geometry, material, THREE.LinePieces);
      this.root = object;
      this.matrix = object.matrixWorld;
      this.matrixAutoUpdate = false;
      this.update();
    };
    THREE.SkeletonHelper.prototype = Object.create(THREE.Line.prototype);
    THREE.SkeletonHelper.prototype.constructor = THREE.SkeletonHelper;
    THREE.SkeletonHelper.prototype.getBoneList = function(object) {
      var boneList = [];
      if (object instanceof THREE.Bone) {
        boneList.push(object);
      }
      for (var i = 0; i < object.children.length; i++) {
        boneList.push.apply(boneList, this.getBoneList(object.children[i]));
      }
      return boneList;
    };
    THREE.SkeletonHelper.prototype.update = function() {
      var geometry = this.geometry;
      var matrixWorldInv = new THREE.Matrix4().getInverse(this.root.matrixWorld);
      var boneMatrix = new THREE.Matrix4();
      var j = 0;
      for (var i = 0; i < this.bones.length; i++) {
        var bone = this.bones[i];
        if (bone.parent instanceof THREE.Bone) {
          boneMatrix.multiplyMatrices(matrixWorldInv, bone.matrixWorld);
          geometry.vertices[j].setFromMatrixPosition(boneMatrix);
          boneMatrix.multiplyMatrices(matrixWorldInv, bone.parent.matrixWorld);
          geometry.vertices[j + 1].setFromMatrixPosition(boneMatrix);
          j += 2;
        }
      }
      geometry.verticesNeedUpdate = true;
      geometry.computeBoundingSphere();
    };
    THREE.SpotLightHelper = function(light) {
      THREE.Object3D.call(this);
      this.light = light;
      this.light.updateMatrixWorld();
      this.matrix = light.matrixWorld;
      this.matrixAutoUpdate = false;
      var geometry = new THREE.CylinderGeometry(0, 1, 1, 8, 1, true);
      geometry.applyMatrix(new THREE.Matrix4().makeTranslation(0, -0.5, 0));
      geometry.applyMatrix(new THREE.Matrix4().makeRotationX(-Math.PI / 2));
      var material = new THREE.MeshBasicMaterial({
        wireframe: true,
        fog: false
      });
      this.cone = new THREE.Mesh(geometry, material);
      this.add(this.cone);
      this.update();
    };
    THREE.SpotLightHelper.prototype = Object.create(THREE.Object3D.prototype);
    THREE.SpotLightHelper.prototype.constructor = THREE.SpotLightHelper;
    THREE.SpotLightHelper.prototype.dispose = function() {
      this.cone.geometry.dispose();
      this.cone.material.dispose();
    };
    THREE.SpotLightHelper.prototype.update = function() {
      var vector = new THREE.Vector3();
      var vector2 = new THREE.Vector3();
      return function() {
        var coneLength = this.light.distance ? this.light.distance : 10000;
        var coneWidth = coneLength * Math.tan(this.light.angle);
        this.cone.scale.set(coneWidth, coneWidth, coneLength);
        vector.setFromMatrixPosition(this.light.matrixWorld);
        vector2.setFromMatrixPosition(this.light.target.matrixWorld);
        this.cone.lookAt(vector2.sub(vector));
        this.cone.material.color.copy(this.light.color).multiplyScalar(this.light.intensity);
      };
    }();
    THREE.VertexNormalsHelper = function(object, size, hex, linewidth) {
      this.object = object;
      this.size = (size !== undefined) ? size : 1;
      var color = (hex !== undefined) ? hex : 0xff0000;
      var width = (linewidth !== undefined) ? linewidth : 1;
      var geometry = new THREE.Geometry();
      var faces = object.geometry.faces;
      for (var i = 0,
          l = faces.length; i < l; i++) {
        var face = faces[i];
        for (var j = 0,
            jl = face.vertexNormals.length; j < jl; j++) {
          geometry.vertices.push(new THREE.Vector3(), new THREE.Vector3());
        }
      }
      THREE.Line.call(this, geometry, new THREE.LineBasicMaterial({
        color: color,
        linewidth: width
      }), THREE.LinePieces);
      this.matrixAutoUpdate = false;
      this.normalMatrix = new THREE.Matrix3();
      this.update();
    };
    THREE.VertexNormalsHelper.prototype = Object.create(THREE.Line.prototype);
    THREE.VertexNormalsHelper.prototype.constructor = THREE.VertexNormalsHelper;
    THREE.VertexNormalsHelper.prototype.update = (function(object) {
      var v1 = new THREE.Vector3();
      return function(object) {
        var keys = ['a', 'b', 'c', 'd'];
        this.object.updateMatrixWorld(true);
        this.normalMatrix.getNormalMatrix(this.object.matrixWorld);
        var vertices = this.geometry.vertices;
        var verts = this.object.geometry.vertices;
        var faces = this.object.geometry.faces;
        var worldMatrix = this.object.matrixWorld;
        var idx = 0;
        for (var i = 0,
            l = faces.length; i < l; i++) {
          var face = faces[i];
          for (var j = 0,
              jl = face.vertexNormals.length; j < jl; j++) {
            var vertexId = face[keys[j]];
            var vertex = verts[vertexId];
            var normal = face.vertexNormals[j];
            vertices[idx].copy(vertex).applyMatrix4(worldMatrix);
            v1.copy(normal).applyMatrix3(this.normalMatrix).normalize().multiplyScalar(this.size);
            v1.add(vertices[idx]);
            idx = idx + 1;
            vertices[idx].copy(v1);
            idx = idx + 1;
          }
        }
        this.geometry.verticesNeedUpdate = true;
        return this;
      };
    }());
    THREE.VertexTangentsHelper = function(object, size, hex, linewidth) {
      this.object = object;
      this.size = (size !== undefined) ? size : 1;
      var color = (hex !== undefined) ? hex : 0x0000ff;
      var width = (linewidth !== undefined) ? linewidth : 1;
      var geometry = new THREE.Geometry();
      var faces = object.geometry.faces;
      for (var i = 0,
          l = faces.length; i < l; i++) {
        var face = faces[i];
        for (var j = 0,
            jl = face.vertexTangents.length; j < jl; j++) {
          geometry.vertices.push(new THREE.Vector3());
          geometry.vertices.push(new THREE.Vector3());
        }
      }
      THREE.Line.call(this, geometry, new THREE.LineBasicMaterial({
        color: color,
        linewidth: width
      }), THREE.LinePieces);
      this.matrixAutoUpdate = false;
      this.update();
    };
    THREE.VertexTangentsHelper.prototype = Object.create(THREE.Line.prototype);
    THREE.VertexTangentsHelper.prototype.constructor = THREE.VertexTangentsHelper;
    THREE.VertexTangentsHelper.prototype.update = (function(object) {
      var v1 = new THREE.Vector3();
      return function(object) {
        var keys = ['a', 'b', 'c', 'd'];
        this.object.updateMatrixWorld(true);
        var vertices = this.geometry.vertices;
        var verts = this.object.geometry.vertices;
        var faces = this.object.geometry.faces;
        var worldMatrix = this.object.matrixWorld;
        var idx = 0;
        for (var i = 0,
            l = faces.length; i < l; i++) {
          var face = faces[i];
          for (var j = 0,
              jl = face.vertexTangents.length; j < jl; j++) {
            var vertexId = face[keys[j]];
            var vertex = verts[vertexId];
            var tangent = face.vertexTangents[j];
            vertices[idx].copy(vertex).applyMatrix4(worldMatrix);
            v1.copy(tangent).transformDirection(worldMatrix).multiplyScalar(this.size);
            v1.add(vertices[idx]);
            idx = idx + 1;
            vertices[idx].copy(v1);
            idx = idx + 1;
          }
        }
        this.geometry.verticesNeedUpdate = true;
        return this;
      };
    }());
    THREE.WireframeHelper = function(object, hex) {
      var color = (hex !== undefined) ? hex : 0xffffff;
      var edge = [0, 0],
          hash = {};
      var sortFunction = function(a, b) {
        return a - b;
      };
      var keys = ['a', 'b', 'c'];
      var geometry = new THREE.BufferGeometry();
      if (object.geometry instanceof THREE.Geometry) {
        var vertices = object.geometry.vertices;
        var faces = object.geometry.faces;
        var numEdges = 0;
        var edges = new Uint32Array(6 * faces.length);
        for (var i = 0,
            l = faces.length; i < l; i++) {
          var face = faces[i];
          for (var j = 0; j < 3; j++) {
            edge[0] = face[keys[j]];
            edge[1] = face[keys[(j + 1) % 3]];
            edge.sort(sortFunction);
            var key = edge.toString();
            if (hash[key] === undefined) {
              edges[2 * numEdges] = edge[0];
              edges[2 * numEdges + 1] = edge[1];
              hash[key] = true;
              numEdges++;
            }
          }
        }
        var coords = new Float32Array(numEdges * 2 * 3);
        for (var i = 0,
            l = numEdges; i < l; i++) {
          for (var j = 0; j < 2; j++) {
            var vertex = vertices[edges[2 * i + j]];
            var index = 6 * i + 3 * j;
            coords[index + 0] = vertex.x;
            coords[index + 1] = vertex.y;
            coords[index + 2] = vertex.z;
          }
        }
        geometry.addAttribute('position', new THREE.BufferAttribute(coords, 3));
      } else if (object.geometry instanceof THREE.BufferGeometry) {
        if (object.geometry.attributes.index !== undefined) {
          var vertices = object.geometry.attributes.position.array;
          var indices = object.geometry.attributes.index.array;
          var drawcalls = object.geometry.drawcalls;
          var numEdges = 0;
          if (drawcalls.length === 0) {
            drawcalls = [{
              count: indices.length,
              index: 0,
              start: 0
            }];
          }
          var edges = new Uint32Array(2 * indices.length);
          for (var o = 0,
              ol = drawcalls.length; o < ol; ++o) {
            var start = drawcalls[o].start;
            var count = drawcalls[o].count;
            var index = drawcalls[o].index;
            for (var i = start,
                il = start + count; i < il; i += 3) {
              for (var j = 0; j < 3; j++) {
                edge[0] = index + indices[i + j];
                edge[1] = index + indices[i + (j + 1) % 3];
                edge.sort(sortFunction);
                var key = edge.toString();
                if (hash[key] === undefined) {
                  edges[2 * numEdges] = edge[0];
                  edges[2 * numEdges + 1] = edge[1];
                  hash[key] = true;
                  numEdges++;
                }
              }
            }
          }
          var coords = new Float32Array(numEdges * 2 * 3);
          for (var i = 0,
              l = numEdges; i < l; i++) {
            for (var j = 0; j < 2; j++) {
              var index = 6 * i + 3 * j;
              var index2 = 3 * edges[2 * i + j];
              coords[index + 0] = vertices[index2];
              coords[index + 1] = vertices[index2 + 1];
              coords[index + 2] = vertices[index2 + 2];
            }
          }
          geometry.addAttribute('position', new THREE.BufferAttribute(coords, 3));
        } else {
          var vertices = object.geometry.attributes.position.array;
          var numEdges = vertices.length / 3;
          var numTris = numEdges / 3;
          var coords = new Float32Array(numEdges * 2 * 3);
          for (var i = 0,
              l = numTris; i < l; i++) {
            for (var j = 0; j < 3; j++) {
              var index = 18 * i + 6 * j;
              var index1 = 9 * i + 3 * j;
              coords[index + 0] = vertices[index1];
              coords[index + 1] = vertices[index1 + 1];
              coords[index + 2] = vertices[index1 + 2];
              var index2 = 9 * i + 3 * ((j + 1) % 3);
              coords[index + 3] = vertices[index2];
              coords[index + 4] = vertices[index2 + 1];
              coords[index + 5] = vertices[index2 + 2];
            }
          }
          geometry.addAttribute('position', new THREE.BufferAttribute(coords, 3));
        }
      }
      THREE.Line.call(this, geometry, new THREE.LineBasicMaterial({color: color}), THREE.LinePieces);
      this.matrix = object.matrixWorld;
      this.matrixAutoUpdate = false;
    };
    THREE.WireframeHelper.prototype = Object.create(THREE.Line.prototype);
    THREE.WireframeHelper.prototype.constructor = THREE.WireframeHelper;
    THREE.ImmediateRenderObject = function() {
      THREE.Object3D.call(this);
      this.render = function(renderCallback) {};
    };
    THREE.ImmediateRenderObject.prototype = Object.create(THREE.Object3D.prototype);
    THREE.ImmediateRenderObject.prototype.constructor = THREE.ImmediateRenderObject;
    THREE.MorphBlendMesh = function(geometry, material) {
      THREE.Mesh.call(this, geometry, material);
      this.animationsMap = {};
      this.animationsList = [];
      var numFrames = this.geometry.morphTargets.length;
      var name = "__default";
      var startFrame = 0;
      var endFrame = numFrames - 1;
      var fps = numFrames / 1;
      this.createAnimation(name, startFrame, endFrame, fps);
      this.setAnimationWeight(name, 1);
    };
    THREE.MorphBlendMesh.prototype = Object.create(THREE.Mesh.prototype);
    THREE.MorphBlendMesh.prototype.constructor = THREE.MorphBlendMesh;
    THREE.MorphBlendMesh.prototype.createAnimation = function(name, start, end, fps) {
      var animation = {
        startFrame: start,
        endFrame: end,
        length: end - start + 1,
        fps: fps,
        duration: (end - start) / fps,
        lastFrame: 0,
        currentFrame: 0,
        active: false,
        time: 0,
        direction: 1,
        weight: 1,
        directionBackwards: false,
        mirroredLoop: false
      };
      this.animationsMap[name] = animation;
      this.animationsList.push(animation);
    };
    THREE.MorphBlendMesh.prototype.autoCreateAnimations = function(fps) {
      var pattern = /([a-z]+)_?(\d+)/;
      var firstAnimation,
          frameRanges = {};
      var geometry = this.geometry;
      for (var i = 0,
          il = geometry.morphTargets.length; i < il; i++) {
        var morph = geometry.morphTargets[i];
        var chunks = morph.name.match(pattern);
        if (chunks && chunks.length > 1) {
          var name = chunks[1];
          if (!frameRanges[name])
            frameRanges[name] = {
              start: Infinity,
              end: -Infinity
            };
          var range = frameRanges[name];
          if (i < range.start)
            range.start = i;
          if (i > range.end)
            range.end = i;
          if (!firstAnimation)
            firstAnimation = name;
        }
      }
      for (var name in frameRanges) {
        var range = frameRanges[name];
        this.createAnimation(name, range.start, range.end, fps);
      }
      this.firstAnimation = firstAnimation;
    };
    THREE.MorphBlendMesh.prototype.setAnimationDirectionForward = function(name) {
      var animation = this.animationsMap[name];
      if (animation) {
        animation.direction = 1;
        animation.directionBackwards = false;
      }
    };
    THREE.MorphBlendMesh.prototype.setAnimationDirectionBackward = function(name) {
      var animation = this.animationsMap[name];
      if (animation) {
        animation.direction = -1;
        animation.directionBackwards = true;
      }
    };
    THREE.MorphBlendMesh.prototype.setAnimationFPS = function(name, fps) {
      var animation = this.animationsMap[name];
      if (animation) {
        animation.fps = fps;
        animation.duration = (animation.end - animation.start) / animation.fps;
      }
    };
    THREE.MorphBlendMesh.prototype.setAnimationDuration = function(name, duration) {
      var animation = this.animationsMap[name];
      if (animation) {
        animation.duration = duration;
        animation.fps = (animation.end - animation.start) / animation.duration;
      }
    };
    THREE.MorphBlendMesh.prototype.setAnimationWeight = function(name, weight) {
      var animation = this.animationsMap[name];
      if (animation) {
        animation.weight = weight;
      }
    };
    THREE.MorphBlendMesh.prototype.setAnimationTime = function(name, time) {
      var animation = this.animationsMap[name];
      if (animation) {
        animation.time = time;
      }
    };
    THREE.MorphBlendMesh.prototype.getAnimationTime = function(name) {
      var time = 0;
      var animation = this.animationsMap[name];
      if (animation) {
        time = animation.time;
      }
      return time;
    };
    THREE.MorphBlendMesh.prototype.getAnimationDuration = function(name) {
      var duration = -1;
      var animation = this.animationsMap[name];
      if (animation) {
        duration = animation.duration;
      }
      return duration;
    };
    THREE.MorphBlendMesh.prototype.playAnimation = function(name) {
      var animation = this.animationsMap[name];
      if (animation) {
        animation.time = 0;
        animation.active = true;
      } else {
        THREE.warn("THREE.MorphBlendMesh: animation[" + name + "] undefined in .playAnimation()");
      }
    };
    THREE.MorphBlendMesh.prototype.stopAnimation = function(name) {
      var animation = this.animationsMap[name];
      if (animation) {
        animation.active = false;
      }
    };
    THREE.MorphBlendMesh.prototype.update = function(delta) {
      for (var i = 0,
          il = this.animationsList.length; i < il; i++) {
        var animation = this.animationsList[i];
        if (!animation.active)
          continue;
        var frameTime = animation.duration / animation.length;
        animation.time += animation.direction * delta;
        if (animation.mirroredLoop) {
          if (animation.time > animation.duration || animation.time < 0) {
            animation.direction *= -1;
            if (animation.time > animation.duration) {
              animation.time = animation.duration;
              animation.directionBackwards = true;
            }
            if (animation.time < 0) {
              animation.time = 0;
              animation.directionBackwards = false;
            }
          }
        } else {
          animation.time = animation.time % animation.duration;
          if (animation.time < 0)
            animation.time += animation.duration;
        }
        var keyframe = animation.startFrame + THREE.Math.clamp(Math.floor(animation.time / frameTime), 0, animation.length - 1);
        var weight = animation.weight;
        if (keyframe !== animation.currentFrame) {
          this.morphTargetInfluences[animation.lastFrame] = 0;
          this.morphTargetInfluences[animation.currentFrame] = 1 * weight;
          this.morphTargetInfluences[keyframe] = 0;
          animation.lastFrame = animation.currentFrame;
          animation.currentFrame = keyframe;
        }
        var mix = (animation.time % frameTime) / frameTime;
        if (animation.directionBackwards)
          mix = 1 - mix;
        this.morphTargetInfluences[animation.currentFrame] = mix * weight;
        this.morphTargetInfluences[animation.lastFrame] = (1 - mix) * weight;
      }
    };
    this["THREE"] = THREE;
  }).call(System.global);
  return System.get("@@global-helpers").retrieveGlobal(__module.id, "THREE");
});

System.register("github:mrdoob/three.js@master/examples/js/controls/OrbitControls", [], false, function(__require, __exports, __module) {
  System.get("@@global-helpers").prepareGlobal(__module.id, []);
  (function() {
    THREE.OrbitControls = function(object, domElement) {
      this.object = object;
      this.domElement = (domElement !== undefined) ? domElement : document;
      this.enabled = true;
      this.target = new THREE.Vector3();
      this.center = this.target;
      this.noZoom = false;
      this.zoomSpeed = 1.0;
      this.minDistance = 0;
      this.maxDistance = Infinity;
      this.minZoom = 0;
      this.maxZoom = Infinity;
      this.noRotate = false;
      this.rotateSpeed = 1.0;
      this.noPan = false;
      this.keyPanSpeed = 7.0;
      this.autoRotate = false;
      this.autoRotateSpeed = 2.0;
      this.minPolarAngle = 0;
      this.maxPolarAngle = Math.PI;
      this.minAzimuthAngle = -Infinity;
      this.maxAzimuthAngle = Infinity;
      this.noKeys = false;
      this.keys = {
        LEFT: 37,
        UP: 38,
        RIGHT: 39,
        BOTTOM: 40
      };
      this.mouseButtons = {
        ORBIT: THREE.MOUSE.LEFT,
        ZOOM: THREE.MOUSE.MIDDLE,
        PAN: THREE.MOUSE.RIGHT
      };
      var scope = this;
      var EPS = 0.000001;
      var rotateStart = new THREE.Vector2();
      var rotateEnd = new THREE.Vector2();
      var rotateDelta = new THREE.Vector2();
      var panStart = new THREE.Vector2();
      var panEnd = new THREE.Vector2();
      var panDelta = new THREE.Vector2();
      var panOffset = new THREE.Vector3();
      var offset = new THREE.Vector3();
      var dollyStart = new THREE.Vector2();
      var dollyEnd = new THREE.Vector2();
      var dollyDelta = new THREE.Vector2();
      var theta;
      var phi;
      var phiDelta = 0;
      var thetaDelta = 0;
      var scale = 1;
      var pan = new THREE.Vector3();
      var lastPosition = new THREE.Vector3();
      var lastQuaternion = new THREE.Quaternion();
      var STATE = {
        NONE: -1,
        ROTATE: 0,
        DOLLY: 1,
        PAN: 2,
        TOUCH_ROTATE: 3,
        TOUCH_DOLLY: 4,
        TOUCH_PAN: 5
      };
      var state = STATE.NONE;
      this.target0 = this.target.clone();
      this.position0 = this.object.position.clone();
      this.zoom0 = this.object.zoom;
      var quat = new THREE.Quaternion().setFromUnitVectors(object.up, new THREE.Vector3(0, 1, 0));
      var quatInverse = quat.clone().inverse();
      var changeEvent = {type: 'change'};
      var startEvent = {type: 'start'};
      var endEvent = {type: 'end'};
      this.rotateLeft = function(angle) {
        if (angle === undefined) {
          angle = getAutoRotationAngle();
        }
        thetaDelta -= angle;
      };
      this.rotateUp = function(angle) {
        if (angle === undefined) {
          angle = getAutoRotationAngle();
        }
        phiDelta -= angle;
      };
      this.panLeft = function(distance) {
        var te = this.object.matrix.elements;
        panOffset.set(te[0], te[1], te[2]);
        panOffset.multiplyScalar(-distance);
        pan.add(panOffset);
      };
      this.panUp = function(distance) {
        var te = this.object.matrix.elements;
        panOffset.set(te[4], te[5], te[6]);
        panOffset.multiplyScalar(distance);
        pan.add(panOffset);
      };
      this.pan = function(deltaX, deltaY) {
        var element = scope.domElement === document ? scope.domElement.body : scope.domElement;
        if (scope.object instanceof THREE.PerspectiveCamera) {
          var position = scope.object.position;
          var offset = position.clone().sub(scope.target);
          var targetDistance = offset.length();
          targetDistance *= Math.tan((scope.object.fov / 2) * Math.PI / 180.0);
          scope.panLeft(2 * deltaX * targetDistance / element.clientHeight);
          scope.panUp(2 * deltaY * targetDistance / element.clientHeight);
        } else if (scope.object instanceof THREE.OrthographicCamera) {
          scope.panLeft(deltaX * (scope.object.right - scope.object.left) / element.clientWidth);
          scope.panUp(deltaY * (scope.object.top - scope.object.bottom) / element.clientHeight);
        } else {
          console.warn('WARNING: OrbitControls.js encountered an unknown camera type - pan disabled.');
        }
      };
      this.dollyIn = function(dollyScale) {
        if (dollyScale === undefined) {
          dollyScale = getZoomScale();
        }
        if (scope.object instanceof THREE.PerspectiveCamera) {
          scale /= dollyScale;
        } else if (scope.object instanceof THREE.OrthographicCamera) {
          scope.object.zoom = Math.max(this.minZoom, Math.min(this.maxZoom, this.object.zoom * dollyScale));
          scope.object.updateProjectionMatrix();
          scope.dispatchEvent(changeEvent);
        } else {
          console.warn('WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled.');
        }
      };
      this.dollyOut = function(dollyScale) {
        if (dollyScale === undefined) {
          dollyScale = getZoomScale();
        }
        if (scope.object instanceof THREE.PerspectiveCamera) {
          scale *= dollyScale;
        } else if (scope.object instanceof THREE.OrthographicCamera) {
          scope.object.zoom = Math.max(this.minZoom, Math.min(this.maxZoom, this.object.zoom / dollyScale));
          scope.object.updateProjectionMatrix();
          scope.dispatchEvent(changeEvent);
        } else {
          console.warn('WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled.');
        }
      };
      this.update = function() {
        var position = this.object.position;
        offset.copy(position).sub(this.target);
        offset.applyQuaternion(quat);
        theta = Math.atan2(offset.x, offset.z);
        phi = Math.atan2(Math.sqrt(offset.x * offset.x + offset.z * offset.z), offset.y);
        if (this.autoRotate && state === STATE.NONE) {
          this.rotateLeft(getAutoRotationAngle());
        }
        theta += thetaDelta;
        phi += phiDelta;
        theta = Math.max(this.minAzimuthAngle, Math.min(this.maxAzimuthAngle, theta));
        phi = Math.max(this.minPolarAngle, Math.min(this.maxPolarAngle, phi));
        phi = Math.max(EPS, Math.min(Math.PI - EPS, phi));
        var radius = offset.length() * scale;
        radius = Math.max(this.minDistance, Math.min(this.maxDistance, radius));
        this.target.add(pan);
        offset.x = radius * Math.sin(phi) * Math.sin(theta);
        offset.y = radius * Math.cos(phi);
        offset.z = radius * Math.sin(phi) * Math.cos(theta);
        offset.applyQuaternion(quatInverse);
        position.copy(this.target).add(offset);
        this.object.lookAt(this.target);
        thetaDelta = 0;
        phiDelta = 0;
        scale = 1;
        pan.set(0, 0, 0);
        if (lastPosition.distanceToSquared(this.object.position) > EPS || 8 * (1 - lastQuaternion.dot(this.object.quaternion)) > EPS) {
          this.dispatchEvent(changeEvent);
          lastPosition.copy(this.object.position);
          lastQuaternion.copy(this.object.quaternion);
        }
      };
      this.reset = function() {
        state = STATE.NONE;
        this.target.copy(this.target0);
        this.object.position.copy(this.position0);
        this.object.zoom = this.zoom0;
        this.object.updateProjectionMatrix();
        this.dispatchEvent(changeEvent);
        this.update();
      };
      this.getPolarAngle = function() {
        return phi;
      };
      this.getAzimuthalAngle = function() {
        return theta;
      };
      function getAutoRotationAngle() {
        return 2 * Math.PI / 60 / 60 * scope.autoRotateSpeed;
      }
      function getZoomScale() {
        return Math.pow(0.95, scope.zoomSpeed);
      }
      function onMouseDown(event) {
        if (scope.enabled === false)
          return ;
        event.preventDefault();
        if (event.button === scope.mouseButtons.ORBIT) {
          if (scope.noRotate === true)
            return ;
          state = STATE.ROTATE;
          rotateStart.set(event.clientX, event.clientY);
        } else if (event.button === scope.mouseButtons.ZOOM) {
          if (scope.noZoom === true)
            return ;
          state = STATE.DOLLY;
          dollyStart.set(event.clientX, event.clientY);
        } else if (event.button === scope.mouseButtons.PAN) {
          if (scope.noPan === true)
            return ;
          state = STATE.PAN;
          panStart.set(event.clientX, event.clientY);
        }
        if (state !== STATE.NONE) {
          document.addEventListener('mousemove', onMouseMove, false);
          document.addEventListener('mouseup', onMouseUp, false);
          scope.dispatchEvent(startEvent);
        }
      }
      function onMouseMove(event) {
        if (scope.enabled === false)
          return ;
        event.preventDefault();
        var element = scope.domElement === document ? scope.domElement.body : scope.domElement;
        if (state === STATE.ROTATE) {
          if (scope.noRotate === true)
            return ;
          rotateEnd.set(event.clientX, event.clientY);
          rotateDelta.subVectors(rotateEnd, rotateStart);
          scope.rotateLeft(2 * Math.PI * rotateDelta.x / element.clientWidth * scope.rotateSpeed);
          scope.rotateUp(2 * Math.PI * rotateDelta.y / element.clientHeight * scope.rotateSpeed);
          rotateStart.copy(rotateEnd);
        } else if (state === STATE.DOLLY) {
          if (scope.noZoom === true)
            return ;
          dollyEnd.set(event.clientX, event.clientY);
          dollyDelta.subVectors(dollyEnd, dollyStart);
          if (dollyDelta.y > 0) {
            scope.dollyIn();
          } else if (dollyDelta.y < 0) {
            scope.dollyOut();
          }
          dollyStart.copy(dollyEnd);
        } else if (state === STATE.PAN) {
          if (scope.noPan === true)
            return ;
          panEnd.set(event.clientX, event.clientY);
          panDelta.subVectors(panEnd, panStart);
          scope.pan(panDelta.x, panDelta.y);
          panStart.copy(panEnd);
        }
        if (state !== STATE.NONE)
          scope.update();
      }
      function onMouseUp() {
        if (scope.enabled === false)
          return ;
        document.removeEventListener('mousemove', onMouseMove, false);
        document.removeEventListener('mouseup', onMouseUp, false);
        scope.dispatchEvent(endEvent);
        state = STATE.NONE;
      }
      function onMouseWheel(event) {
        if (scope.enabled === false || scope.noZoom === true || state !== STATE.NONE)
          return ;
        event.preventDefault();
        event.stopPropagation();
        var delta = 0;
        if (event.wheelDelta !== undefined) {
          delta = event.wheelDelta;
        } else if (event.detail !== undefined) {
          delta = -event.detail;
        }
        if (delta > 0) {
          scope.dollyOut();
        } else if (delta < 0) {
          scope.dollyIn();
        }
        scope.update();
        scope.dispatchEvent(startEvent);
        scope.dispatchEvent(endEvent);
      }
      function onKeyDown(event) {
        if (scope.enabled === false || scope.noKeys === true || scope.noPan === true)
          return ;
        switch (event.keyCode) {
          case scope.keys.UP:
            scope.pan(0, scope.keyPanSpeed);
            scope.update();
            break;
          case scope.keys.BOTTOM:
            scope.pan(0, -scope.keyPanSpeed);
            scope.update();
            break;
          case scope.keys.LEFT:
            scope.pan(scope.keyPanSpeed, 0);
            scope.update();
            break;
          case scope.keys.RIGHT:
            scope.pan(-scope.keyPanSpeed, 0);
            scope.update();
            break;
        }
      }
      function touchstart(event) {
        if (scope.enabled === false)
          return ;
        switch (event.touches.length) {
          case 1:
            if (scope.noRotate === true)
              return ;
            state = STATE.TOUCH_ROTATE;
            rotateStart.set(event.touches[0].pageX, event.touches[0].pageY);
            break;
          case 2:
            if (scope.noZoom === true)
              return ;
            state = STATE.TOUCH_DOLLY;
            var dx = event.touches[0].pageX - event.touches[1].pageX;
            var dy = event.touches[0].pageY - event.touches[1].pageY;
            var distance = Math.sqrt(dx * dx + dy * dy);
            dollyStart.set(0, distance);
            break;
          case 3:
            if (scope.noPan === true)
              return ;
            state = STATE.TOUCH_PAN;
            panStart.set(event.touches[0].pageX, event.touches[0].pageY);
            break;
          default:
            state = STATE.NONE;
        }
        if (state !== STATE.NONE)
          scope.dispatchEvent(startEvent);
      }
      function touchmove(event) {
        if (scope.enabled === false)
          return ;
        event.preventDefault();
        event.stopPropagation();
        var element = scope.domElement === document ? scope.domElement.body : scope.domElement;
        switch (event.touches.length) {
          case 1:
            if (scope.noRotate === true)
              return ;
            if (state !== STATE.TOUCH_ROTATE)
              return ;
            rotateEnd.set(event.touches[0].pageX, event.touches[0].pageY);
            rotateDelta.subVectors(rotateEnd, rotateStart);
            scope.rotateLeft(2 * Math.PI * rotateDelta.x / element.clientWidth * scope.rotateSpeed);
            scope.rotateUp(2 * Math.PI * rotateDelta.y / element.clientHeight * scope.rotateSpeed);
            rotateStart.copy(rotateEnd);
            scope.update();
            break;
          case 2:
            if (scope.noZoom === true)
              return ;
            if (state !== STATE.TOUCH_DOLLY)
              return ;
            var dx = event.touches[0].pageX - event.touches[1].pageX;
            var dy = event.touches[0].pageY - event.touches[1].pageY;
            var distance = Math.sqrt(dx * dx + dy * dy);
            dollyEnd.set(0, distance);
            dollyDelta.subVectors(dollyEnd, dollyStart);
            if (dollyDelta.y > 0) {
              scope.dollyOut();
            } else if (dollyDelta.y < 0) {
              scope.dollyIn();
            }
            dollyStart.copy(dollyEnd);
            scope.update();
            break;
          case 3:
            if (scope.noPan === true)
              return ;
            if (state !== STATE.TOUCH_PAN)
              return ;
            panEnd.set(event.touches[0].pageX, event.touches[0].pageY);
            panDelta.subVectors(panEnd, panStart);
            scope.pan(panDelta.x, panDelta.y);
            panStart.copy(panEnd);
            scope.update();
            break;
          default:
            state = STATE.NONE;
        }
      }
      function touchend() {
        if (scope.enabled === false)
          return ;
        scope.dispatchEvent(endEvent);
        state = STATE.NONE;
      }
      this.domElement.addEventListener('contextmenu', function(event) {
        event.preventDefault();
      }, false);
      this.domElement.addEventListener('mousedown', onMouseDown, false);
      this.domElement.addEventListener('mousewheel', onMouseWheel, false);
      this.domElement.addEventListener('DOMMouseScroll', onMouseWheel, false);
      this.domElement.addEventListener('touchstart', touchstart, false);
      this.domElement.addEventListener('touchend', touchend, false);
      this.domElement.addEventListener('touchmove', touchmove, false);
      window.addEventListener('keydown', onKeyDown, false);
      this.update();
    };
    THREE.OrbitControls.prototype = Object.create(THREE.EventDispatcher.prototype);
    THREE.OrbitControls.prototype.constructor = THREE.OrbitControls;
  }).call(System.global);
  return System.get("@@global-helpers").retrieveGlobal(__module.id, false);
});

System.register("arbeit/particleset", [], function($__export) {
  "use strict";
  var $__1;
  var __moduleName = "arbeit/particleset";
  var ParticleSet,
      Particle;
  return ($__1 = {}, Object.defineProperty($__1, "setters", {
    value: [],
    configurable: true,
    enumerable: true,
    writable: true
  }), Object.defineProperty($__1, "execute", {
    value: function() {
      ParticleSet = $__export("ParticleSet", (function() {
        var $__1;
        var ParticleSet = function ParticleSet(size) {
          this.data = {};
          this.data.positions = new Float64Array(size * 3);
          this.data.velocities = new Float64Array(size * 3);
          this.data.accelerations = new Float64Array(size * 3);
          this.data.masses = new Float64Array(size);
          this.proxies = new Array(size);
          for (var i = 0; i < size; i++) {
            this.proxies[i] = new Particle(i, this.data);
          }
        };
        return ($traceurRuntime.createClass)(ParticleSet, ($__1 = {}, Object.defineProperty($__1, Symbol.iterator, {
          value: function() {
            var cur = 0,
                value;
            var proxies = this.proxies;
            return {next: function() {
                var $__2,
                    $__3,
                    $__4;
                if (cur < proxies.length) {
                  ($__2 = [proxies[cur], cur + 1], value = ($__3 = $__2[$traceurRuntime.toProperty(Symbol.iterator)](), ($__4 = $__3.next()).done ? void 0 : $__4.value), cur = ($__4 = $__3.next()).done ? void 0 : $__4.value, $__2);
                  return {
                    value: value,
                    done: false
                  };
                } else {
                  return {done: true};
                }
              }};
          },
          configurable: true,
          enumerable: true,
          writable: true
        }), Object.defineProperty($__1, "length", {
          get: function() {
            return this.proxies.length;
          },
          configurable: true,
          enumerable: true
        }), Object.defineProperty($__1, "at", {
          value: function(i) {
            return this.proxies[i];
          },
          configurable: true,
          enumerable: true,
          writable: true
        }), $__1), {});
      }()));
      Particle = (function() {
        var Particle = function Particle(i, data) {
          this.index = i;
          this.positionView = new Float64Array(data.positions.buffer, i * 24, 3);
          this.velocityView = new Float64Array(data.velocities.buffer, i * 24, 3);
          this.accelerationView = new Float64Array(data.accelerations.buffer, i * 24, 3);
          this.massView = new Float64Array(data.masses.buffer, i * 8, 1);
        };
        return ($traceurRuntime.createClass)(Particle, {
          get position() {
            return this.positionView;
          },
          get velocity() {
            return this.velocityView;
          },
          get acceleration() {
            return this.accelerationView;
          },
          get mass() {
            return this.massView[0];
          },
          set mass(value) {
            return this.massView[0] = value;
          },
          debug: function() {
            console.group('Particle %d', this.index);
            console.log("Position { %d, %d, %d }", this.position[0], this.position[1], this.position[2]);
            console.log("Velocity { %d, %d, %d }", this.velocity[0], this.velocity[1], this.velocity[2]);
            console.log("Mass { %d }", this.mass);
            console.groupEnd();
          }
        }, {});
      }());
    },
    configurable: true,
    enumerable: true,
    writable: true
  }), $__1);
});

System.register("arbeit/proxy", [], function($__export) {
  "use strict";
  var __moduleName = "arbeit/proxy";
  var Proxy;
  return {
    setters: [],
    execute: function() {
      Proxy = $__export("Proxy", (function() {
        var Proxy = function Proxy(script) {
          this.script = script;
          this.worker = null;
        };
        return ($traceurRuntime.createClass)(Proxy, {
          run: function() {
            if (!this.script) {
              this.worker = self;
              return Promise.resolve(self);
            }
            if (!this.worker) {
              return new Promise(function(resolve, reject) {
                var forked = new Worker(this.script);
                forked.addEventListener('message', function(event) {
                  forked.removeEventListener('message', this);
                  resolve(forked);
                }, false);
              }.bind(this)).then(function(forked) {
                this.worker = forked;
                return forked;
              }.bind(this));
            } else {
              return Promise.resolve(this.worker);
            }
          },
          send: function(data, shared) {
            return this.run().then(function(worker) {
              worker.postMessage(data, shared);
            });
          }
        }, {});
      }()));
    }
  };
});

System.register("npm:gl-matrix@2.2.1/dist/gl-matrix", [], false, function(__require, __exports, __module) {
  System.get("@@global-helpers").prepareGlobal(__module.id, []);
  (function() {
    "format cjs";
    (function(_global) {
      "use strict";
      var shim = {};
      if (typeof(exports) === 'undefined') {
        if (typeof define == 'function' && typeof define.amd == 'object' && define.amd) {
          shim.exports = {};
          define(function() {
            return shim.exports;
          });
        } else {
          shim.exports = typeof(window) !== 'undefined' ? window : _global;
        }
      } else {
        shim.exports = exports;
      }
      (function(exports) {
        if (!GLMAT_EPSILON) {
          var GLMAT_EPSILON = 0.000001;
        }
        if (!GLMAT_ARRAY_TYPE) {
          var GLMAT_ARRAY_TYPE = (typeof Float32Array !== 'undefined') ? Float32Array : Array;
        }
        if (!GLMAT_RANDOM) {
          var GLMAT_RANDOM = Math.random;
        }
        var glMatrix = {};
        glMatrix.setMatrixArrayType = function(type) {
          GLMAT_ARRAY_TYPE = type;
        };
        if (typeof(exports) !== 'undefined') {
          exports.glMatrix = glMatrix;
        }
        var degree = Math.PI / 180;
        glMatrix.toRadian = function(a) {
          return a * degree;
        };
        ;
        var vec2 = {};
        vec2.create = function() {
          var out = new GLMAT_ARRAY_TYPE(2);
          out[0] = 0;
          out[1] = 0;
          return out;
        };
        vec2.clone = function(a) {
          var out = new GLMAT_ARRAY_TYPE(2);
          out[0] = a[0];
          out[1] = a[1];
          return out;
        };
        vec2.fromValues = function(x, y) {
          var out = new GLMAT_ARRAY_TYPE(2);
          out[0] = x;
          out[1] = y;
          return out;
        };
        vec2.copy = function(out, a) {
          out[0] = a[0];
          out[1] = a[1];
          return out;
        };
        vec2.set = function(out, x, y) {
          out[0] = x;
          out[1] = y;
          return out;
        };
        vec2.add = function(out, a, b) {
          out[0] = a[0] + b[0];
          out[1] = a[1] + b[1];
          return out;
        };
        vec2.subtract = function(out, a, b) {
          out[0] = a[0] - b[0];
          out[1] = a[1] - b[1];
          return out;
        };
        vec2.sub = vec2.subtract;
        vec2.multiply = function(out, a, b) {
          out[0] = a[0] * b[0];
          out[1] = a[1] * b[1];
          return out;
        };
        vec2.mul = vec2.multiply;
        vec2.divide = function(out, a, b) {
          out[0] = a[0] / b[0];
          out[1] = a[1] / b[1];
          return out;
        };
        vec2.div = vec2.divide;
        vec2.min = function(out, a, b) {
          out[0] = Math.min(a[0], b[0]);
          out[1] = Math.min(a[1], b[1]);
          return out;
        };
        vec2.max = function(out, a, b) {
          out[0] = Math.max(a[0], b[0]);
          out[1] = Math.max(a[1], b[1]);
          return out;
        };
        vec2.scale = function(out, a, b) {
          out[0] = a[0] * b;
          out[1] = a[1] * b;
          return out;
        };
        vec2.scaleAndAdd = function(out, a, b, scale) {
          out[0] = a[0] + (b[0] * scale);
          out[1] = a[1] + (b[1] * scale);
          return out;
        };
        vec2.distance = function(a, b) {
          var x = b[0] - a[0],
              y = b[1] - a[1];
          return Math.sqrt(x * x + y * y);
        };
        vec2.dist = vec2.distance;
        vec2.squaredDistance = function(a, b) {
          var x = b[0] - a[0],
              y = b[1] - a[1];
          return x * x + y * y;
        };
        vec2.sqrDist = vec2.squaredDistance;
        vec2.length = function(a) {
          var x = a[0],
              y = a[1];
          return Math.sqrt(x * x + y * y);
        };
        vec2.len = vec2.length;
        vec2.squaredLength = function(a) {
          var x = a[0],
              y = a[1];
          return x * x + y * y;
        };
        vec2.sqrLen = vec2.squaredLength;
        vec2.negate = function(out, a) {
          out[0] = -a[0];
          out[1] = -a[1];
          return out;
        };
        vec2.normalize = function(out, a) {
          var x = a[0],
              y = a[1];
          var len = x * x + y * y;
          if (len > 0) {
            len = 1 / Math.sqrt(len);
            out[0] = a[0] * len;
            out[1] = a[1] * len;
          }
          return out;
        };
        vec2.dot = function(a, b) {
          return a[0] * b[0] + a[1] * b[1];
        };
        vec2.cross = function(out, a, b) {
          var z = a[0] * b[1] - a[1] * b[0];
          out[0] = out[1] = 0;
          out[2] = z;
          return out;
        };
        vec2.lerp = function(out, a, b, t) {
          var ax = a[0],
              ay = a[1];
          out[0] = ax + t * (b[0] - ax);
          out[1] = ay + t * (b[1] - ay);
          return out;
        };
        vec2.random = function(out, scale) {
          scale = scale || 1.0;
          var r = GLMAT_RANDOM() * 2.0 * Math.PI;
          out[0] = Math.cos(r) * scale;
          out[1] = Math.sin(r) * scale;
          return out;
        };
        vec2.transformMat2 = function(out, a, m) {
          var x = a[0],
              y = a[1];
          out[0] = m[0] * x + m[2] * y;
          out[1] = m[1] * x + m[3] * y;
          return out;
        };
        vec2.transformMat2d = function(out, a, m) {
          var x = a[0],
              y = a[1];
          out[0] = m[0] * x + m[2] * y + m[4];
          out[1] = m[1] * x + m[3] * y + m[5];
          return out;
        };
        vec2.transformMat3 = function(out, a, m) {
          var x = a[0],
              y = a[1];
          out[0] = m[0] * x + m[3] * y + m[6];
          out[1] = m[1] * x + m[4] * y + m[7];
          return out;
        };
        vec2.transformMat4 = function(out, a, m) {
          var x = a[0],
              y = a[1];
          out[0] = m[0] * x + m[4] * y + m[12];
          out[1] = m[1] * x + m[5] * y + m[13];
          return out;
        };
        vec2.forEach = (function() {
          var vec = vec2.create();
          return function(a, stride, offset, count, fn, arg) {
            var i,
                l;
            if (!stride) {
              stride = 2;
            }
            if (!offset) {
              offset = 0;
            }
            if (count) {
              l = Math.min((count * stride) + offset, a.length);
            } else {
              l = a.length;
            }
            for (i = offset; i < l; i += stride) {
              vec[0] = a[i];
              vec[1] = a[i + 1];
              fn(vec, vec, arg);
              a[i] = vec[0];
              a[i + 1] = vec[1];
            }
            return a;
          };
        })();
        vec2.str = function(a) {
          return 'vec2(' + a[0] + ', ' + a[1] + ')';
        };
        if (typeof(exports) !== 'undefined') {
          exports.vec2 = vec2;
        }
        ;
        var vec3 = {};
        vec3.create = function() {
          var out = new GLMAT_ARRAY_TYPE(3);
          out[0] = 0;
          out[1] = 0;
          out[2] = 0;
          return out;
        };
        vec3.clone = function(a) {
          var out = new GLMAT_ARRAY_TYPE(3);
          out[0] = a[0];
          out[1] = a[1];
          out[2] = a[2];
          return out;
        };
        vec3.fromValues = function(x, y, z) {
          var out = new GLMAT_ARRAY_TYPE(3);
          out[0] = x;
          out[1] = y;
          out[2] = z;
          return out;
        };
        vec3.copy = function(out, a) {
          out[0] = a[0];
          out[1] = a[1];
          out[2] = a[2];
          return out;
        };
        vec3.set = function(out, x, y, z) {
          out[0] = x;
          out[1] = y;
          out[2] = z;
          return out;
        };
        vec3.add = function(out, a, b) {
          out[0] = a[0] + b[0];
          out[1] = a[1] + b[1];
          out[2] = a[2] + b[2];
          return out;
        };
        vec3.subtract = function(out, a, b) {
          out[0] = a[0] - b[0];
          out[1] = a[1] - b[1];
          out[2] = a[2] - b[2];
          return out;
        };
        vec3.sub = vec3.subtract;
        vec3.multiply = function(out, a, b) {
          out[0] = a[0] * b[0];
          out[1] = a[1] * b[1];
          out[2] = a[2] * b[2];
          return out;
        };
        vec3.mul = vec3.multiply;
        vec3.divide = function(out, a, b) {
          out[0] = a[0] / b[0];
          out[1] = a[1] / b[1];
          out[2] = a[2] / b[2];
          return out;
        };
        vec3.div = vec3.divide;
        vec3.min = function(out, a, b) {
          out[0] = Math.min(a[0], b[0]);
          out[1] = Math.min(a[1], b[1]);
          out[2] = Math.min(a[2], b[2]);
          return out;
        };
        vec3.max = function(out, a, b) {
          out[0] = Math.max(a[0], b[0]);
          out[1] = Math.max(a[1], b[1]);
          out[2] = Math.max(a[2], b[2]);
          return out;
        };
        vec3.scale = function(out, a, b) {
          out[0] = a[0] * b;
          out[1] = a[1] * b;
          out[2] = a[2] * b;
          return out;
        };
        vec3.scaleAndAdd = function(out, a, b, scale) {
          out[0] = a[0] + (b[0] * scale);
          out[1] = a[1] + (b[1] * scale);
          out[2] = a[2] + (b[2] * scale);
          return out;
        };
        vec3.distance = function(a, b) {
          var x = b[0] - a[0],
              y = b[1] - a[1],
              z = b[2] - a[2];
          return Math.sqrt(x * x + y * y + z * z);
        };
        vec3.dist = vec3.distance;
        vec3.squaredDistance = function(a, b) {
          var x = b[0] - a[0],
              y = b[1] - a[1],
              z = b[2] - a[2];
          return x * x + y * y + z * z;
        };
        vec3.sqrDist = vec3.squaredDistance;
        vec3.length = function(a) {
          var x = a[0],
              y = a[1],
              z = a[2];
          return Math.sqrt(x * x + y * y + z * z);
        };
        vec3.len = vec3.length;
        vec3.squaredLength = function(a) {
          var x = a[0],
              y = a[1],
              z = a[2];
          return x * x + y * y + z * z;
        };
        vec3.sqrLen = vec3.squaredLength;
        vec3.negate = function(out, a) {
          out[0] = -a[0];
          out[1] = -a[1];
          out[2] = -a[2];
          return out;
        };
        vec3.normalize = function(out, a) {
          var x = a[0],
              y = a[1],
              z = a[2];
          var len = x * x + y * y + z * z;
          if (len > 0) {
            len = 1 / Math.sqrt(len);
            out[0] = a[0] * len;
            out[1] = a[1] * len;
            out[2] = a[2] * len;
          }
          return out;
        };
        vec3.dot = function(a, b) {
          return a[0] * b[0] + a[1] * b[1] + a[2] * b[2];
        };
        vec3.cross = function(out, a, b) {
          var ax = a[0],
              ay = a[1],
              az = a[2],
              bx = b[0],
              by = b[1],
              bz = b[2];
          out[0] = ay * bz - az * by;
          out[1] = az * bx - ax * bz;
          out[2] = ax * by - ay * bx;
          return out;
        };
        vec3.lerp = function(out, a, b, t) {
          var ax = a[0],
              ay = a[1],
              az = a[2];
          out[0] = ax + t * (b[0] - ax);
          out[1] = ay + t * (b[1] - ay);
          out[2] = az + t * (b[2] - az);
          return out;
        };
        vec3.random = function(out, scale) {
          scale = scale || 1.0;
          var r = GLMAT_RANDOM() * 2.0 * Math.PI;
          var z = (GLMAT_RANDOM() * 2.0) - 1.0;
          var zScale = Math.sqrt(1.0 - z * z) * scale;
          out[0] = Math.cos(r) * zScale;
          out[1] = Math.sin(r) * zScale;
          out[2] = z * scale;
          return out;
        };
        vec3.transformMat4 = function(out, a, m) {
          var x = a[0],
              y = a[1],
              z = a[2];
          out[0] = m[0] * x + m[4] * y + m[8] * z + m[12];
          out[1] = m[1] * x + m[5] * y + m[9] * z + m[13];
          out[2] = m[2] * x + m[6] * y + m[10] * z + m[14];
          return out;
        };
        vec3.transformMat3 = function(out, a, m) {
          var x = a[0],
              y = a[1],
              z = a[2];
          out[0] = x * m[0] + y * m[3] + z * m[6];
          out[1] = x * m[1] + y * m[4] + z * m[7];
          out[2] = x * m[2] + y * m[5] + z * m[8];
          return out;
        };
        vec3.transformQuat = function(out, a, q) {
          var x = a[0],
              y = a[1],
              z = a[2],
              qx = q[0],
              qy = q[1],
              qz = q[2],
              qw = q[3],
              ix = qw * x + qy * z - qz * y,
              iy = qw * y + qz * x - qx * z,
              iz = qw * z + qx * y - qy * x,
              iw = -qx * x - qy * y - qz * z;
          out[0] = ix * qw + iw * -qx + iy * -qz - iz * -qy;
          out[1] = iy * qw + iw * -qy + iz * -qx - ix * -qz;
          out[2] = iz * qw + iw * -qz + ix * -qy - iy * -qx;
          return out;
        };
        vec3.rotateX = function(out, a, b, c) {
          var p = [],
              r = [];
          p[0] = a[0] - b[0];
          p[1] = a[1] - b[1];
          p[2] = a[2] - b[2];
          r[0] = p[0];
          r[1] = p[1] * Math.cos(c) - p[2] * Math.sin(c);
          r[2] = p[1] * Math.sin(c) + p[2] * Math.cos(c);
          out[0] = r[0] + b[0];
          out[1] = r[1] + b[1];
          out[2] = r[2] + b[2];
          return out;
        };
        vec3.rotateY = function(out, a, b, c) {
          var p = [],
              r = [];
          p[0] = a[0] - b[0];
          p[1] = a[1] - b[1];
          p[2] = a[2] - b[2];
          r[0] = p[2] * Math.sin(c) + p[0] * Math.cos(c);
          r[1] = p[1];
          r[2] = p[2] * Math.cos(c) - p[0] * Math.sin(c);
          out[0] = r[0] + b[0];
          out[1] = r[1] + b[1];
          out[2] = r[2] + b[2];
          return out;
        };
        vec3.rotateZ = function(out, a, b, c) {
          var p = [],
              r = [];
          p[0] = a[0] - b[0];
          p[1] = a[1] - b[1];
          p[2] = a[2] - b[2];
          r[0] = p[0] * Math.cos(c) - p[1] * Math.sin(c);
          r[1] = p[0] * Math.sin(c) + p[1] * Math.cos(c);
          r[2] = p[2];
          out[0] = r[0] + b[0];
          out[1] = r[1] + b[1];
          out[2] = r[2] + b[2];
          return out;
        };
        vec3.forEach = (function() {
          var vec = vec3.create();
          return function(a, stride, offset, count, fn, arg) {
            var i,
                l;
            if (!stride) {
              stride = 3;
            }
            if (!offset) {
              offset = 0;
            }
            if (count) {
              l = Math.min((count * stride) + offset, a.length);
            } else {
              l = a.length;
            }
            for (i = offset; i < l; i += stride) {
              vec[0] = a[i];
              vec[1] = a[i + 1];
              vec[2] = a[i + 2];
              fn(vec, vec, arg);
              a[i] = vec[0];
              a[i + 1] = vec[1];
              a[i + 2] = vec[2];
            }
            return a;
          };
        })();
        vec3.str = function(a) {
          return 'vec3(' + a[0] + ', ' + a[1] + ', ' + a[2] + ')';
        };
        if (typeof(exports) !== 'undefined') {
          exports.vec3 = vec3;
        }
        ;
        var vec4 = {};
        vec4.create = function() {
          var out = new GLMAT_ARRAY_TYPE(4);
          out[0] = 0;
          out[1] = 0;
          out[2] = 0;
          out[3] = 0;
          return out;
        };
        vec4.clone = function(a) {
          var out = new GLMAT_ARRAY_TYPE(4);
          out[0] = a[0];
          out[1] = a[1];
          out[2] = a[2];
          out[3] = a[3];
          return out;
        };
        vec4.fromValues = function(x, y, z, w) {
          var out = new GLMAT_ARRAY_TYPE(4);
          out[0] = x;
          out[1] = y;
          out[2] = z;
          out[3] = w;
          return out;
        };
        vec4.copy = function(out, a) {
          out[0] = a[0];
          out[1] = a[1];
          out[2] = a[2];
          out[3] = a[3];
          return out;
        };
        vec4.set = function(out, x, y, z, w) {
          out[0] = x;
          out[1] = y;
          out[2] = z;
          out[3] = w;
          return out;
        };
        vec4.add = function(out, a, b) {
          out[0] = a[0] + b[0];
          out[1] = a[1] + b[1];
          out[2] = a[2] + b[2];
          out[3] = a[3] + b[3];
          return out;
        };
        vec4.subtract = function(out, a, b) {
          out[0] = a[0] - b[0];
          out[1] = a[1] - b[1];
          out[2] = a[2] - b[2];
          out[3] = a[3] - b[3];
          return out;
        };
        vec4.sub = vec4.subtract;
        vec4.multiply = function(out, a, b) {
          out[0] = a[0] * b[0];
          out[1] = a[1] * b[1];
          out[2] = a[2] * b[2];
          out[3] = a[3] * b[3];
          return out;
        };
        vec4.mul = vec4.multiply;
        vec4.divide = function(out, a, b) {
          out[0] = a[0] / b[0];
          out[1] = a[1] / b[1];
          out[2] = a[2] / b[2];
          out[3] = a[3] / b[3];
          return out;
        };
        vec4.div = vec4.divide;
        vec4.min = function(out, a, b) {
          out[0] = Math.min(a[0], b[0]);
          out[1] = Math.min(a[1], b[1]);
          out[2] = Math.min(a[2], b[2]);
          out[3] = Math.min(a[3], b[3]);
          return out;
        };
        vec4.max = function(out, a, b) {
          out[0] = Math.max(a[0], b[0]);
          out[1] = Math.max(a[1], b[1]);
          out[2] = Math.max(a[2], b[2]);
          out[3] = Math.max(a[3], b[3]);
          return out;
        };
        vec4.scale = function(out, a, b) {
          out[0] = a[0] * b;
          out[1] = a[1] * b;
          out[2] = a[2] * b;
          out[3] = a[3] * b;
          return out;
        };
        vec4.scaleAndAdd = function(out, a, b, scale) {
          out[0] = a[0] + (b[0] * scale);
          out[1] = a[1] + (b[1] * scale);
          out[2] = a[2] + (b[2] * scale);
          out[3] = a[3] + (b[3] * scale);
          return out;
        };
        vec4.distance = function(a, b) {
          var x = b[0] - a[0],
              y = b[1] - a[1],
              z = b[2] - a[2],
              w = b[3] - a[3];
          return Math.sqrt(x * x + y * y + z * z + w * w);
        };
        vec4.dist = vec4.distance;
        vec4.squaredDistance = function(a, b) {
          var x = b[0] - a[0],
              y = b[1] - a[1],
              z = b[2] - a[2],
              w = b[3] - a[3];
          return x * x + y * y + z * z + w * w;
        };
        vec4.sqrDist = vec4.squaredDistance;
        vec4.length = function(a) {
          var x = a[0],
              y = a[1],
              z = a[2],
              w = a[3];
          return Math.sqrt(x * x + y * y + z * z + w * w);
        };
        vec4.len = vec4.length;
        vec4.squaredLength = function(a) {
          var x = a[0],
              y = a[1],
              z = a[2],
              w = a[3];
          return x * x + y * y + z * z + w * w;
        };
        vec4.sqrLen = vec4.squaredLength;
        vec4.negate = function(out, a) {
          out[0] = -a[0];
          out[1] = -a[1];
          out[2] = -a[2];
          out[3] = -a[3];
          return out;
        };
        vec4.normalize = function(out, a) {
          var x = a[0],
              y = a[1],
              z = a[2],
              w = a[3];
          var len = x * x + y * y + z * z + w * w;
          if (len > 0) {
            len = 1 / Math.sqrt(len);
            out[0] = a[0] * len;
            out[1] = a[1] * len;
            out[2] = a[2] * len;
            out[3] = a[3] * len;
          }
          return out;
        };
        vec4.dot = function(a, b) {
          return a[0] * b[0] + a[1] * b[1] + a[2] * b[2] + a[3] * b[3];
        };
        vec4.lerp = function(out, a, b, t) {
          var ax = a[0],
              ay = a[1],
              az = a[2],
              aw = a[3];
          out[0] = ax + t * (b[0] - ax);
          out[1] = ay + t * (b[1] - ay);
          out[2] = az + t * (b[2] - az);
          out[3] = aw + t * (b[3] - aw);
          return out;
        };
        vec4.random = function(out, scale) {
          scale = scale || 1.0;
          out[0] = GLMAT_RANDOM();
          out[1] = GLMAT_RANDOM();
          out[2] = GLMAT_RANDOM();
          out[3] = GLMAT_RANDOM();
          vec4.normalize(out, out);
          vec4.scale(out, out, scale);
          return out;
        };
        vec4.transformMat4 = function(out, a, m) {
          var x = a[0],
              y = a[1],
              z = a[2],
              w = a[3];
          out[0] = m[0] * x + m[4] * y + m[8] * z + m[12] * w;
          out[1] = m[1] * x + m[5] * y + m[9] * z + m[13] * w;
          out[2] = m[2] * x + m[6] * y + m[10] * z + m[14] * w;
          out[3] = m[3] * x + m[7] * y + m[11] * z + m[15] * w;
          return out;
        };
        vec4.transformQuat = function(out, a, q) {
          var x = a[0],
              y = a[1],
              z = a[2],
              qx = q[0],
              qy = q[1],
              qz = q[2],
              qw = q[3],
              ix = qw * x + qy * z - qz * y,
              iy = qw * y + qz * x - qx * z,
              iz = qw * z + qx * y - qy * x,
              iw = -qx * x - qy * y - qz * z;
          out[0] = ix * qw + iw * -qx + iy * -qz - iz * -qy;
          out[1] = iy * qw + iw * -qy + iz * -qx - ix * -qz;
          out[2] = iz * qw + iw * -qz + ix * -qy - iy * -qx;
          return out;
        };
        vec4.forEach = (function() {
          var vec = vec4.create();
          return function(a, stride, offset, count, fn, arg) {
            var i,
                l;
            if (!stride) {
              stride = 4;
            }
            if (!offset) {
              offset = 0;
            }
            if (count) {
              l = Math.min((count * stride) + offset, a.length);
            } else {
              l = a.length;
            }
            for (i = offset; i < l; i += stride) {
              vec[0] = a[i];
              vec[1] = a[i + 1];
              vec[2] = a[i + 2];
              vec[3] = a[i + 3];
              fn(vec, vec, arg);
              a[i] = vec[0];
              a[i + 1] = vec[1];
              a[i + 2] = vec[2];
              a[i + 3] = vec[3];
            }
            return a;
          };
        })();
        vec4.str = function(a) {
          return 'vec4(' + a[0] + ', ' + a[1] + ', ' + a[2] + ', ' + a[3] + ')';
        };
        if (typeof(exports) !== 'undefined') {
          exports.vec4 = vec4;
        }
        ;
        var mat2 = {};
        mat2.create = function() {
          var out = new GLMAT_ARRAY_TYPE(4);
          out[0] = 1;
          out[1] = 0;
          out[2] = 0;
          out[3] = 1;
          return out;
        };
        mat2.clone = function(a) {
          var out = new GLMAT_ARRAY_TYPE(4);
          out[0] = a[0];
          out[1] = a[1];
          out[2] = a[2];
          out[3] = a[3];
          return out;
        };
        mat2.copy = function(out, a) {
          out[0] = a[0];
          out[1] = a[1];
          out[2] = a[2];
          out[3] = a[3];
          return out;
        };
        mat2.identity = function(out) {
          out[0] = 1;
          out[1] = 0;
          out[2] = 0;
          out[3] = 1;
          return out;
        };
        mat2.transpose = function(out, a) {
          if (out === a) {
            var a1 = a[1];
            out[1] = a[2];
            out[2] = a1;
          } else {
            out[0] = a[0];
            out[1] = a[2];
            out[2] = a[1];
            out[3] = a[3];
          }
          return out;
        };
        mat2.invert = function(out, a) {
          var a0 = a[0],
              a1 = a[1],
              a2 = a[2],
              a3 = a[3],
              det = a0 * a3 - a2 * a1;
          if (!det) {
            return null;
          }
          det = 1.0 / det;
          out[0] = a3 * det;
          out[1] = -a1 * det;
          out[2] = -a2 * det;
          out[3] = a0 * det;
          return out;
        };
        mat2.adjoint = function(out, a) {
          var a0 = a[0];
          out[0] = a[3];
          out[1] = -a[1];
          out[2] = -a[2];
          out[3] = a0;
          return out;
        };
        mat2.determinant = function(a) {
          return a[0] * a[3] - a[2] * a[1];
        };
        mat2.multiply = function(out, a, b) {
          var a0 = a[0],
              a1 = a[1],
              a2 = a[2],
              a3 = a[3];
          var b0 = b[0],
              b1 = b[1],
              b2 = b[2],
              b3 = b[3];
          out[0] = a0 * b0 + a2 * b1;
          out[1] = a1 * b0 + a3 * b1;
          out[2] = a0 * b2 + a2 * b3;
          out[3] = a1 * b2 + a3 * b3;
          return out;
        };
        mat2.mul = mat2.multiply;
        mat2.rotate = function(out, a, rad) {
          var a0 = a[0],
              a1 = a[1],
              a2 = a[2],
              a3 = a[3],
              s = Math.sin(rad),
              c = Math.cos(rad);
          out[0] = a0 * c + a2 * s;
          out[1] = a1 * c + a3 * s;
          out[2] = a0 * -s + a2 * c;
          out[3] = a1 * -s + a3 * c;
          return out;
        };
        mat2.scale = function(out, a, v) {
          var a0 = a[0],
              a1 = a[1],
              a2 = a[2],
              a3 = a[3],
              v0 = v[0],
              v1 = v[1];
          out[0] = a0 * v0;
          out[1] = a1 * v0;
          out[2] = a2 * v1;
          out[3] = a3 * v1;
          return out;
        };
        mat2.str = function(a) {
          return 'mat2(' + a[0] + ', ' + a[1] + ', ' + a[2] + ', ' + a[3] + ')';
        };
        mat2.frob = function(a) {
          return (Math.sqrt(Math.pow(a[0], 2) + Math.pow(a[1], 2) + Math.pow(a[2], 2) + Math.pow(a[3], 2)));
        };
        mat2.LDU = function(L, D, U, a) {
          L[2] = a[2] / a[0];
          U[0] = a[0];
          U[1] = a[1];
          U[3] = a[3] - L[2] * U[1];
          return [L, D, U];
        };
        if (typeof(exports) !== 'undefined') {
          exports.mat2 = mat2;
        }
        ;
        var mat2d = {};
        mat2d.create = function() {
          var out = new GLMAT_ARRAY_TYPE(6);
          out[0] = 1;
          out[1] = 0;
          out[2] = 0;
          out[3] = 1;
          out[4] = 0;
          out[5] = 0;
          return out;
        };
        mat2d.clone = function(a) {
          var out = new GLMAT_ARRAY_TYPE(6);
          out[0] = a[0];
          out[1] = a[1];
          out[2] = a[2];
          out[3] = a[3];
          out[4] = a[4];
          out[5] = a[5];
          return out;
        };
        mat2d.copy = function(out, a) {
          out[0] = a[0];
          out[1] = a[1];
          out[2] = a[2];
          out[3] = a[3];
          out[4] = a[4];
          out[5] = a[5];
          return out;
        };
        mat2d.identity = function(out) {
          out[0] = 1;
          out[1] = 0;
          out[2] = 0;
          out[3] = 1;
          out[4] = 0;
          out[5] = 0;
          return out;
        };
        mat2d.invert = function(out, a) {
          var aa = a[0],
              ab = a[1],
              ac = a[2],
              ad = a[3],
              atx = a[4],
              aty = a[5];
          var det = aa * ad - ab * ac;
          if (!det) {
            return null;
          }
          det = 1.0 / det;
          out[0] = ad * det;
          out[1] = -ab * det;
          out[2] = -ac * det;
          out[3] = aa * det;
          out[4] = (ac * aty - ad * atx) * det;
          out[5] = (ab * atx - aa * aty) * det;
          return out;
        };
        mat2d.determinant = function(a) {
          return a[0] * a[3] - a[1] * a[2];
        };
        mat2d.multiply = function(out, a, b) {
          var a0 = a[0],
              a1 = a[1],
              a2 = a[2],
              a3 = a[3],
              a4 = a[4],
              a5 = a[5],
              b0 = b[0],
              b1 = b[1],
              b2 = b[2],
              b3 = b[3],
              b4 = b[4],
              b5 = b[5];
          out[0] = a0 * b0 + a2 * b1;
          out[1] = a1 * b0 + a3 * b1;
          out[2] = a0 * b2 + a2 * b3;
          out[3] = a1 * b2 + a3 * b3;
          out[4] = a0 * b4 + a2 * b5 + a4;
          out[5] = a1 * b4 + a3 * b5 + a5;
          return out;
        };
        mat2d.mul = mat2d.multiply;
        mat2d.rotate = function(out, a, rad) {
          var a0 = a[0],
              a1 = a[1],
              a2 = a[2],
              a3 = a[3],
              a4 = a[4],
              a5 = a[5],
              s = Math.sin(rad),
              c = Math.cos(rad);
          out[0] = a0 * c + a2 * s;
          out[1] = a1 * c + a3 * s;
          out[2] = a0 * -s + a2 * c;
          out[3] = a1 * -s + a3 * c;
          out[4] = a4;
          out[5] = a5;
          return out;
        };
        mat2d.scale = function(out, a, v) {
          var a0 = a[0],
              a1 = a[1],
              a2 = a[2],
              a3 = a[3],
              a4 = a[4],
              a5 = a[5],
              v0 = v[0],
              v1 = v[1];
          out[0] = a0 * v0;
          out[1] = a1 * v0;
          out[2] = a2 * v1;
          out[3] = a3 * v1;
          out[4] = a4;
          out[5] = a5;
          return out;
        };
        mat2d.translate = function(out, a, v) {
          var a0 = a[0],
              a1 = a[1],
              a2 = a[2],
              a3 = a[3],
              a4 = a[4],
              a5 = a[5],
              v0 = v[0],
              v1 = v[1];
          out[0] = a0;
          out[1] = a1;
          out[2] = a2;
          out[3] = a3;
          out[4] = a0 * v0 + a2 * v1 + a4;
          out[5] = a1 * v0 + a3 * v1 + a5;
          return out;
        };
        mat2d.str = function(a) {
          return 'mat2d(' + a[0] + ', ' + a[1] + ', ' + a[2] + ', ' + a[3] + ', ' + a[4] + ', ' + a[5] + ')';
        };
        mat2d.frob = function(a) {
          return (Math.sqrt(Math.pow(a[0], 2) + Math.pow(a[1], 2) + Math.pow(a[2], 2) + Math.pow(a[3], 2) + Math.pow(a[4], 2) + Math.pow(a[5], 2) + 1));
        };
        if (typeof(exports) !== 'undefined') {
          exports.mat2d = mat2d;
        }
        ;
        var mat3 = {};
        mat3.create = function() {
          var out = new GLMAT_ARRAY_TYPE(9);
          out[0] = 1;
          out[1] = 0;
          out[2] = 0;
          out[3] = 0;
          out[4] = 1;
          out[5] = 0;
          out[6] = 0;
          out[7] = 0;
          out[8] = 1;
          return out;
        };
        mat3.fromMat4 = function(out, a) {
          out[0] = a[0];
          out[1] = a[1];
          out[2] = a[2];
          out[3] = a[4];
          out[4] = a[5];
          out[5] = a[6];
          out[6] = a[8];
          out[7] = a[9];
          out[8] = a[10];
          return out;
        };
        mat3.clone = function(a) {
          var out = new GLMAT_ARRAY_TYPE(9);
          out[0] = a[0];
          out[1] = a[1];
          out[2] = a[2];
          out[3] = a[3];
          out[4] = a[4];
          out[5] = a[5];
          out[6] = a[6];
          out[7] = a[7];
          out[8] = a[8];
          return out;
        };
        mat3.copy = function(out, a) {
          out[0] = a[0];
          out[1] = a[1];
          out[2] = a[2];
          out[3] = a[3];
          out[4] = a[4];
          out[5] = a[5];
          out[6] = a[6];
          out[7] = a[7];
          out[8] = a[8];
          return out;
        };
        mat3.identity = function(out) {
          out[0] = 1;
          out[1] = 0;
          out[2] = 0;
          out[3] = 0;
          out[4] = 1;
          out[5] = 0;
          out[6] = 0;
          out[7] = 0;
          out[8] = 1;
          return out;
        };
        mat3.transpose = function(out, a) {
          if (out === a) {
            var a01 = a[1],
                a02 = a[2],
                a12 = a[5];
            out[1] = a[3];
            out[2] = a[6];
            out[3] = a01;
            out[5] = a[7];
            out[6] = a02;
            out[7] = a12;
          } else {
            out[0] = a[0];
            out[1] = a[3];
            out[2] = a[6];
            out[3] = a[1];
            out[4] = a[4];
            out[5] = a[7];
            out[6] = a[2];
            out[7] = a[5];
            out[8] = a[8];
          }
          return out;
        };
        mat3.invert = function(out, a) {
          var a00 = a[0],
              a01 = a[1],
              a02 = a[2],
              a10 = a[3],
              a11 = a[4],
              a12 = a[5],
              a20 = a[6],
              a21 = a[7],
              a22 = a[8],
              b01 = a22 * a11 - a12 * a21,
              b11 = -a22 * a10 + a12 * a20,
              b21 = a21 * a10 - a11 * a20,
              det = a00 * b01 + a01 * b11 + a02 * b21;
          if (!det) {
            return null;
          }
          det = 1.0 / det;
          out[0] = b01 * det;
          out[1] = (-a22 * a01 + a02 * a21) * det;
          out[2] = (a12 * a01 - a02 * a11) * det;
          out[3] = b11 * det;
          out[4] = (a22 * a00 - a02 * a20) * det;
          out[5] = (-a12 * a00 + a02 * a10) * det;
          out[6] = b21 * det;
          out[7] = (-a21 * a00 + a01 * a20) * det;
          out[8] = (a11 * a00 - a01 * a10) * det;
          return out;
        };
        mat3.adjoint = function(out, a) {
          var a00 = a[0],
              a01 = a[1],
              a02 = a[2],
              a10 = a[3],
              a11 = a[4],
              a12 = a[5],
              a20 = a[6],
              a21 = a[7],
              a22 = a[8];
          out[0] = (a11 * a22 - a12 * a21);
          out[1] = (a02 * a21 - a01 * a22);
          out[2] = (a01 * a12 - a02 * a11);
          out[3] = (a12 * a20 - a10 * a22);
          out[4] = (a00 * a22 - a02 * a20);
          out[5] = (a02 * a10 - a00 * a12);
          out[6] = (a10 * a21 - a11 * a20);
          out[7] = (a01 * a20 - a00 * a21);
          out[8] = (a00 * a11 - a01 * a10);
          return out;
        };
        mat3.determinant = function(a) {
          var a00 = a[0],
              a01 = a[1],
              a02 = a[2],
              a10 = a[3],
              a11 = a[4],
              a12 = a[5],
              a20 = a[6],
              a21 = a[7],
              a22 = a[8];
          return a00 * (a22 * a11 - a12 * a21) + a01 * (-a22 * a10 + a12 * a20) + a02 * (a21 * a10 - a11 * a20);
        };
        mat3.multiply = function(out, a, b) {
          var a00 = a[0],
              a01 = a[1],
              a02 = a[2],
              a10 = a[3],
              a11 = a[4],
              a12 = a[5],
              a20 = a[6],
              a21 = a[7],
              a22 = a[8],
              b00 = b[0],
              b01 = b[1],
              b02 = b[2],
              b10 = b[3],
              b11 = b[4],
              b12 = b[5],
              b20 = b[6],
              b21 = b[7],
              b22 = b[8];
          out[0] = b00 * a00 + b01 * a10 + b02 * a20;
          out[1] = b00 * a01 + b01 * a11 + b02 * a21;
          out[2] = b00 * a02 + b01 * a12 + b02 * a22;
          out[3] = b10 * a00 + b11 * a10 + b12 * a20;
          out[4] = b10 * a01 + b11 * a11 + b12 * a21;
          out[5] = b10 * a02 + b11 * a12 + b12 * a22;
          out[6] = b20 * a00 + b21 * a10 + b22 * a20;
          out[7] = b20 * a01 + b21 * a11 + b22 * a21;
          out[8] = b20 * a02 + b21 * a12 + b22 * a22;
          return out;
        };
        mat3.mul = mat3.multiply;
        mat3.translate = function(out, a, v) {
          var a00 = a[0],
              a01 = a[1],
              a02 = a[2],
              a10 = a[3],
              a11 = a[4],
              a12 = a[5],
              a20 = a[6],
              a21 = a[7],
              a22 = a[8],
              x = v[0],
              y = v[1];
          out[0] = a00;
          out[1] = a01;
          out[2] = a02;
          out[3] = a10;
          out[4] = a11;
          out[5] = a12;
          out[6] = x * a00 + y * a10 + a20;
          out[7] = x * a01 + y * a11 + a21;
          out[8] = x * a02 + y * a12 + a22;
          return out;
        };
        mat3.rotate = function(out, a, rad) {
          var a00 = a[0],
              a01 = a[1],
              a02 = a[2],
              a10 = a[3],
              a11 = a[4],
              a12 = a[5],
              a20 = a[6],
              a21 = a[7],
              a22 = a[8],
              s = Math.sin(rad),
              c = Math.cos(rad);
          out[0] = c * a00 + s * a10;
          out[1] = c * a01 + s * a11;
          out[2] = c * a02 + s * a12;
          out[3] = c * a10 - s * a00;
          out[4] = c * a11 - s * a01;
          out[5] = c * a12 - s * a02;
          out[6] = a20;
          out[7] = a21;
          out[8] = a22;
          return out;
        };
        mat3.scale = function(out, a, v) {
          var x = v[0],
              y = v[1];
          out[0] = x * a[0];
          out[1] = x * a[1];
          out[2] = x * a[2];
          out[3] = y * a[3];
          out[4] = y * a[4];
          out[5] = y * a[5];
          out[6] = a[6];
          out[7] = a[7];
          out[8] = a[8];
          return out;
        };
        mat3.fromMat2d = function(out, a) {
          out[0] = a[0];
          out[1] = a[1];
          out[2] = 0;
          out[3] = a[2];
          out[4] = a[3];
          out[5] = 0;
          out[6] = a[4];
          out[7] = a[5];
          out[8] = 1;
          return out;
        };
        mat3.fromQuat = function(out, q) {
          var x = q[0],
              y = q[1],
              z = q[2],
              w = q[3],
              x2 = x + x,
              y2 = y + y,
              z2 = z + z,
              xx = x * x2,
              yx = y * x2,
              yy = y * y2,
              zx = z * x2,
              zy = z * y2,
              zz = z * z2,
              wx = w * x2,
              wy = w * y2,
              wz = w * z2;
          out[0] = 1 - yy - zz;
          out[3] = yx - wz;
          out[6] = zx + wy;
          out[1] = yx + wz;
          out[4] = 1 - xx - zz;
          out[7] = zy - wx;
          out[2] = zx - wy;
          out[5] = zy + wx;
          out[8] = 1 - xx - yy;
          return out;
        };
        mat3.normalFromMat4 = function(out, a) {
          var a00 = a[0],
              a01 = a[1],
              a02 = a[2],
              a03 = a[3],
              a10 = a[4],
              a11 = a[5],
              a12 = a[6],
              a13 = a[7],
              a20 = a[8],
              a21 = a[9],
              a22 = a[10],
              a23 = a[11],
              a30 = a[12],
              a31 = a[13],
              a32 = a[14],
              a33 = a[15],
              b00 = a00 * a11 - a01 * a10,
              b01 = a00 * a12 - a02 * a10,
              b02 = a00 * a13 - a03 * a10,
              b03 = a01 * a12 - a02 * a11,
              b04 = a01 * a13 - a03 * a11,
              b05 = a02 * a13 - a03 * a12,
              b06 = a20 * a31 - a21 * a30,
              b07 = a20 * a32 - a22 * a30,
              b08 = a20 * a33 - a23 * a30,
              b09 = a21 * a32 - a22 * a31,
              b10 = a21 * a33 - a23 * a31,
              b11 = a22 * a33 - a23 * a32,
              det = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;
          if (!det) {
            return null;
          }
          det = 1.0 / det;
          out[0] = (a11 * b11 - a12 * b10 + a13 * b09) * det;
          out[1] = (a12 * b08 - a10 * b11 - a13 * b07) * det;
          out[2] = (a10 * b10 - a11 * b08 + a13 * b06) * det;
          out[3] = (a02 * b10 - a01 * b11 - a03 * b09) * det;
          out[4] = (a00 * b11 - a02 * b08 + a03 * b07) * det;
          out[5] = (a01 * b08 - a00 * b10 - a03 * b06) * det;
          out[6] = (a31 * b05 - a32 * b04 + a33 * b03) * det;
          out[7] = (a32 * b02 - a30 * b05 - a33 * b01) * det;
          out[8] = (a30 * b04 - a31 * b02 + a33 * b00) * det;
          return out;
        };
        mat3.str = function(a) {
          return 'mat3(' + a[0] + ', ' + a[1] + ', ' + a[2] + ', ' + a[3] + ', ' + a[4] + ', ' + a[5] + ', ' + a[6] + ', ' + a[7] + ', ' + a[8] + ')';
        };
        mat3.frob = function(a) {
          return (Math.sqrt(Math.pow(a[0], 2) + Math.pow(a[1], 2) + Math.pow(a[2], 2) + Math.pow(a[3], 2) + Math.pow(a[4], 2) + Math.pow(a[5], 2) + Math.pow(a[6], 2) + Math.pow(a[7], 2) + Math.pow(a[8], 2)));
        };
        if (typeof(exports) !== 'undefined') {
          exports.mat3 = mat3;
        }
        ;
        var mat4 = {};
        mat4.create = function() {
          var out = new GLMAT_ARRAY_TYPE(16);
          out[0] = 1;
          out[1] = 0;
          out[2] = 0;
          out[3] = 0;
          out[4] = 0;
          out[5] = 1;
          out[6] = 0;
          out[7] = 0;
          out[8] = 0;
          out[9] = 0;
          out[10] = 1;
          out[11] = 0;
          out[12] = 0;
          out[13] = 0;
          out[14] = 0;
          out[15] = 1;
          return out;
        };
        mat4.clone = function(a) {
          var out = new GLMAT_ARRAY_TYPE(16);
          out[0] = a[0];
          out[1] = a[1];
          out[2] = a[2];
          out[3] = a[3];
          out[4] = a[4];
          out[5] = a[5];
          out[6] = a[6];
          out[7] = a[7];
          out[8] = a[8];
          out[9] = a[9];
          out[10] = a[10];
          out[11] = a[11];
          out[12] = a[12];
          out[13] = a[13];
          out[14] = a[14];
          out[15] = a[15];
          return out;
        };
        mat4.copy = function(out, a) {
          out[0] = a[0];
          out[1] = a[1];
          out[2] = a[2];
          out[3] = a[3];
          out[4] = a[4];
          out[5] = a[5];
          out[6] = a[6];
          out[7] = a[7];
          out[8] = a[8];
          out[9] = a[9];
          out[10] = a[10];
          out[11] = a[11];
          out[12] = a[12];
          out[13] = a[13];
          out[14] = a[14];
          out[15] = a[15];
          return out;
        };
        mat4.identity = function(out) {
          out[0] = 1;
          out[1] = 0;
          out[2] = 0;
          out[3] = 0;
          out[4] = 0;
          out[5] = 1;
          out[6] = 0;
          out[7] = 0;
          out[8] = 0;
          out[9] = 0;
          out[10] = 1;
          out[11] = 0;
          out[12] = 0;
          out[13] = 0;
          out[14] = 0;
          out[15] = 1;
          return out;
        };
        mat4.transpose = function(out, a) {
          if (out === a) {
            var a01 = a[1],
                a02 = a[2],
                a03 = a[3],
                a12 = a[6],
                a13 = a[7],
                a23 = a[11];
            out[1] = a[4];
            out[2] = a[8];
            out[3] = a[12];
            out[4] = a01;
            out[6] = a[9];
            out[7] = a[13];
            out[8] = a02;
            out[9] = a12;
            out[11] = a[14];
            out[12] = a03;
            out[13] = a13;
            out[14] = a23;
          } else {
            out[0] = a[0];
            out[1] = a[4];
            out[2] = a[8];
            out[3] = a[12];
            out[4] = a[1];
            out[5] = a[5];
            out[6] = a[9];
            out[7] = a[13];
            out[8] = a[2];
            out[9] = a[6];
            out[10] = a[10];
            out[11] = a[14];
            out[12] = a[3];
            out[13] = a[7];
            out[14] = a[11];
            out[15] = a[15];
          }
          return out;
        };
        mat4.invert = function(out, a) {
          var a00 = a[0],
              a01 = a[1],
              a02 = a[2],
              a03 = a[3],
              a10 = a[4],
              a11 = a[5],
              a12 = a[6],
              a13 = a[7],
              a20 = a[8],
              a21 = a[9],
              a22 = a[10],
              a23 = a[11],
              a30 = a[12],
              a31 = a[13],
              a32 = a[14],
              a33 = a[15],
              b00 = a00 * a11 - a01 * a10,
              b01 = a00 * a12 - a02 * a10,
              b02 = a00 * a13 - a03 * a10,
              b03 = a01 * a12 - a02 * a11,
              b04 = a01 * a13 - a03 * a11,
              b05 = a02 * a13 - a03 * a12,
              b06 = a20 * a31 - a21 * a30,
              b07 = a20 * a32 - a22 * a30,
              b08 = a20 * a33 - a23 * a30,
              b09 = a21 * a32 - a22 * a31,
              b10 = a21 * a33 - a23 * a31,
              b11 = a22 * a33 - a23 * a32,
              det = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;
          if (!det) {
            return null;
          }
          det = 1.0 / det;
          out[0] = (a11 * b11 - a12 * b10 + a13 * b09) * det;
          out[1] = (a02 * b10 - a01 * b11 - a03 * b09) * det;
          out[2] = (a31 * b05 - a32 * b04 + a33 * b03) * det;
          out[3] = (a22 * b04 - a21 * b05 - a23 * b03) * det;
          out[4] = (a12 * b08 - a10 * b11 - a13 * b07) * det;
          out[5] = (a00 * b11 - a02 * b08 + a03 * b07) * det;
          out[6] = (a32 * b02 - a30 * b05 - a33 * b01) * det;
          out[7] = (a20 * b05 - a22 * b02 + a23 * b01) * det;
          out[8] = (a10 * b10 - a11 * b08 + a13 * b06) * det;
          out[9] = (a01 * b08 - a00 * b10 - a03 * b06) * det;
          out[10] = (a30 * b04 - a31 * b02 + a33 * b00) * det;
          out[11] = (a21 * b02 - a20 * b04 - a23 * b00) * det;
          out[12] = (a11 * b07 - a10 * b09 - a12 * b06) * det;
          out[13] = (a00 * b09 - a01 * b07 + a02 * b06) * det;
          out[14] = (a31 * b01 - a30 * b03 - a32 * b00) * det;
          out[15] = (a20 * b03 - a21 * b01 + a22 * b00) * det;
          return out;
        };
        mat4.adjoint = function(out, a) {
          var a00 = a[0],
              a01 = a[1],
              a02 = a[2],
              a03 = a[3],
              a10 = a[4],
              a11 = a[5],
              a12 = a[6],
              a13 = a[7],
              a20 = a[8],
              a21 = a[9],
              a22 = a[10],
              a23 = a[11],
              a30 = a[12],
              a31 = a[13],
              a32 = a[14],
              a33 = a[15];
          out[0] = (a11 * (a22 * a33 - a23 * a32) - a21 * (a12 * a33 - a13 * a32) + a31 * (a12 * a23 - a13 * a22));
          out[1] = -(a01 * (a22 * a33 - a23 * a32) - a21 * (a02 * a33 - a03 * a32) + a31 * (a02 * a23 - a03 * a22));
          out[2] = (a01 * (a12 * a33 - a13 * a32) - a11 * (a02 * a33 - a03 * a32) + a31 * (a02 * a13 - a03 * a12));
          out[3] = -(a01 * (a12 * a23 - a13 * a22) - a11 * (a02 * a23 - a03 * a22) + a21 * (a02 * a13 - a03 * a12));
          out[4] = -(a10 * (a22 * a33 - a23 * a32) - a20 * (a12 * a33 - a13 * a32) + a30 * (a12 * a23 - a13 * a22));
          out[5] = (a00 * (a22 * a33 - a23 * a32) - a20 * (a02 * a33 - a03 * a32) + a30 * (a02 * a23 - a03 * a22));
          out[6] = -(a00 * (a12 * a33 - a13 * a32) - a10 * (a02 * a33 - a03 * a32) + a30 * (a02 * a13 - a03 * a12));
          out[7] = (a00 * (a12 * a23 - a13 * a22) - a10 * (a02 * a23 - a03 * a22) + a20 * (a02 * a13 - a03 * a12));
          out[8] = (a10 * (a21 * a33 - a23 * a31) - a20 * (a11 * a33 - a13 * a31) + a30 * (a11 * a23 - a13 * a21));
          out[9] = -(a00 * (a21 * a33 - a23 * a31) - a20 * (a01 * a33 - a03 * a31) + a30 * (a01 * a23 - a03 * a21));
          out[10] = (a00 * (a11 * a33 - a13 * a31) - a10 * (a01 * a33 - a03 * a31) + a30 * (a01 * a13 - a03 * a11));
          out[11] = -(a00 * (a11 * a23 - a13 * a21) - a10 * (a01 * a23 - a03 * a21) + a20 * (a01 * a13 - a03 * a11));
          out[12] = -(a10 * (a21 * a32 - a22 * a31) - a20 * (a11 * a32 - a12 * a31) + a30 * (a11 * a22 - a12 * a21));
          out[13] = (a00 * (a21 * a32 - a22 * a31) - a20 * (a01 * a32 - a02 * a31) + a30 * (a01 * a22 - a02 * a21));
          out[14] = -(a00 * (a11 * a32 - a12 * a31) - a10 * (a01 * a32 - a02 * a31) + a30 * (a01 * a12 - a02 * a11));
          out[15] = (a00 * (a11 * a22 - a12 * a21) - a10 * (a01 * a22 - a02 * a21) + a20 * (a01 * a12 - a02 * a11));
          return out;
        };
        mat4.determinant = function(a) {
          var a00 = a[0],
              a01 = a[1],
              a02 = a[2],
              a03 = a[3],
              a10 = a[4],
              a11 = a[5],
              a12 = a[6],
              a13 = a[7],
              a20 = a[8],
              a21 = a[9],
              a22 = a[10],
              a23 = a[11],
              a30 = a[12],
              a31 = a[13],
              a32 = a[14],
              a33 = a[15],
              b00 = a00 * a11 - a01 * a10,
              b01 = a00 * a12 - a02 * a10,
              b02 = a00 * a13 - a03 * a10,
              b03 = a01 * a12 - a02 * a11,
              b04 = a01 * a13 - a03 * a11,
              b05 = a02 * a13 - a03 * a12,
              b06 = a20 * a31 - a21 * a30,
              b07 = a20 * a32 - a22 * a30,
              b08 = a20 * a33 - a23 * a30,
              b09 = a21 * a32 - a22 * a31,
              b10 = a21 * a33 - a23 * a31,
              b11 = a22 * a33 - a23 * a32;
          return b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;
        };
        mat4.multiply = function(out, a, b) {
          var a00 = a[0],
              a01 = a[1],
              a02 = a[2],
              a03 = a[3],
              a10 = a[4],
              a11 = a[5],
              a12 = a[6],
              a13 = a[7],
              a20 = a[8],
              a21 = a[9],
              a22 = a[10],
              a23 = a[11],
              a30 = a[12],
              a31 = a[13],
              a32 = a[14],
              a33 = a[15];
          var b0 = b[0],
              b1 = b[1],
              b2 = b[2],
              b3 = b[3];
          out[0] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
          out[1] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
          out[2] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
          out[3] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
          b0 = b[4];
          b1 = b[5];
          b2 = b[6];
          b3 = b[7];
          out[4] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
          out[5] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
          out[6] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
          out[7] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
          b0 = b[8];
          b1 = b[9];
          b2 = b[10];
          b3 = b[11];
          out[8] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
          out[9] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
          out[10] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
          out[11] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
          b0 = b[12];
          b1 = b[13];
          b2 = b[14];
          b3 = b[15];
          out[12] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
          out[13] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
          out[14] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
          out[15] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
          return out;
        };
        mat4.mul = mat4.multiply;
        mat4.translate = function(out, a, v) {
          var x = v[0],
              y = v[1],
              z = v[2],
              a00,
              a01,
              a02,
              a03,
              a10,
              a11,
              a12,
              a13,
              a20,
              a21,
              a22,
              a23;
          if (a === out) {
            out[12] = a[0] * x + a[4] * y + a[8] * z + a[12];
            out[13] = a[1] * x + a[5] * y + a[9] * z + a[13];
            out[14] = a[2] * x + a[6] * y + a[10] * z + a[14];
            out[15] = a[3] * x + a[7] * y + a[11] * z + a[15];
          } else {
            a00 = a[0];
            a01 = a[1];
            a02 = a[2];
            a03 = a[3];
            a10 = a[4];
            a11 = a[5];
            a12 = a[6];
            a13 = a[7];
            a20 = a[8];
            a21 = a[9];
            a22 = a[10];
            a23 = a[11];
            out[0] = a00;
            out[1] = a01;
            out[2] = a02;
            out[3] = a03;
            out[4] = a10;
            out[5] = a11;
            out[6] = a12;
            out[7] = a13;
            out[8] = a20;
            out[9] = a21;
            out[10] = a22;
            out[11] = a23;
            out[12] = a00 * x + a10 * y + a20 * z + a[12];
            out[13] = a01 * x + a11 * y + a21 * z + a[13];
            out[14] = a02 * x + a12 * y + a22 * z + a[14];
            out[15] = a03 * x + a13 * y + a23 * z + a[15];
          }
          return out;
        };
        mat4.scale = function(out, a, v) {
          var x = v[0],
              y = v[1],
              z = v[2];
          out[0] = a[0] * x;
          out[1] = a[1] * x;
          out[2] = a[2] * x;
          out[3] = a[3] * x;
          out[4] = a[4] * y;
          out[5] = a[5] * y;
          out[6] = a[6] * y;
          out[7] = a[7] * y;
          out[8] = a[8] * z;
          out[9] = a[9] * z;
          out[10] = a[10] * z;
          out[11] = a[11] * z;
          out[12] = a[12];
          out[13] = a[13];
          out[14] = a[14];
          out[15] = a[15];
          return out;
        };
        mat4.rotate = function(out, a, rad, axis) {
          var x = axis[0],
              y = axis[1],
              z = axis[2],
              len = Math.sqrt(x * x + y * y + z * z),
              s,
              c,
              t,
              a00,
              a01,
              a02,
              a03,
              a10,
              a11,
              a12,
              a13,
              a20,
              a21,
              a22,
              a23,
              b00,
              b01,
              b02,
              b10,
              b11,
              b12,
              b20,
              b21,
              b22;
          if (Math.abs(len) < GLMAT_EPSILON) {
            return null;
          }
          len = 1 / len;
          x *= len;
          y *= len;
          z *= len;
          s = Math.sin(rad);
          c = Math.cos(rad);
          t = 1 - c;
          a00 = a[0];
          a01 = a[1];
          a02 = a[2];
          a03 = a[3];
          a10 = a[4];
          a11 = a[5];
          a12 = a[6];
          a13 = a[7];
          a20 = a[8];
          a21 = a[9];
          a22 = a[10];
          a23 = a[11];
          b00 = x * x * t + c;
          b01 = y * x * t + z * s;
          b02 = z * x * t - y * s;
          b10 = x * y * t - z * s;
          b11 = y * y * t + c;
          b12 = z * y * t + x * s;
          b20 = x * z * t + y * s;
          b21 = y * z * t - x * s;
          b22 = z * z * t + c;
          out[0] = a00 * b00 + a10 * b01 + a20 * b02;
          out[1] = a01 * b00 + a11 * b01 + a21 * b02;
          out[2] = a02 * b00 + a12 * b01 + a22 * b02;
          out[3] = a03 * b00 + a13 * b01 + a23 * b02;
          out[4] = a00 * b10 + a10 * b11 + a20 * b12;
          out[5] = a01 * b10 + a11 * b11 + a21 * b12;
          out[6] = a02 * b10 + a12 * b11 + a22 * b12;
          out[7] = a03 * b10 + a13 * b11 + a23 * b12;
          out[8] = a00 * b20 + a10 * b21 + a20 * b22;
          out[9] = a01 * b20 + a11 * b21 + a21 * b22;
          out[10] = a02 * b20 + a12 * b21 + a22 * b22;
          out[11] = a03 * b20 + a13 * b21 + a23 * b22;
          if (a !== out) {
            out[12] = a[12];
            out[13] = a[13];
            out[14] = a[14];
            out[15] = a[15];
          }
          return out;
        };
        mat4.rotateX = function(out, a, rad) {
          var s = Math.sin(rad),
              c = Math.cos(rad),
              a10 = a[4],
              a11 = a[5],
              a12 = a[6],
              a13 = a[7],
              a20 = a[8],
              a21 = a[9],
              a22 = a[10],
              a23 = a[11];
          if (a !== out) {
            out[0] = a[0];
            out[1] = a[1];
            out[2] = a[2];
            out[3] = a[3];
            out[12] = a[12];
            out[13] = a[13];
            out[14] = a[14];
            out[15] = a[15];
          }
          out[4] = a10 * c + a20 * s;
          out[5] = a11 * c + a21 * s;
          out[6] = a12 * c + a22 * s;
          out[7] = a13 * c + a23 * s;
          out[8] = a20 * c - a10 * s;
          out[9] = a21 * c - a11 * s;
          out[10] = a22 * c - a12 * s;
          out[11] = a23 * c - a13 * s;
          return out;
        };
        mat4.rotateY = function(out, a, rad) {
          var s = Math.sin(rad),
              c = Math.cos(rad),
              a00 = a[0],
              a01 = a[1],
              a02 = a[2],
              a03 = a[3],
              a20 = a[8],
              a21 = a[9],
              a22 = a[10],
              a23 = a[11];
          if (a !== out) {
            out[4] = a[4];
            out[5] = a[5];
            out[6] = a[6];
            out[7] = a[7];
            out[12] = a[12];
            out[13] = a[13];
            out[14] = a[14];
            out[15] = a[15];
          }
          out[0] = a00 * c - a20 * s;
          out[1] = a01 * c - a21 * s;
          out[2] = a02 * c - a22 * s;
          out[3] = a03 * c - a23 * s;
          out[8] = a00 * s + a20 * c;
          out[9] = a01 * s + a21 * c;
          out[10] = a02 * s + a22 * c;
          out[11] = a03 * s + a23 * c;
          return out;
        };
        mat4.rotateZ = function(out, a, rad) {
          var s = Math.sin(rad),
              c = Math.cos(rad),
              a00 = a[0],
              a01 = a[1],
              a02 = a[2],
              a03 = a[3],
              a10 = a[4],
              a11 = a[5],
              a12 = a[6],
              a13 = a[7];
          if (a !== out) {
            out[8] = a[8];
            out[9] = a[9];
            out[10] = a[10];
            out[11] = a[11];
            out[12] = a[12];
            out[13] = a[13];
            out[14] = a[14];
            out[15] = a[15];
          }
          out[0] = a00 * c + a10 * s;
          out[1] = a01 * c + a11 * s;
          out[2] = a02 * c + a12 * s;
          out[3] = a03 * c + a13 * s;
          out[4] = a10 * c - a00 * s;
          out[5] = a11 * c - a01 * s;
          out[6] = a12 * c - a02 * s;
          out[7] = a13 * c - a03 * s;
          return out;
        };
        mat4.fromRotationTranslation = function(out, q, v) {
          var x = q[0],
              y = q[1],
              z = q[2],
              w = q[3],
              x2 = x + x,
              y2 = y + y,
              z2 = z + z,
              xx = x * x2,
              xy = x * y2,
              xz = x * z2,
              yy = y * y2,
              yz = y * z2,
              zz = z * z2,
              wx = w * x2,
              wy = w * y2,
              wz = w * z2;
          out[0] = 1 - (yy + zz);
          out[1] = xy + wz;
          out[2] = xz - wy;
          out[3] = 0;
          out[4] = xy - wz;
          out[5] = 1 - (xx + zz);
          out[6] = yz + wx;
          out[7] = 0;
          out[8] = xz + wy;
          out[9] = yz - wx;
          out[10] = 1 - (xx + yy);
          out[11] = 0;
          out[12] = v[0];
          out[13] = v[1];
          out[14] = v[2];
          out[15] = 1;
          return out;
        };
        mat4.fromQuat = function(out, q) {
          var x = q[0],
              y = q[1],
              z = q[2],
              w = q[3],
              x2 = x + x,
              y2 = y + y,
              z2 = z + z,
              xx = x * x2,
              yx = y * x2,
              yy = y * y2,
              zx = z * x2,
              zy = z * y2,
              zz = z * z2,
              wx = w * x2,
              wy = w * y2,
              wz = w * z2;
          out[0] = 1 - yy - zz;
          out[1] = yx + wz;
          out[2] = zx - wy;
          out[3] = 0;
          out[4] = yx - wz;
          out[5] = 1 - xx - zz;
          out[6] = zy + wx;
          out[7] = 0;
          out[8] = zx + wy;
          out[9] = zy - wx;
          out[10] = 1 - xx - yy;
          out[11] = 0;
          out[12] = 0;
          out[13] = 0;
          out[14] = 0;
          out[15] = 1;
          return out;
        };
        mat4.frustum = function(out, left, right, bottom, top, near, far) {
          var rl = 1 / (right - left),
              tb = 1 / (top - bottom),
              nf = 1 / (near - far);
          out[0] = (near * 2) * rl;
          out[1] = 0;
          out[2] = 0;
          out[3] = 0;
          out[4] = 0;
          out[5] = (near * 2) * tb;
          out[6] = 0;
          out[7] = 0;
          out[8] = (right + left) * rl;
          out[9] = (top + bottom) * tb;
          out[10] = (far + near) * nf;
          out[11] = -1;
          out[12] = 0;
          out[13] = 0;
          out[14] = (far * near * 2) * nf;
          out[15] = 0;
          return out;
        };
        mat4.perspective = function(out, fovy, aspect, near, far) {
          var f = 1.0 / Math.tan(fovy / 2),
              nf = 1 / (near - far);
          out[0] = f / aspect;
          out[1] = 0;
          out[2] = 0;
          out[3] = 0;
          out[4] = 0;
          out[5] = f;
          out[6] = 0;
          out[7] = 0;
          out[8] = 0;
          out[9] = 0;
          out[10] = (far + near) * nf;
          out[11] = -1;
          out[12] = 0;
          out[13] = 0;
          out[14] = (2 * far * near) * nf;
          out[15] = 0;
          return out;
        };
        mat4.ortho = function(out, left, right, bottom, top, near, far) {
          var lr = 1 / (left - right),
              bt = 1 / (bottom - top),
              nf = 1 / (near - far);
          out[0] = -2 * lr;
          out[1] = 0;
          out[2] = 0;
          out[3] = 0;
          out[4] = 0;
          out[5] = -2 * bt;
          out[6] = 0;
          out[7] = 0;
          out[8] = 0;
          out[9] = 0;
          out[10] = 2 * nf;
          out[11] = 0;
          out[12] = (left + right) * lr;
          out[13] = (top + bottom) * bt;
          out[14] = (far + near) * nf;
          out[15] = 1;
          return out;
        };
        mat4.lookAt = function(out, eye, center, up) {
          var x0,
              x1,
              x2,
              y0,
              y1,
              y2,
              z0,
              z1,
              z2,
              len,
              eyex = eye[0],
              eyey = eye[1],
              eyez = eye[2],
              upx = up[0],
              upy = up[1],
              upz = up[2],
              centerx = center[0],
              centery = center[1],
              centerz = center[2];
          if (Math.abs(eyex - centerx) < GLMAT_EPSILON && Math.abs(eyey - centery) < GLMAT_EPSILON && Math.abs(eyez - centerz) < GLMAT_EPSILON) {
            return mat4.identity(out);
          }
          z0 = eyex - centerx;
          z1 = eyey - centery;
          z2 = eyez - centerz;
          len = 1 / Math.sqrt(z0 * z0 + z1 * z1 + z2 * z2);
          z0 *= len;
          z1 *= len;
          z2 *= len;
          x0 = upy * z2 - upz * z1;
          x1 = upz * z0 - upx * z2;
          x2 = upx * z1 - upy * z0;
          len = Math.sqrt(x0 * x0 + x1 * x1 + x2 * x2);
          if (!len) {
            x0 = 0;
            x1 = 0;
            x2 = 0;
          } else {
            len = 1 / len;
            x0 *= len;
            x1 *= len;
            x2 *= len;
          }
          y0 = z1 * x2 - z2 * x1;
          y1 = z2 * x0 - z0 * x2;
          y2 = z0 * x1 - z1 * x0;
          len = Math.sqrt(y0 * y0 + y1 * y1 + y2 * y2);
          if (!len) {
            y0 = 0;
            y1 = 0;
            y2 = 0;
          } else {
            len = 1 / len;
            y0 *= len;
            y1 *= len;
            y2 *= len;
          }
          out[0] = x0;
          out[1] = y0;
          out[2] = z0;
          out[3] = 0;
          out[4] = x1;
          out[5] = y1;
          out[6] = z1;
          out[7] = 0;
          out[8] = x2;
          out[9] = y2;
          out[10] = z2;
          out[11] = 0;
          out[12] = -(x0 * eyex + x1 * eyey + x2 * eyez);
          out[13] = -(y0 * eyex + y1 * eyey + y2 * eyez);
          out[14] = -(z0 * eyex + z1 * eyey + z2 * eyez);
          out[15] = 1;
          return out;
        };
        mat4.str = function(a) {
          return 'mat4(' + a[0] + ', ' + a[1] + ', ' + a[2] + ', ' + a[3] + ', ' + a[4] + ', ' + a[5] + ', ' + a[6] + ', ' + a[7] + ', ' + a[8] + ', ' + a[9] + ', ' + a[10] + ', ' + a[11] + ', ' + a[12] + ', ' + a[13] + ', ' + a[14] + ', ' + a[15] + ')';
        };
        mat4.frob = function(a) {
          return (Math.sqrt(Math.pow(a[0], 2) + Math.pow(a[1], 2) + Math.pow(a[2], 2) + Math.pow(a[3], 2) + Math.pow(a[4], 2) + Math.pow(a[5], 2) + Math.pow(a[6], 2) + Math.pow(a[6], 2) + Math.pow(a[7], 2) + Math.pow(a[8], 2) + Math.pow(a[9], 2) + Math.pow(a[10], 2) + Math.pow(a[11], 2) + Math.pow(a[12], 2) + Math.pow(a[13], 2) + Math.pow(a[14], 2) + Math.pow(a[15], 2)));
        };
        if (typeof(exports) !== 'undefined') {
          exports.mat4 = mat4;
        }
        ;
        var quat = {};
        quat.create = function() {
          var out = new GLMAT_ARRAY_TYPE(4);
          out[0] = 0;
          out[1] = 0;
          out[2] = 0;
          out[3] = 1;
          return out;
        };
        quat.rotationTo = (function() {
          var tmpvec3 = vec3.create();
          var xUnitVec3 = vec3.fromValues(1, 0, 0);
          var yUnitVec3 = vec3.fromValues(0, 1, 0);
          return function(out, a, b) {
            var dot = vec3.dot(a, b);
            if (dot < -0.999999) {
              vec3.cross(tmpvec3, xUnitVec3, a);
              if (vec3.length(tmpvec3) < 0.000001)
                vec3.cross(tmpvec3, yUnitVec3, a);
              vec3.normalize(tmpvec3, tmpvec3);
              quat.setAxisAngle(out, tmpvec3, Math.PI);
              return out;
            } else if (dot > 0.999999) {
              out[0] = 0;
              out[1] = 0;
              out[2] = 0;
              out[3] = 1;
              return out;
            } else {
              vec3.cross(tmpvec3, a, b);
              out[0] = tmpvec3[0];
              out[1] = tmpvec3[1];
              out[2] = tmpvec3[2];
              out[3] = 1 + dot;
              return quat.normalize(out, out);
            }
          };
        })();
        quat.setAxes = (function() {
          var matr = mat3.create();
          return function(out, view, right, up) {
            matr[0] = right[0];
            matr[3] = right[1];
            matr[6] = right[2];
            matr[1] = up[0];
            matr[4] = up[1];
            matr[7] = up[2];
            matr[2] = -view[0];
            matr[5] = -view[1];
            matr[8] = -view[2];
            return quat.normalize(out, quat.fromMat3(out, matr));
          };
        })();
        quat.clone = vec4.clone;
        quat.fromValues = vec4.fromValues;
        quat.copy = vec4.copy;
        quat.set = vec4.set;
        quat.identity = function(out) {
          out[0] = 0;
          out[1] = 0;
          out[2] = 0;
          out[3] = 1;
          return out;
        };
        quat.setAxisAngle = function(out, axis, rad) {
          rad = rad * 0.5;
          var s = Math.sin(rad);
          out[0] = s * axis[0];
          out[1] = s * axis[1];
          out[2] = s * axis[2];
          out[3] = Math.cos(rad);
          return out;
        };
        quat.add = vec4.add;
        quat.multiply = function(out, a, b) {
          var ax = a[0],
              ay = a[1],
              az = a[2],
              aw = a[3],
              bx = b[0],
              by = b[1],
              bz = b[2],
              bw = b[3];
          out[0] = ax * bw + aw * bx + ay * bz - az * by;
          out[1] = ay * bw + aw * by + az * bx - ax * bz;
          out[2] = az * bw + aw * bz + ax * by - ay * bx;
          out[3] = aw * bw - ax * bx - ay * by - az * bz;
          return out;
        };
        quat.mul = quat.multiply;
        quat.scale = vec4.scale;
        quat.rotateX = function(out, a, rad) {
          rad *= 0.5;
          var ax = a[0],
              ay = a[1],
              az = a[2],
              aw = a[3],
              bx = Math.sin(rad),
              bw = Math.cos(rad);
          out[0] = ax * bw + aw * bx;
          out[1] = ay * bw + az * bx;
          out[2] = az * bw - ay * bx;
          out[3] = aw * bw - ax * bx;
          return out;
        };
        quat.rotateY = function(out, a, rad) {
          rad *= 0.5;
          var ax = a[0],
              ay = a[1],
              az = a[2],
              aw = a[3],
              by = Math.sin(rad),
              bw = Math.cos(rad);
          out[0] = ax * bw - az * by;
          out[1] = ay * bw + aw * by;
          out[2] = az * bw + ax * by;
          out[3] = aw * bw - ay * by;
          return out;
        };
        quat.rotateZ = function(out, a, rad) {
          rad *= 0.5;
          var ax = a[0],
              ay = a[1],
              az = a[2],
              aw = a[3],
              bz = Math.sin(rad),
              bw = Math.cos(rad);
          out[0] = ax * bw + ay * bz;
          out[1] = ay * bw - ax * bz;
          out[2] = az * bw + aw * bz;
          out[3] = aw * bw - az * bz;
          return out;
        };
        quat.calculateW = function(out, a) {
          var x = a[0],
              y = a[1],
              z = a[2];
          out[0] = x;
          out[1] = y;
          out[2] = z;
          out[3] = -Math.sqrt(Math.abs(1.0 - x * x - y * y - z * z));
          return out;
        };
        quat.dot = vec4.dot;
        quat.lerp = vec4.lerp;
        quat.slerp = function(out, a, b, t) {
          var ax = a[0],
              ay = a[1],
              az = a[2],
              aw = a[3],
              bx = b[0],
              by = b[1],
              bz = b[2],
              bw = b[3];
          var omega,
              cosom,
              sinom,
              scale0,
              scale1;
          cosom = ax * bx + ay * by + az * bz + aw * bw;
          if (cosom < 0.0) {
            cosom = -cosom;
            bx = -bx;
            by = -by;
            bz = -bz;
            bw = -bw;
          }
          if ((1.0 - cosom) > 0.000001) {
            omega = Math.acos(cosom);
            sinom = Math.sin(omega);
            scale0 = Math.sin((1.0 - t) * omega) / sinom;
            scale1 = Math.sin(t * omega) / sinom;
          } else {
            scale0 = 1.0 - t;
            scale1 = t;
          }
          out[0] = scale0 * ax + scale1 * bx;
          out[1] = scale0 * ay + scale1 * by;
          out[2] = scale0 * az + scale1 * bz;
          out[3] = scale0 * aw + scale1 * bw;
          return out;
        };
        quat.invert = function(out, a) {
          var a0 = a[0],
              a1 = a[1],
              a2 = a[2],
              a3 = a[3],
              dot = a0 * a0 + a1 * a1 + a2 * a2 + a3 * a3,
              invDot = dot ? 1.0 / dot : 0;
          out[0] = -a0 * invDot;
          out[1] = -a1 * invDot;
          out[2] = -a2 * invDot;
          out[3] = a3 * invDot;
          return out;
        };
        quat.conjugate = function(out, a) {
          out[0] = -a[0];
          out[1] = -a[1];
          out[2] = -a[2];
          out[3] = a[3];
          return out;
        };
        quat.length = vec4.length;
        quat.len = quat.length;
        quat.squaredLength = vec4.squaredLength;
        quat.sqrLen = quat.squaredLength;
        quat.normalize = vec4.normalize;
        quat.fromMat3 = function(out, m) {
          var fTrace = m[0] + m[4] + m[8];
          var fRoot;
          if (fTrace > 0.0) {
            fRoot = Math.sqrt(fTrace + 1.0);
            out[3] = 0.5 * fRoot;
            fRoot = 0.5 / fRoot;
            out[0] = (m[7] - m[5]) * fRoot;
            out[1] = (m[2] - m[6]) * fRoot;
            out[2] = (m[3] - m[1]) * fRoot;
          } else {
            var i = 0;
            if (m[4] > m[0])
              i = 1;
            if (m[8] > m[i * 3 + i])
              i = 2;
            var j = (i + 1) % 3;
            var k = (i + 2) % 3;
            fRoot = Math.sqrt(m[i * 3 + i] - m[j * 3 + j] - m[k * 3 + k] + 1.0);
            out[i] = 0.5 * fRoot;
            fRoot = 0.5 / fRoot;
            out[3] = (m[k * 3 + j] - m[j * 3 + k]) * fRoot;
            out[j] = (m[j * 3 + i] + m[i * 3 + j]) * fRoot;
            out[k] = (m[k * 3 + i] + m[i * 3 + k]) * fRoot;
          }
          return out;
        };
        quat.str = function(a) {
          return 'quat(' + a[0] + ', ' + a[1] + ', ' + a[2] + ', ' + a[3] + ')';
        };
        if (typeof(exports) !== 'undefined') {
          exports.quat = quat;
        }
        ;
      })(shim.exports);
    })(this);
  }).call(System.global);
  return System.get("@@global-helpers").retrieveGlobal(__module.id, "glMatrix");
});

System.register("github:mrdoob/three.js@master", ["github:mrdoob/three.js@master/build/three"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  module.exports = require("github:mrdoob/three.js@master/build/three");
  global.define = __define;
  return module.exports;
});

System.register("npm:process@0.10.1", ["npm:process@0.10.1/browser"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  module.exports = require("npm:process@0.10.1/browser");
  global.define = __define;
  return module.exports;
});

System.register("github:unconed/threestrap@0.0.9/threestrap", ["three"], false, function(__require, __exports, __module) {
  System.get("@@global-helpers").prepareGlobal(__module.id, ["three"]);
  (function() {
    "format global";
    "deps three";
    "exports THREE";
    ;
    (function() {
      var undefined;
      var arrayPool = [],
          objectPool = [];
      var idCounter = 0;
      var keyPrefix = +new Date + '';
      var largeArraySize = 75;
      var maxPoolSize = 40;
      var whitespace = (' \t\x0B\f\xA0\ufeff' + '\n\r\u2028\u2029' + '\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000');
      var reEmptyStringLeading = /\b__p \+= '';/g,
          reEmptyStringMiddle = /\b(__p \+=) '' \+/g,
          reEmptyStringTrailing = /(__e\(.*?\)|\b__t\)) \+\n'';/g;
      var reEsTemplate = /\$\{([^\\}]*(?:\\.[^\\}]*)*)\}/g;
      var reFlags = /\w*$/;
      var reFuncName = /^\s*function[ \n\r\t]+\w/;
      var reInterpolate = /<%=([\s\S]+?)%>/g;
      var reLeadingSpacesAndZeros = RegExp('^[' + whitespace + ']*0+(?=.$)');
      var reNoMatch = /($^)/;
      var reThis = /\bthis\b/;
      var reUnescapedString = /['\n\r\t\u2028\u2029\\]/g;
      var contextProps = ['Array', 'Boolean', 'Date', 'Function', 'Math', 'Number', 'Object', 'RegExp', 'String', '_', 'attachEvent', 'clearTimeout', 'isFinite', 'isNaN', 'parseInt', 'setTimeout'];
      var templateCounter = 0;
      var argsClass = '[object Arguments]',
          arrayClass = '[object Array]',
          boolClass = '[object Boolean]',
          dateClass = '[object Date]',
          funcClass = '[object Function]',
          numberClass = '[object Number]',
          objectClass = '[object Object]',
          regexpClass = '[object RegExp]',
          stringClass = '[object String]';
      var cloneableClasses = {};
      cloneableClasses[funcClass] = false;
      cloneableClasses[argsClass] = cloneableClasses[arrayClass] = cloneableClasses[boolClass] = cloneableClasses[dateClass] = cloneableClasses[numberClass] = cloneableClasses[objectClass] = cloneableClasses[regexpClass] = cloneableClasses[stringClass] = true;
      var debounceOptions = {
        'leading': false,
        'maxWait': 0,
        'trailing': false
      };
      var descriptor = {
        'configurable': false,
        'enumerable': false,
        'value': null,
        'writable': false
      };
      var objectTypes = {
        'boolean': false,
        'function': true,
        'object': true,
        'number': false,
        'string': false,
        'undefined': false
      };
      var stringEscapes = {
        '\\': '\\',
        "'": "'",
        '\n': 'n',
        '\r': 'r',
        '\t': 't',
        '\u2028': 'u2028',
        '\u2029': 'u2029'
      };
      var root = (objectTypes[typeof window] && window) || this;
      var freeExports = objectTypes[typeof exports] && exports && !exports.nodeType && exports;
      var freeModule = objectTypes[typeof module] && module && !module.nodeType && module;
      var moduleExports = freeModule && freeModule.exports === freeExports && freeExports;
      var freeGlobal = objectTypes[typeof global] && global;
      if (freeGlobal && (freeGlobal.global === freeGlobal || freeGlobal.window === freeGlobal)) {
        root = freeGlobal;
      }
      function baseIndexOf(array, value, fromIndex) {
        var index = (fromIndex || 0) - 1,
            length = array ? array.length : 0;
        while (++index < length) {
          if (array[index] === value) {
            return index;
          }
        }
        return -1;
      }
      function cacheIndexOf(cache, value) {
        var type = typeof value;
        cache = cache.cache;
        if (type == 'boolean' || value == null) {
          return cache[value] ? 0 : -1;
        }
        if (type != 'number' && type != 'string') {
          type = 'object';
        }
        var key = type == 'number' ? value : keyPrefix + value;
        cache = (cache = cache[type]) && cache[key];
        return type == 'object' ? (cache && baseIndexOf(cache, value) > -1 ? 0 : -1) : (cache ? 0 : -1);
      }
      function cachePush(value) {
        var cache = this.cache,
            type = typeof value;
        if (type == 'boolean' || value == null) {
          cache[value] = true;
        } else {
          if (type != 'number' && type != 'string') {
            type = 'object';
          }
          var key = type == 'number' ? value : keyPrefix + value,
              typeCache = cache[type] || (cache[type] = {});
          if (type == 'object') {
            (typeCache[key] || (typeCache[key] = [])).push(value);
          } else {
            typeCache[key] = true;
          }
        }
      }
      function charAtCallback(value) {
        return value.charCodeAt(0);
      }
      function compareAscending(a, b) {
        var ac = a.criteria,
            bc = b.criteria,
            index = -1,
            length = ac.length;
        while (++index < length) {
          var value = ac[index],
              other = bc[index];
          if (value !== other) {
            if (value > other || typeof value == 'undefined') {
              return 1;
            }
            if (value < other || typeof other == 'undefined') {
              return -1;
            }
          }
        }
        return a.index - b.index;
      }
      function createCache(array) {
        var index = -1,
            length = array.length,
            first = array[0],
            mid = array[(length / 2) | 0],
            last = array[length - 1];
        if (first && typeof first == 'object' && mid && typeof mid == 'object' && last && typeof last == 'object') {
          return false;
        }
        var cache = getObject();
        cache['false'] = cache['null'] = cache['true'] = cache['undefined'] = false;
        var result = getObject();
        result.array = array;
        result.cache = cache;
        result.push = cachePush;
        while (++index < length) {
          result.push(array[index]);
        }
        return result;
      }
      function escapeStringChar(match) {
        return '\\' + stringEscapes[match];
      }
      function getArray() {
        return arrayPool.pop() || [];
      }
      function getObject() {
        return objectPool.pop() || {
          'array': null,
          'cache': null,
          'criteria': null,
          'false': false,
          'index': 0,
          'null': false,
          'number': null,
          'object': null,
          'push': null,
          'string': null,
          'true': false,
          'undefined': false,
          'value': null
        };
      }
      function releaseArray(array) {
        array.length = 0;
        if (arrayPool.length < maxPoolSize) {
          arrayPool.push(array);
        }
      }
      function releaseObject(object) {
        var cache = object.cache;
        if (cache) {
          releaseObject(cache);
        }
        object.array = object.cache = object.criteria = object.object = object.number = object.string = object.value = null;
        if (objectPool.length < maxPoolSize) {
          objectPool.push(object);
        }
      }
      function slice(array, start, end) {
        start || (start = 0);
        if (typeof end == 'undefined') {
          end = array ? array.length : 0;
        }
        var index = -1,
            length = end - start || 0,
            result = Array(length < 0 ? 0 : length);
        while (++index < length) {
          result[index] = array[start + index];
        }
        return result;
      }
      function runInContext(context) {
        context = context ? _.defaults(root.Object(), context, _.pick(root, contextProps)) : root;
        var Array = context.Array,
            Boolean = context.Boolean,
            Date = context.Date,
            Function = context.Function,
            Math = context.Math,
            Number = context.Number,
            Object = context.Object,
            RegExp = context.RegExp,
            String = context.String,
            TypeError = context.TypeError;
        var arrayRef = [];
        var objectProto = Object.prototype;
        var oldDash = context._;
        var toString = objectProto.toString;
        var reNative = RegExp('^' + String(toString).replace(/[.*+?^${}()|[\]\\]/g, '\\$&').replace(/toString| for [^\]]+/g, '.*?') + '$');
        var ceil = Math.ceil,
            clearTimeout = context.clearTimeout,
            floor = Math.floor,
            fnToString = Function.prototype.toString,
            getPrototypeOf = isNative(getPrototypeOf = Object.getPrototypeOf) && getPrototypeOf,
            hasOwnProperty = objectProto.hasOwnProperty,
            push = arrayRef.push,
            setTimeout = context.setTimeout,
            splice = arrayRef.splice,
            unshift = arrayRef.unshift;
        var defineProperty = (function() {
          try {
            var o = {},
                func = isNative(func = Object.defineProperty) && func,
                result = func(o, o, o) && func;
          } catch (e) {}
          return result;
        }());
        var nativeCreate = isNative(nativeCreate = Object.create) && nativeCreate,
            nativeIsArray = isNative(nativeIsArray = Array.isArray) && nativeIsArray,
            nativeIsFinite = context.isFinite,
            nativeIsNaN = context.isNaN,
            nativeKeys = isNative(nativeKeys = Object.keys) && nativeKeys,
            nativeMax = Math.max,
            nativeMin = Math.min,
            nativeParseInt = context.parseInt,
            nativeRandom = Math.random;
        var ctorByClass = {};
        ctorByClass[arrayClass] = Array;
        ctorByClass[boolClass] = Boolean;
        ctorByClass[dateClass] = Date;
        ctorByClass[funcClass] = Function;
        ctorByClass[objectClass] = Object;
        ctorByClass[numberClass] = Number;
        ctorByClass[regexpClass] = RegExp;
        ctorByClass[stringClass] = String;
        function lodash(value) {
          return (value && typeof value == 'object' && !isArray(value) && hasOwnProperty.call(value, '__wrapped__')) ? value : new lodashWrapper(value);
        }
        function lodashWrapper(value, chainAll) {
          this.__chain__ = !!chainAll;
          this.__wrapped__ = value;
        }
        lodashWrapper.prototype = lodash.prototype;
        var support = lodash.support = {};
        support.funcDecomp = !isNative(context.WinRTError) && reThis.test(runInContext);
        support.funcNames = typeof Function.name == 'string';
        lodash.templateSettings = {
          'escape': /<%-([\s\S]+?)%>/g,
          'evaluate': /<%([\s\S]+?)%>/g,
          'interpolate': reInterpolate,
          'variable': '',
          'imports': {'_': lodash}
        };
        function baseBind(bindData) {
          var func = bindData[0],
              partialArgs = bindData[2],
              thisArg = bindData[4];
          function bound() {
            if (partialArgs) {
              var args = slice(partialArgs);
              push.apply(args, arguments);
            }
            if (this instanceof bound) {
              var thisBinding = baseCreate(func.prototype),
                  result = func.apply(thisBinding, args || arguments);
              return isObject(result) ? result : thisBinding;
            }
            return func.apply(thisArg, args || arguments);
          }
          setBindData(bound, bindData);
          return bound;
        }
        function baseClone(value, isDeep, callback, stackA, stackB) {
          if (callback) {
            var result = callback(value);
            if (typeof result != 'undefined') {
              return result;
            }
          }
          var isObj = isObject(value);
          if (isObj) {
            var className = toString.call(value);
            if (!cloneableClasses[className]) {
              return value;
            }
            var ctor = ctorByClass[className];
            switch (className) {
              case boolClass:
              case dateClass:
                return new ctor(+value);
              case numberClass:
              case stringClass:
                return new ctor(value);
              case regexpClass:
                result = ctor(value.source, reFlags.exec(value));
                result.lastIndex = value.lastIndex;
                return result;
            }
          } else {
            return value;
          }
          var isArr = isArray(value);
          if (isDeep) {
            var initedStack = !stackA;
            stackA || (stackA = getArray());
            stackB || (stackB = getArray());
            var length = stackA.length;
            while (length--) {
              if (stackA[length] == value) {
                return stackB[length];
              }
            }
            result = isArr ? ctor(value.length) : {};
          } else {
            result = isArr ? slice(value) : assign({}, value);
          }
          if (isArr) {
            if (hasOwnProperty.call(value, 'index')) {
              result.index = value.index;
            }
            if (hasOwnProperty.call(value, 'input')) {
              result.input = value.input;
            }
          }
          if (!isDeep) {
            return result;
          }
          stackA.push(value);
          stackB.push(result);
          (isArr ? forEach : forOwn)(value, function(objValue, key) {
            result[key] = baseClone(objValue, isDeep, callback, stackA, stackB);
          });
          if (initedStack) {
            releaseArray(stackA);
            releaseArray(stackB);
          }
          return result;
        }
        function baseCreate(prototype, properties) {
          return isObject(prototype) ? nativeCreate(prototype) : {};
        }
        if (!nativeCreate) {
          baseCreate = (function() {
            function Object() {}
            return function(prototype) {
              if (isObject(prototype)) {
                Object.prototype = prototype;
                var result = new Object;
                Object.prototype = null;
              }
              return result || context.Object();
            };
          }());
        }
        function baseCreateCallback(func, thisArg, argCount) {
          if (typeof func != 'function') {
            return identity;
          }
          if (typeof thisArg == 'undefined' || !('prototype' in func)) {
            return func;
          }
          var bindData = func.__bindData__;
          if (typeof bindData == 'undefined') {
            if (support.funcNames) {
              bindData = !func.name;
            }
            bindData = bindData || !support.funcDecomp;
            if (!bindData) {
              var source = fnToString.call(func);
              if (!support.funcNames) {
                bindData = !reFuncName.test(source);
              }
              if (!bindData) {
                bindData = reThis.test(source);
                setBindData(func, bindData);
              }
            }
          }
          if (bindData === false || (bindData !== true && bindData[1] & 1)) {
            return func;
          }
          switch (argCount) {
            case 1:
              return function(value) {
                return func.call(thisArg, value);
              };
            case 2:
              return function(a, b) {
                return func.call(thisArg, a, b);
              };
            case 3:
              return function(value, index, collection) {
                return func.call(thisArg, value, index, collection);
              };
            case 4:
              return function(accumulator, value, index, collection) {
                return func.call(thisArg, accumulator, value, index, collection);
              };
          }
          return bind(func, thisArg);
        }
        function baseCreateWrapper(bindData) {
          var func = bindData[0],
              bitmask = bindData[1],
              partialArgs = bindData[2],
              partialRightArgs = bindData[3],
              thisArg = bindData[4],
              arity = bindData[5];
          var isBind = bitmask & 1,
              isBindKey = bitmask & 2,
              isCurry = bitmask & 4,
              isCurryBound = bitmask & 8,
              key = func;
          function bound() {
            var thisBinding = isBind ? thisArg : this;
            if (partialArgs) {
              var args = slice(partialArgs);
              push.apply(args, arguments);
            }
            if (partialRightArgs || isCurry) {
              args || (args = slice(arguments));
              if (partialRightArgs) {
                push.apply(args, partialRightArgs);
              }
              if (isCurry && args.length < arity) {
                bitmask |= 16 & ~32;
                return baseCreateWrapper([func, (isCurryBound ? bitmask : bitmask & ~3), args, null, thisArg, arity]);
              }
            }
            args || (args = arguments);
            if (isBindKey) {
              func = thisBinding[key];
            }
            if (this instanceof bound) {
              thisBinding = baseCreate(func.prototype);
              var result = func.apply(thisBinding, args);
              return isObject(result) ? result : thisBinding;
            }
            return func.apply(thisBinding, args);
          }
          setBindData(bound, bindData);
          return bound;
        }
        function baseDifference(array, values) {
          var index = -1,
              indexOf = getIndexOf(),
              length = array ? array.length : 0,
              isLarge = length >= largeArraySize && indexOf === baseIndexOf,
              result = [];
          if (isLarge) {
            var cache = createCache(values);
            if (cache) {
              indexOf = cacheIndexOf;
              values = cache;
            } else {
              isLarge = false;
            }
          }
          while (++index < length) {
            var value = array[index];
            if (indexOf(values, value) < 0) {
              result.push(value);
            }
          }
          if (isLarge) {
            releaseObject(values);
          }
          return result;
        }
        function baseFlatten(array, isShallow, isStrict, fromIndex) {
          var index = (fromIndex || 0) - 1,
              length = array ? array.length : 0,
              result = [];
          while (++index < length) {
            var value = array[index];
            if (value && typeof value == 'object' && typeof value.length == 'number' && (isArray(value) || isArguments(value))) {
              if (!isShallow) {
                value = baseFlatten(value, isShallow, isStrict);
              }
              var valIndex = -1,
                  valLength = value.length,
                  resIndex = result.length;
              result.length += valLength;
              while (++valIndex < valLength) {
                result[resIndex++] = value[valIndex];
              }
            } else if (!isStrict) {
              result.push(value);
            }
          }
          return result;
        }
        function baseIsEqual(a, b, callback, isWhere, stackA, stackB) {
          if (callback) {
            var result = callback(a, b);
            if (typeof result != 'undefined') {
              return !!result;
            }
          }
          if (a === b) {
            return a !== 0 || (1 / a == 1 / b);
          }
          var type = typeof a,
              otherType = typeof b;
          if (a === a && !(a && objectTypes[type]) && !(b && objectTypes[otherType])) {
            return false;
          }
          if (a == null || b == null) {
            return a === b;
          }
          var className = toString.call(a),
              otherClass = toString.call(b);
          if (className == argsClass) {
            className = objectClass;
          }
          if (otherClass == argsClass) {
            otherClass = objectClass;
          }
          if (className != otherClass) {
            return false;
          }
          switch (className) {
            case boolClass:
            case dateClass:
              return +a == +b;
            case numberClass:
              return (a != +a) ? b != +b : (a == 0 ? (1 / a == 1 / b) : a == +b);
            case regexpClass:
            case stringClass:
              return a == String(b);
          }
          var isArr = className == arrayClass;
          if (!isArr) {
            var aWrapped = hasOwnProperty.call(a, '__wrapped__'),
                bWrapped = hasOwnProperty.call(b, '__wrapped__');
            if (aWrapped || bWrapped) {
              return baseIsEqual(aWrapped ? a.__wrapped__ : a, bWrapped ? b.__wrapped__ : b, callback, isWhere, stackA, stackB);
            }
            if (className != objectClass) {
              return false;
            }
            var ctorA = a.constructor,
                ctorB = b.constructor;
            if (ctorA != ctorB && !(isFunction(ctorA) && ctorA instanceof ctorA && isFunction(ctorB) && ctorB instanceof ctorB) && ('constructor' in a && 'constructor' in b)) {
              return false;
            }
          }
          var initedStack = !stackA;
          stackA || (stackA = getArray());
          stackB || (stackB = getArray());
          var length = stackA.length;
          while (length--) {
            if (stackA[length] == a) {
              return stackB[length] == b;
            }
          }
          var size = 0;
          result = true;
          stackA.push(a);
          stackB.push(b);
          if (isArr) {
            length = a.length;
            size = b.length;
            result = size == length;
            if (result || isWhere) {
              while (size--) {
                var index = length,
                    value = b[size];
                if (isWhere) {
                  while (index--) {
                    if ((result = baseIsEqual(a[index], value, callback, isWhere, stackA, stackB))) {
                      break;
                    }
                  }
                } else if (!(result = baseIsEqual(a[size], value, callback, isWhere, stackA, stackB))) {
                  break;
                }
              }
            }
          } else {
            forIn(b, function(value, key, b) {
              if (hasOwnProperty.call(b, key)) {
                size++;
                return (result = hasOwnProperty.call(a, key) && baseIsEqual(a[key], value, callback, isWhere, stackA, stackB));
              }
            });
            if (result && !isWhere) {
              forIn(a, function(value, key, a) {
                if (hasOwnProperty.call(a, key)) {
                  return (result = --size > -1);
                }
              });
            }
          }
          stackA.pop();
          stackB.pop();
          if (initedStack) {
            releaseArray(stackA);
            releaseArray(stackB);
          }
          return result;
        }
        function baseMerge(object, source, callback, stackA, stackB) {
          (isArray(source) ? forEach : forOwn)(source, function(source, key) {
            var found,
                isArr,
                result = source,
                value = object[key];
            if (source && ((isArr = isArray(source)) || isPlainObject(source))) {
              var stackLength = stackA.length;
              while (stackLength--) {
                if ((found = stackA[stackLength] == source)) {
                  value = stackB[stackLength];
                  break;
                }
              }
              if (!found) {
                var isShallow;
                if (callback) {
                  result = callback(value, source);
                  if ((isShallow = typeof result != 'undefined')) {
                    value = result;
                  }
                }
                if (!isShallow) {
                  value = isArr ? (isArray(value) ? value : []) : (isPlainObject(value) ? value : {});
                }
                stackA.push(source);
                stackB.push(value);
                if (!isShallow) {
                  baseMerge(value, source, callback, stackA, stackB);
                }
              }
            } else {
              if (callback) {
                result = callback(value, source);
                if (typeof result == 'undefined') {
                  result = source;
                }
              }
              if (typeof result != 'undefined') {
                value = result;
              }
            }
            object[key] = value;
          });
        }
        function baseRandom(min, max) {
          return min + floor(nativeRandom() * (max - min + 1));
        }
        function baseUniq(array, isSorted, callback) {
          var index = -1,
              indexOf = getIndexOf(),
              length = array ? array.length : 0,
              result = [];
          var isLarge = !isSorted && length >= largeArraySize && indexOf === baseIndexOf,
              seen = (callback || isLarge) ? getArray() : result;
          if (isLarge) {
            var cache = createCache(seen);
            indexOf = cacheIndexOf;
            seen = cache;
          }
          while (++index < length) {
            var value = array[index],
                computed = callback ? callback(value, index, array) : value;
            if (isSorted ? !index || seen[seen.length - 1] !== computed : indexOf(seen, computed) < 0) {
              if (callback || isLarge) {
                seen.push(computed);
              }
              result.push(value);
            }
          }
          if (isLarge) {
            releaseArray(seen.array);
            releaseObject(seen);
          } else if (callback) {
            releaseArray(seen);
          }
          return result;
        }
        function createAggregator(setter) {
          return function(collection, callback, thisArg) {
            var result = {};
            callback = lodash.createCallback(callback, thisArg, 3);
            var index = -1,
                length = collection ? collection.length : 0;
            if (typeof length == 'number') {
              while (++index < length) {
                var value = collection[index];
                setter(result, value, callback(value, index, collection), collection);
              }
            } else {
              forOwn(collection, function(value, key, collection) {
                setter(result, value, callback(value, key, collection), collection);
              });
            }
            return result;
          };
        }
        function createWrapper(func, bitmask, partialArgs, partialRightArgs, thisArg, arity) {
          var isBind = bitmask & 1,
              isBindKey = bitmask & 2,
              isCurry = bitmask & 4,
              isCurryBound = bitmask & 8,
              isPartial = bitmask & 16,
              isPartialRight = bitmask & 32;
          if (!isBindKey && !isFunction(func)) {
            throw new TypeError;
          }
          if (isPartial && !partialArgs.length) {
            bitmask &= ~16;
            isPartial = partialArgs = false;
          }
          if (isPartialRight && !partialRightArgs.length) {
            bitmask &= ~32;
            isPartialRight = partialRightArgs = false;
          }
          var bindData = func && func.__bindData__;
          if (bindData && bindData !== true) {
            bindData = slice(bindData);
            if (bindData[2]) {
              bindData[2] = slice(bindData[2]);
            }
            if (bindData[3]) {
              bindData[3] = slice(bindData[3]);
            }
            if (isBind && !(bindData[1] & 1)) {
              bindData[4] = thisArg;
            }
            if (!isBind && bindData[1] & 1) {
              bitmask |= 8;
            }
            if (isCurry && !(bindData[1] & 4)) {
              bindData[5] = arity;
            }
            if (isPartial) {
              push.apply(bindData[2] || (bindData[2] = []), partialArgs);
            }
            if (isPartialRight) {
              unshift.apply(bindData[3] || (bindData[3] = []), partialRightArgs);
            }
            bindData[1] |= bitmask;
            return createWrapper.apply(null, bindData);
          }
          var creater = (bitmask == 1 || bitmask === 17) ? baseBind : baseCreateWrapper;
          return creater([func, bitmask, partialArgs, partialRightArgs, thisArg, arity]);
        }
        function escapeHtmlChar(match) {
          return htmlEscapes[match];
        }
        function getIndexOf() {
          var result = (result = lodash.indexOf) === indexOf ? baseIndexOf : result;
          return result;
        }
        function isNative(value) {
          return typeof value == 'function' && reNative.test(value);
        }
        var setBindData = !defineProperty ? noop : function(func, value) {
          descriptor.value = value;
          defineProperty(func, '__bindData__', descriptor);
        };
        function shimIsPlainObject(value) {
          var ctor,
              result;
          if (!(value && toString.call(value) == objectClass) || (ctor = value.constructor, isFunction(ctor) && !(ctor instanceof ctor))) {
            return false;
          }
          forIn(value, function(value, key) {
            result = key;
          });
          return typeof result == 'undefined' || hasOwnProperty.call(value, result);
        }
        function unescapeHtmlChar(match) {
          return htmlUnescapes[match];
        }
        function isArguments(value) {
          return value && typeof value == 'object' && typeof value.length == 'number' && toString.call(value) == argsClass || false;
        }
        var isArray = nativeIsArray || function(value) {
          return value && typeof value == 'object' && typeof value.length == 'number' && toString.call(value) == arrayClass || false;
        };
        var shimKeys = function(object) {
          var index,
              iterable = object,
              result = [];
          if (!iterable)
            return result;
          if (!(objectTypes[typeof object]))
            return result;
          for (index in iterable) {
            if (hasOwnProperty.call(iterable, index)) {
              result.push(index);
            }
          }
          return result;
        };
        var keys = !nativeKeys ? shimKeys : function(object) {
          if (!isObject(object)) {
            return [];
          }
          return nativeKeys(object);
        };
        var htmlEscapes = {
          '&': '&amp;',
          '<': '&lt;',
          '>': '&gt;',
          '"': '&quot;',
          "'": '&#39;'
        };
        var htmlUnescapes = invert(htmlEscapes);
        var reEscapedHtml = RegExp('(' + keys(htmlUnescapes).join('|') + ')', 'g'),
            reUnescapedHtml = RegExp('[' + keys(htmlEscapes).join('') + ']', 'g');
        var assign = function(object, source, guard) {
          var index,
              iterable = object,
              result = iterable;
          if (!iterable)
            return result;
          var args = arguments,
              argsIndex = 0,
              argsLength = typeof guard == 'number' ? 2 : args.length;
          if (argsLength > 3 && typeof args[argsLength - 2] == 'function') {
            var callback = baseCreateCallback(args[--argsLength - 1], args[argsLength--], 2);
          } else if (argsLength > 2 && typeof args[argsLength - 1] == 'function') {
            callback = args[--argsLength];
          }
          while (++argsIndex < argsLength) {
            iterable = args[argsIndex];
            if (iterable && objectTypes[typeof iterable]) {
              var ownIndex = -1,
                  ownProps = objectTypes[typeof iterable] && keys(iterable),
                  length = ownProps ? ownProps.length : 0;
              while (++ownIndex < length) {
                index = ownProps[ownIndex];
                result[index] = callback ? callback(result[index], iterable[index]) : iterable[index];
              }
            }
          }
          return result;
        };
        function clone(value, isDeep, callback, thisArg) {
          if (typeof isDeep != 'boolean' && isDeep != null) {
            thisArg = callback;
            callback = isDeep;
            isDeep = false;
          }
          return baseClone(value, isDeep, typeof callback == 'function' && baseCreateCallback(callback, thisArg, 1));
        }
        function cloneDeep(value, callback, thisArg) {
          return baseClone(value, true, typeof callback == 'function' && baseCreateCallback(callback, thisArg, 1));
        }
        function create(prototype, properties) {
          var result = baseCreate(prototype);
          return properties ? assign(result, properties) : result;
        }
        var defaults = function(object, source, guard) {
          var index,
              iterable = object,
              result = iterable;
          if (!iterable)
            return result;
          var args = arguments,
              argsIndex = 0,
              argsLength = typeof guard == 'number' ? 2 : args.length;
          while (++argsIndex < argsLength) {
            iterable = args[argsIndex];
            if (iterable && objectTypes[typeof iterable]) {
              var ownIndex = -1,
                  ownProps = objectTypes[typeof iterable] && keys(iterable),
                  length = ownProps ? ownProps.length : 0;
              while (++ownIndex < length) {
                index = ownProps[ownIndex];
                if (typeof result[index] == 'undefined')
                  result[index] = iterable[index];
              }
            }
          }
          return result;
        };
        function findKey(object, callback, thisArg) {
          var result;
          callback = lodash.createCallback(callback, thisArg, 3);
          forOwn(object, function(value, key, object) {
            if (callback(value, key, object)) {
              result = key;
              return false;
            }
          });
          return result;
        }
        function findLastKey(object, callback, thisArg) {
          var result;
          callback = lodash.createCallback(callback, thisArg, 3);
          forOwnRight(object, function(value, key, object) {
            if (callback(value, key, object)) {
              result = key;
              return false;
            }
          });
          return result;
        }
        var forIn = function(collection, callback, thisArg) {
          var index,
              iterable = collection,
              result = iterable;
          if (!iterable)
            return result;
          if (!objectTypes[typeof iterable])
            return result;
          callback = callback && typeof thisArg == 'undefined' ? callback : baseCreateCallback(callback, thisArg, 3);
          for (index in iterable) {
            if (callback(iterable[index], index, collection) === false)
              return result;
          }
          return result;
        };
        function forInRight(object, callback, thisArg) {
          var pairs = [];
          forIn(object, function(value, key) {
            pairs.push(key, value);
          });
          var length = pairs.length;
          callback = baseCreateCallback(callback, thisArg, 3);
          while (length--) {
            if (callback(pairs[length--], pairs[length], object) === false) {
              break;
            }
          }
          return object;
        }
        var forOwn = function(collection, callback, thisArg) {
          var index,
              iterable = collection,
              result = iterable;
          if (!iterable)
            return result;
          if (!objectTypes[typeof iterable])
            return result;
          callback = callback && typeof thisArg == 'undefined' ? callback : baseCreateCallback(callback, thisArg, 3);
          var ownIndex = -1,
              ownProps = objectTypes[typeof iterable] && keys(iterable),
              length = ownProps ? ownProps.length : 0;
          while (++ownIndex < length) {
            index = ownProps[ownIndex];
            if (callback(iterable[index], index, collection) === false)
              return result;
          }
          return result;
        };
        function forOwnRight(object, callback, thisArg) {
          var props = keys(object),
              length = props.length;
          callback = baseCreateCallback(callback, thisArg, 3);
          while (length--) {
            var key = props[length];
            if (callback(object[key], key, object) === false) {
              break;
            }
          }
          return object;
        }
        function functions(object) {
          var result = [];
          forIn(object, function(value, key) {
            if (isFunction(value)) {
              result.push(key);
            }
          });
          return result.sort();
        }
        function has(object, key) {
          return object ? hasOwnProperty.call(object, key) : false;
        }
        function invert(object) {
          var index = -1,
              props = keys(object),
              length = props.length,
              result = {};
          while (++index < length) {
            var key = props[index];
            result[object[key]] = key;
          }
          return result;
        }
        function isBoolean(value) {
          return value === true || value === false || value && typeof value == 'object' && toString.call(value) == boolClass || false;
        }
        function isDate(value) {
          return value && typeof value == 'object' && toString.call(value) == dateClass || false;
        }
        function isElement(value) {
          return value && value.nodeType === 1 || false;
        }
        function isEmpty(value) {
          var result = true;
          if (!value) {
            return result;
          }
          var className = toString.call(value),
              length = value.length;
          if ((className == arrayClass || className == stringClass || className == argsClass) || (className == objectClass && typeof length == 'number' && isFunction(value.splice))) {
            return !length;
          }
          forOwn(value, function() {
            return (result = false);
          });
          return result;
        }
        function isEqual(a, b, callback, thisArg) {
          return baseIsEqual(a, b, typeof callback == 'function' && baseCreateCallback(callback, thisArg, 2));
        }
        function isFinite(value) {
          return nativeIsFinite(value) && !nativeIsNaN(parseFloat(value));
        }
        function isFunction(value) {
          return typeof value == 'function';
        }
        function isObject(value) {
          return !!(value && objectTypes[typeof value]);
        }
        function isNaN(value) {
          return isNumber(value) && value != +value;
        }
        function isNull(value) {
          return value === null;
        }
        function isNumber(value) {
          return typeof value == 'number' || value && typeof value == 'object' && toString.call(value) == numberClass || false;
        }
        var isPlainObject = !getPrototypeOf ? shimIsPlainObject : function(value) {
          if (!(value && toString.call(value) == objectClass)) {
            return false;
          }
          var valueOf = value.valueOf,
              objProto = isNative(valueOf) && (objProto = getPrototypeOf(valueOf)) && getPrototypeOf(objProto);
          return objProto ? (value == objProto || getPrototypeOf(value) == objProto) : shimIsPlainObject(value);
        };
        function isRegExp(value) {
          return value && typeof value == 'object' && toString.call(value) == regexpClass || false;
        }
        function isString(value) {
          return typeof value == 'string' || value && typeof value == 'object' && toString.call(value) == stringClass || false;
        }
        function isUndefined(value) {
          return typeof value == 'undefined';
        }
        function mapValues(object, callback, thisArg) {
          var result = {};
          callback = lodash.createCallback(callback, thisArg, 3);
          forOwn(object, function(value, key, object) {
            result[key] = callback(value, key, object);
          });
          return result;
        }
        function merge(object) {
          var args = arguments,
              length = 2;
          if (!isObject(object)) {
            return object;
          }
          if (typeof args[2] != 'number') {
            length = args.length;
          }
          if (length > 3 && typeof args[length - 2] == 'function') {
            var callback = baseCreateCallback(args[--length - 1], args[length--], 2);
          } else if (length > 2 && typeof args[length - 1] == 'function') {
            callback = args[--length];
          }
          var sources = slice(arguments, 1, length),
              index = -1,
              stackA = getArray(),
              stackB = getArray();
          while (++index < length) {
            baseMerge(object, sources[index], callback, stackA, stackB);
          }
          releaseArray(stackA);
          releaseArray(stackB);
          return object;
        }
        function omit(object, callback, thisArg) {
          var result = {};
          if (typeof callback != 'function') {
            var props = [];
            forIn(object, function(value, key) {
              props.push(key);
            });
            props = baseDifference(props, baseFlatten(arguments, true, false, 1));
            var index = -1,
                length = props.length;
            while (++index < length) {
              var key = props[index];
              result[key] = object[key];
            }
          } else {
            callback = lodash.createCallback(callback, thisArg, 3);
            forIn(object, function(value, key, object) {
              if (!callback(value, key, object)) {
                result[key] = value;
              }
            });
          }
          return result;
        }
        function pairs(object) {
          var index = -1,
              props = keys(object),
              length = props.length,
              result = Array(length);
          while (++index < length) {
            var key = props[index];
            result[index] = [key, object[key]];
          }
          return result;
        }
        function pick(object, callback, thisArg) {
          var result = {};
          if (typeof callback != 'function') {
            var index = -1,
                props = baseFlatten(arguments, true, false, 1),
                length = isObject(object) ? props.length : 0;
            while (++index < length) {
              var key = props[index];
              if (key in object) {
                result[key] = object[key];
              }
            }
          } else {
            callback = lodash.createCallback(callback, thisArg, 3);
            forIn(object, function(value, key, object) {
              if (callback(value, key, object)) {
                result[key] = value;
              }
            });
          }
          return result;
        }
        function transform(object, callback, accumulator, thisArg) {
          var isArr = isArray(object);
          if (accumulator == null) {
            if (isArr) {
              accumulator = [];
            } else {
              var ctor = object && object.constructor,
                  proto = ctor && ctor.prototype;
              accumulator = baseCreate(proto);
            }
          }
          if (callback) {
            callback = lodash.createCallback(callback, thisArg, 4);
            (isArr ? forEach : forOwn)(object, function(value, index, object) {
              return callback(accumulator, value, index, object);
            });
          }
          return accumulator;
        }
        function values(object) {
          var index = -1,
              props = keys(object),
              length = props.length,
              result = Array(length);
          while (++index < length) {
            result[index] = object[props[index]];
          }
          return result;
        }
        function at(collection) {
          var args = arguments,
              index = -1,
              props = baseFlatten(args, true, false, 1),
              length = (args[2] && args[2][args[1]] === collection) ? 1 : props.length,
              result = Array(length);
          while (++index < length) {
            result[index] = collection[props[index]];
          }
          return result;
        }
        function contains(collection, target, fromIndex) {
          var index = -1,
              indexOf = getIndexOf(),
              length = collection ? collection.length : 0,
              result = false;
          fromIndex = (fromIndex < 0 ? nativeMax(0, length + fromIndex) : fromIndex) || 0;
          if (isArray(collection)) {
            result = indexOf(collection, target, fromIndex) > -1;
          } else if (typeof length == 'number') {
            result = (isString(collection) ? collection.indexOf(target, fromIndex) : indexOf(collection, target, fromIndex)) > -1;
          } else {
            forOwn(collection, function(value) {
              if (++index >= fromIndex) {
                return !(result = value === target);
              }
            });
          }
          return result;
        }
        var countBy = createAggregator(function(result, value, key) {
          (hasOwnProperty.call(result, key) ? result[key]++ : result[key] = 1);
        });
        function every(collection, callback, thisArg) {
          var result = true;
          callback = lodash.createCallback(callback, thisArg, 3);
          var index = -1,
              length = collection ? collection.length : 0;
          if (typeof length == 'number') {
            while (++index < length) {
              if (!(result = !!callback(collection[index], index, collection))) {
                break;
              }
            }
          } else {
            forOwn(collection, function(value, index, collection) {
              return (result = !!callback(value, index, collection));
            });
          }
          return result;
        }
        function filter(collection, callback, thisArg) {
          var result = [];
          callback = lodash.createCallback(callback, thisArg, 3);
          var index = -1,
              length = collection ? collection.length : 0;
          if (typeof length == 'number') {
            while (++index < length) {
              var value = collection[index];
              if (callback(value, index, collection)) {
                result.push(value);
              }
            }
          } else {
            forOwn(collection, function(value, index, collection) {
              if (callback(value, index, collection)) {
                result.push(value);
              }
            });
          }
          return result;
        }
        function find(collection, callback, thisArg) {
          callback = lodash.createCallback(callback, thisArg, 3);
          var index = -1,
              length = collection ? collection.length : 0;
          if (typeof length == 'number') {
            while (++index < length) {
              var value = collection[index];
              if (callback(value, index, collection)) {
                return value;
              }
            }
          } else {
            var result;
            forOwn(collection, function(value, index, collection) {
              if (callback(value, index, collection)) {
                result = value;
                return false;
              }
            });
            return result;
          }
        }
        function findLast(collection, callback, thisArg) {
          var result;
          callback = lodash.createCallback(callback, thisArg, 3);
          forEachRight(collection, function(value, index, collection) {
            if (callback(value, index, collection)) {
              result = value;
              return false;
            }
          });
          return result;
        }
        function forEach(collection, callback, thisArg) {
          var index = -1,
              length = collection ? collection.length : 0;
          callback = callback && typeof thisArg == 'undefined' ? callback : baseCreateCallback(callback, thisArg, 3);
          if (typeof length == 'number') {
            while (++index < length) {
              if (callback(collection[index], index, collection) === false) {
                break;
              }
            }
          } else {
            forOwn(collection, callback);
          }
          return collection;
        }
        function forEachRight(collection, callback, thisArg) {
          var length = collection ? collection.length : 0;
          callback = callback && typeof thisArg == 'undefined' ? callback : baseCreateCallback(callback, thisArg, 3);
          if (typeof length == 'number') {
            while (length--) {
              if (callback(collection[length], length, collection) === false) {
                break;
              }
            }
          } else {
            var props = keys(collection);
            length = props.length;
            forOwn(collection, function(value, key, collection) {
              key = props ? props[--length] : --length;
              return callback(collection[key], key, collection);
            });
          }
          return collection;
        }
        var groupBy = createAggregator(function(result, value, key) {
          (hasOwnProperty.call(result, key) ? result[key] : result[key] = []).push(value);
        });
        var indexBy = createAggregator(function(result, value, key) {
          result[key] = value;
        });
        function invoke(collection, methodName) {
          var args = slice(arguments, 2),
              index = -1,
              isFunc = typeof methodName == 'function',
              length = collection ? collection.length : 0,
              result = Array(typeof length == 'number' ? length : 0);
          forEach(collection, function(value) {
            result[++index] = (isFunc ? methodName : value[methodName]).apply(value, args);
          });
          return result;
        }
        function map(collection, callback, thisArg) {
          var index = -1,
              length = collection ? collection.length : 0;
          callback = lodash.createCallback(callback, thisArg, 3);
          if (typeof length == 'number') {
            var result = Array(length);
            while (++index < length) {
              result[index] = callback(collection[index], index, collection);
            }
          } else {
            result = [];
            forOwn(collection, function(value, key, collection) {
              result[++index] = callback(value, key, collection);
            });
          }
          return result;
        }
        function max(collection, callback, thisArg) {
          var computed = -Infinity,
              result = computed;
          if (typeof callback != 'function' && thisArg && thisArg[callback] === collection) {
            callback = null;
          }
          if (callback == null && isArray(collection)) {
            var index = -1,
                length = collection.length;
            while (++index < length) {
              var value = collection[index];
              if (value > result) {
                result = value;
              }
            }
          } else {
            callback = (callback == null && isString(collection)) ? charAtCallback : lodash.createCallback(callback, thisArg, 3);
            forEach(collection, function(value, index, collection) {
              var current = callback(value, index, collection);
              if (current > computed) {
                computed = current;
                result = value;
              }
            });
          }
          return result;
        }
        function min(collection, callback, thisArg) {
          var computed = Infinity,
              result = computed;
          if (typeof callback != 'function' && thisArg && thisArg[callback] === collection) {
            callback = null;
          }
          if (callback == null && isArray(collection)) {
            var index = -1,
                length = collection.length;
            while (++index < length) {
              var value = collection[index];
              if (value < result) {
                result = value;
              }
            }
          } else {
            callback = (callback == null && isString(collection)) ? charAtCallback : lodash.createCallback(callback, thisArg, 3);
            forEach(collection, function(value, index, collection) {
              var current = callback(value, index, collection);
              if (current < computed) {
                computed = current;
                result = value;
              }
            });
          }
          return result;
        }
        var pluck = map;
        function reduce(collection, callback, accumulator, thisArg) {
          if (!collection)
            return accumulator;
          var noaccum = arguments.length < 3;
          callback = lodash.createCallback(callback, thisArg, 4);
          var index = -1,
              length = collection.length;
          if (typeof length == 'number') {
            if (noaccum) {
              accumulator = collection[++index];
            }
            while (++index < length) {
              accumulator = callback(accumulator, collection[index], index, collection);
            }
          } else {
            forOwn(collection, function(value, index, collection) {
              accumulator = noaccum ? (noaccum = false, value) : callback(accumulator, value, index, collection);
            });
          }
          return accumulator;
        }
        function reduceRight(collection, callback, accumulator, thisArg) {
          var noaccum = arguments.length < 3;
          callback = lodash.createCallback(callback, thisArg, 4);
          forEachRight(collection, function(value, index, collection) {
            accumulator = noaccum ? (noaccum = false, value) : callback(accumulator, value, index, collection);
          });
          return accumulator;
        }
        function reject(collection, callback, thisArg) {
          callback = lodash.createCallback(callback, thisArg, 3);
          return filter(collection, function(value, index, collection) {
            return !callback(value, index, collection);
          });
        }
        function sample(collection, n, guard) {
          if (collection && typeof collection.length != 'number') {
            collection = values(collection);
          }
          if (n == null || guard) {
            return collection ? collection[baseRandom(0, collection.length - 1)] : undefined;
          }
          var result = shuffle(collection);
          result.length = nativeMin(nativeMax(0, n), result.length);
          return result;
        }
        function shuffle(collection) {
          var index = -1,
              length = collection ? collection.length : 0,
              result = Array(typeof length == 'number' ? length : 0);
          forEach(collection, function(value) {
            var rand = baseRandom(0, ++index);
            result[index] = result[rand];
            result[rand] = value;
          });
          return result;
        }
        function size(collection) {
          var length = collection ? collection.length : 0;
          return typeof length == 'number' ? length : keys(collection).length;
        }
        function some(collection, callback, thisArg) {
          var result;
          callback = lodash.createCallback(callback, thisArg, 3);
          var index = -1,
              length = collection ? collection.length : 0;
          if (typeof length == 'number') {
            while (++index < length) {
              if ((result = callback(collection[index], index, collection))) {
                break;
              }
            }
          } else {
            forOwn(collection, function(value, index, collection) {
              return !(result = callback(value, index, collection));
            });
          }
          return !!result;
        }
        function sortBy(collection, callback, thisArg) {
          var index = -1,
              isArr = isArray(callback),
              length = collection ? collection.length : 0,
              result = Array(typeof length == 'number' ? length : 0);
          if (!isArr) {
            callback = lodash.createCallback(callback, thisArg, 3);
          }
          forEach(collection, function(value, key, collection) {
            var object = result[++index] = getObject();
            if (isArr) {
              object.criteria = map(callback, function(key) {
                return value[key];
              });
            } else {
              (object.criteria = getArray())[0] = callback(value, key, collection);
            }
            object.index = index;
            object.value = value;
          });
          length = result.length;
          result.sort(compareAscending);
          while (length--) {
            var object = result[length];
            result[length] = object.value;
            if (!isArr) {
              releaseArray(object.criteria);
            }
            releaseObject(object);
          }
          return result;
        }
        function toArray(collection) {
          if (collection && typeof collection.length == 'number') {
            return slice(collection);
          }
          return values(collection);
        }
        var where = filter;
        function compact(array) {
          var index = -1,
              length = array ? array.length : 0,
              result = [];
          while (++index < length) {
            var value = array[index];
            if (value) {
              result.push(value);
            }
          }
          return result;
        }
        function difference(array) {
          return baseDifference(array, baseFlatten(arguments, true, true, 1));
        }
        function findIndex(array, callback, thisArg) {
          var index = -1,
              length = array ? array.length : 0;
          callback = lodash.createCallback(callback, thisArg, 3);
          while (++index < length) {
            if (callback(array[index], index, array)) {
              return index;
            }
          }
          return -1;
        }
        function findLastIndex(array, callback, thisArg) {
          var length = array ? array.length : 0;
          callback = lodash.createCallback(callback, thisArg, 3);
          while (length--) {
            if (callback(array[length], length, array)) {
              return length;
            }
          }
          return -1;
        }
        function first(array, callback, thisArg) {
          var n = 0,
              length = array ? array.length : 0;
          if (typeof callback != 'number' && callback != null) {
            var index = -1;
            callback = lodash.createCallback(callback, thisArg, 3);
            while (++index < length && callback(array[index], index, array)) {
              n++;
            }
          } else {
            n = callback;
            if (n == null || thisArg) {
              return array ? array[0] : undefined;
            }
          }
          return slice(array, 0, nativeMin(nativeMax(0, n), length));
        }
        function flatten(array, isShallow, callback, thisArg) {
          if (typeof isShallow != 'boolean' && isShallow != null) {
            thisArg = callback;
            callback = (typeof isShallow != 'function' && thisArg && thisArg[isShallow] === array) ? null : isShallow;
            isShallow = false;
          }
          if (callback != null) {
            array = map(array, callback, thisArg);
          }
          return baseFlatten(array, isShallow);
        }
        function indexOf(array, value, fromIndex) {
          if (typeof fromIndex == 'number') {
            var length = array ? array.length : 0;
            fromIndex = (fromIndex < 0 ? nativeMax(0, length + fromIndex) : fromIndex || 0);
          } else if (fromIndex) {
            var index = sortedIndex(array, value);
            return array[index] === value ? index : -1;
          }
          return baseIndexOf(array, value, fromIndex);
        }
        function initial(array, callback, thisArg) {
          var n = 0,
              length = array ? array.length : 0;
          if (typeof callback != 'number' && callback != null) {
            var index = length;
            callback = lodash.createCallback(callback, thisArg, 3);
            while (index-- && callback(array[index], index, array)) {
              n++;
            }
          } else {
            n = (callback == null || thisArg) ? 1 : callback || n;
          }
          return slice(array, 0, nativeMin(nativeMax(0, length - n), length));
        }
        function intersection() {
          var args = [],
              argsIndex = -1,
              argsLength = arguments.length,
              caches = getArray(),
              indexOf = getIndexOf(),
              trustIndexOf = indexOf === baseIndexOf,
              seen = getArray();
          while (++argsIndex < argsLength) {
            var value = arguments[argsIndex];
            if (isArray(value) || isArguments(value)) {
              args.push(value);
              caches.push(trustIndexOf && value.length >= largeArraySize && createCache(argsIndex ? args[argsIndex] : seen));
            }
          }
          var array = args[0],
              index = -1,
              length = array ? array.length : 0,
              result = [];
          outer: while (++index < length) {
            var cache = caches[0];
            value = array[index];
            if ((cache ? cacheIndexOf(cache, value) : indexOf(seen, value)) < 0) {
              argsIndex = argsLength;
              (cache || seen).push(value);
              while (--argsIndex) {
                cache = caches[argsIndex];
                if ((cache ? cacheIndexOf(cache, value) : indexOf(args[argsIndex], value)) < 0) {
                  continue outer;
                }
              }
              result.push(value);
            }
          }
          while (argsLength--) {
            cache = caches[argsLength];
            if (cache) {
              releaseObject(cache);
            }
          }
          releaseArray(caches);
          releaseArray(seen);
          return result;
        }
        function last(array, callback, thisArg) {
          var n = 0,
              length = array ? array.length : 0;
          if (typeof callback != 'number' && callback != null) {
            var index = length;
            callback = lodash.createCallback(callback, thisArg, 3);
            while (index-- && callback(array[index], index, array)) {
              n++;
            }
          } else {
            n = callback;
            if (n == null || thisArg) {
              return array ? array[length - 1] : undefined;
            }
          }
          return slice(array, nativeMax(0, length - n));
        }
        function lastIndexOf(array, value, fromIndex) {
          var index = array ? array.length : 0;
          if (typeof fromIndex == 'number') {
            index = (fromIndex < 0 ? nativeMax(0, index + fromIndex) : nativeMin(fromIndex, index - 1)) + 1;
          }
          while (index--) {
            if (array[index] === value) {
              return index;
            }
          }
          return -1;
        }
        function pull(array) {
          var args = arguments,
              argsIndex = 0,
              argsLength = args.length,
              length = array ? array.length : 0;
          while (++argsIndex < argsLength) {
            var index = -1,
                value = args[argsIndex];
            while (++index < length) {
              if (array[index] === value) {
                splice.call(array, index--, 1);
                length--;
              }
            }
          }
          return array;
        }
        function range(start, end, step) {
          start = +start || 0;
          step = typeof step == 'number' ? step : (+step || 1);
          if (end == null) {
            end = start;
            start = 0;
          }
          var index = -1,
              length = nativeMax(0, ceil((end - start) / (step || 1))),
              result = Array(length);
          while (++index < length) {
            result[index] = start;
            start += step;
          }
          return result;
        }
        function remove(array, callback, thisArg) {
          var index = -1,
              length = array ? array.length : 0,
              result = [];
          callback = lodash.createCallback(callback, thisArg, 3);
          while (++index < length) {
            var value = array[index];
            if (callback(value, index, array)) {
              result.push(value);
              splice.call(array, index--, 1);
              length--;
            }
          }
          return result;
        }
        function rest(array, callback, thisArg) {
          if (typeof callback != 'number' && callback != null) {
            var n = 0,
                index = -1,
                length = array ? array.length : 0;
            callback = lodash.createCallback(callback, thisArg, 3);
            while (++index < length && callback(array[index], index, array)) {
              n++;
            }
          } else {
            n = (callback == null || thisArg) ? 1 : nativeMax(0, callback);
          }
          return slice(array, n);
        }
        function sortedIndex(array, value, callback, thisArg) {
          var low = 0,
              high = array ? array.length : low;
          callback = callback ? lodash.createCallback(callback, thisArg, 1) : identity;
          value = callback(value);
          while (low < high) {
            var mid = (low + high) >>> 1;
            (callback(array[mid]) < value) ? low = mid + 1 : high = mid;
          }
          return low;
        }
        function union() {
          return baseUniq(baseFlatten(arguments, true, true));
        }
        function uniq(array, isSorted, callback, thisArg) {
          if (typeof isSorted != 'boolean' && isSorted != null) {
            thisArg = callback;
            callback = (typeof isSorted != 'function' && thisArg && thisArg[isSorted] === array) ? null : isSorted;
            isSorted = false;
          }
          if (callback != null) {
            callback = lodash.createCallback(callback, thisArg, 3);
          }
          return baseUniq(array, isSorted, callback);
        }
        function without(array) {
          return baseDifference(array, slice(arguments, 1));
        }
        function xor() {
          var index = -1,
              length = arguments.length;
          while (++index < length) {
            var array = arguments[index];
            if (isArray(array) || isArguments(array)) {
              var result = result ? baseUniq(baseDifference(result, array).concat(baseDifference(array, result))) : array;
            }
          }
          return result || [];
        }
        function zip() {
          var array = arguments.length > 1 ? arguments : arguments[0],
              index = -1,
              length = array ? max(pluck(array, 'length')) : 0,
              result = Array(length < 0 ? 0 : length);
          while (++index < length) {
            result[index] = pluck(array, index);
          }
          return result;
        }
        function zipObject(keys, values) {
          var index = -1,
              length = keys ? keys.length : 0,
              result = {};
          if (!values && length && !isArray(keys[0])) {
            values = [];
          }
          while (++index < length) {
            var key = keys[index];
            if (values) {
              result[key] = values[index];
            } else if (key) {
              result[key[0]] = key[1];
            }
          }
          return result;
        }
        function after(n, func) {
          if (!isFunction(func)) {
            throw new TypeError;
          }
          return function() {
            if (--n < 1) {
              return func.apply(this, arguments);
            }
          };
        }
        function bind(func, thisArg) {
          return arguments.length > 2 ? createWrapper(func, 17, slice(arguments, 2), null, thisArg) : createWrapper(func, 1, null, null, thisArg);
        }
        function bindAll(object) {
          var funcs = arguments.length > 1 ? baseFlatten(arguments, true, false, 1) : functions(object),
              index = -1,
              length = funcs.length;
          while (++index < length) {
            var key = funcs[index];
            object[key] = createWrapper(object[key], 1, null, null, object);
          }
          return object;
        }
        function bindKey(object, key) {
          return arguments.length > 2 ? createWrapper(key, 19, slice(arguments, 2), null, object) : createWrapper(key, 3, null, null, object);
        }
        function compose() {
          var funcs = arguments,
              length = funcs.length;
          while (length--) {
            if (!isFunction(funcs[length])) {
              throw new TypeError;
            }
          }
          return function() {
            var args = arguments,
                length = funcs.length;
            while (length--) {
              args = [funcs[length].apply(this, args)];
            }
            return args[0];
          };
        }
        function curry(func, arity) {
          arity = typeof arity == 'number' ? arity : (+arity || func.length);
          return createWrapper(func, 4, null, null, null, arity);
        }
        function debounce(func, wait, options) {
          var args,
              maxTimeoutId,
              result,
              stamp,
              thisArg,
              timeoutId,
              trailingCall,
              lastCalled = 0,
              maxWait = false,
              trailing = true;
          if (!isFunction(func)) {
            throw new TypeError;
          }
          wait = nativeMax(0, wait) || 0;
          if (options === true) {
            var leading = true;
            trailing = false;
          } else if (isObject(options)) {
            leading = options.leading;
            maxWait = 'maxWait' in options && (nativeMax(wait, options.maxWait) || 0);
            trailing = 'trailing' in options ? options.trailing : trailing;
          }
          var delayed = function() {
            var remaining = wait - (now() - stamp);
            if (remaining <= 0) {
              if (maxTimeoutId) {
                clearTimeout(maxTimeoutId);
              }
              var isCalled = trailingCall;
              maxTimeoutId = timeoutId = trailingCall = undefined;
              if (isCalled) {
                lastCalled = now();
                result = func.apply(thisArg, args);
                if (!timeoutId && !maxTimeoutId) {
                  args = thisArg = null;
                }
              }
            } else {
              timeoutId = setTimeout(delayed, remaining);
            }
          };
          var maxDelayed = function() {
            if (timeoutId) {
              clearTimeout(timeoutId);
            }
            maxTimeoutId = timeoutId = trailingCall = undefined;
            if (trailing || (maxWait !== wait)) {
              lastCalled = now();
              result = func.apply(thisArg, args);
              if (!timeoutId && !maxTimeoutId) {
                args = thisArg = null;
              }
            }
          };
          return function() {
            args = arguments;
            stamp = now();
            thisArg = this;
            trailingCall = trailing && (timeoutId || !leading);
            if (maxWait === false) {
              var leadingCall = leading && !timeoutId;
            } else {
              if (!maxTimeoutId && !leading) {
                lastCalled = stamp;
              }
              var remaining = maxWait - (stamp - lastCalled),
                  isCalled = remaining <= 0;
              if (isCalled) {
                if (maxTimeoutId) {
                  maxTimeoutId = clearTimeout(maxTimeoutId);
                }
                lastCalled = stamp;
                result = func.apply(thisArg, args);
              } else if (!maxTimeoutId) {
                maxTimeoutId = setTimeout(maxDelayed, remaining);
              }
            }
            if (isCalled && timeoutId) {
              timeoutId = clearTimeout(timeoutId);
            } else if (!timeoutId && wait !== maxWait) {
              timeoutId = setTimeout(delayed, wait);
            }
            if (leadingCall) {
              isCalled = true;
              result = func.apply(thisArg, args);
            }
            if (isCalled && !timeoutId && !maxTimeoutId) {
              args = thisArg = null;
            }
            return result;
          };
        }
        function defer(func) {
          if (!isFunction(func)) {
            throw new TypeError;
          }
          var args = slice(arguments, 1);
          return setTimeout(function() {
            func.apply(undefined, args);
          }, 1);
        }
        function delay(func, wait) {
          if (!isFunction(func)) {
            throw new TypeError;
          }
          var args = slice(arguments, 2);
          return setTimeout(function() {
            func.apply(undefined, args);
          }, wait);
        }
        function memoize(func, resolver) {
          if (!isFunction(func)) {
            throw new TypeError;
          }
          var memoized = function() {
            var cache = memoized.cache,
                key = resolver ? resolver.apply(this, arguments) : keyPrefix + arguments[0];
            return hasOwnProperty.call(cache, key) ? cache[key] : (cache[key] = func.apply(this, arguments));
          };
          memoized.cache = {};
          return memoized;
        }
        function once(func) {
          var ran,
              result;
          if (!isFunction(func)) {
            throw new TypeError;
          }
          return function() {
            if (ran) {
              return result;
            }
            ran = true;
            result = func.apply(this, arguments);
            func = null;
            return result;
          };
        }
        function partial(func) {
          return createWrapper(func, 16, slice(arguments, 1));
        }
        function partialRight(func) {
          return createWrapper(func, 32, null, slice(arguments, 1));
        }
        function throttle(func, wait, options) {
          var leading = true,
              trailing = true;
          if (!isFunction(func)) {
            throw new TypeError;
          }
          if (options === false) {
            leading = false;
          } else if (isObject(options)) {
            leading = 'leading' in options ? options.leading : leading;
            trailing = 'trailing' in options ? options.trailing : trailing;
          }
          debounceOptions.leading = leading;
          debounceOptions.maxWait = wait;
          debounceOptions.trailing = trailing;
          return debounce(func, wait, debounceOptions);
        }
        function wrap(value, wrapper) {
          return createWrapper(wrapper, 16, [value]);
        }
        function constant(value) {
          return function() {
            return value;
          };
        }
        function createCallback(func, thisArg, argCount) {
          var type = typeof func;
          if (func == null || type == 'function') {
            return baseCreateCallback(func, thisArg, argCount);
          }
          if (type != 'object') {
            return property(func);
          }
          var props = keys(func),
              key = props[0],
              a = func[key];
          if (props.length == 1 && a === a && !isObject(a)) {
            return function(object) {
              var b = object[key];
              return a === b && (a !== 0 || (1 / a == 1 / b));
            };
          }
          return function(object) {
            var length = props.length,
                result = false;
            while (length--) {
              if (!(result = baseIsEqual(object[props[length]], func[props[length]], null, true))) {
                break;
              }
            }
            return result;
          };
        }
        function escape(string) {
          return string == null ? '' : String(string).replace(reUnescapedHtml, escapeHtmlChar);
        }
        function identity(value) {
          return value;
        }
        function mixin(object, source, options) {
          var chain = true,
              methodNames = source && functions(source);
          if (!source || (!options && !methodNames.length)) {
            if (options == null) {
              options = source;
            }
            ctor = lodashWrapper;
            source = object;
            object = lodash;
            methodNames = functions(source);
          }
          if (options === false) {
            chain = false;
          } else if (isObject(options) && 'chain' in options) {
            chain = options.chain;
          }
          var ctor = object,
              isFunc = isFunction(ctor);
          forEach(methodNames, function(methodName) {
            var func = object[methodName] = source[methodName];
            if (isFunc) {
              ctor.prototype[methodName] = function() {
                var chainAll = this.__chain__,
                    value = this.__wrapped__,
                    args = [value];
                push.apply(args, arguments);
                var result = func.apply(object, args);
                if (chain || chainAll) {
                  if (value === result && isObject(result)) {
                    return this;
                  }
                  result = new ctor(result);
                  result.__chain__ = chainAll;
                }
                return result;
              };
            }
          });
        }
        function noConflict() {
          context._ = oldDash;
          return this;
        }
        function noop() {}
        var now = isNative(now = Date.now) && now || function() {
          return new Date().getTime();
        };
        var parseInt = nativeParseInt(whitespace + '08') == 8 ? nativeParseInt : function(value, radix) {
          return nativeParseInt(isString(value) ? value.replace(reLeadingSpacesAndZeros, '') : value, radix || 0);
        };
        function property(key) {
          return function(object) {
            return object[key];
          };
        }
        function random(min, max, floating) {
          var noMin = min == null,
              noMax = max == null;
          if (floating == null) {
            if (typeof min == 'boolean' && noMax) {
              floating = min;
              min = 1;
            } else if (!noMax && typeof max == 'boolean') {
              floating = max;
              noMax = true;
            }
          }
          if (noMin && noMax) {
            max = 1;
          }
          min = +min || 0;
          if (noMax) {
            max = min;
            min = 0;
          } else {
            max = +max || 0;
          }
          if (floating || min % 1 || max % 1) {
            var rand = nativeRandom();
            return nativeMin(min + (rand * (max - min + parseFloat('1e-' + ((rand + '').length - 1)))), max);
          }
          return baseRandom(min, max);
        }
        function result(object, key) {
          if (object) {
            var value = object[key];
            return isFunction(value) ? object[key]() : value;
          }
        }
        function template(text, data, options) {
          var settings = lodash.templateSettings;
          text = String(text || '');
          options = defaults({}, options, settings);
          var imports = defaults({}, options.imports, settings.imports),
              importsKeys = keys(imports),
              importsValues = values(imports);
          var isEvaluating,
              index = 0,
              interpolate = options.interpolate || reNoMatch,
              source = "__p += '";
          var reDelimiters = RegExp((options.escape || reNoMatch).source + '|' + interpolate.source + '|' + (interpolate === reInterpolate ? reEsTemplate : reNoMatch).source + '|' + (options.evaluate || reNoMatch).source + '|$', 'g');
          text.replace(reDelimiters, function(match, escapeValue, interpolateValue, esTemplateValue, evaluateValue, offset) {
            interpolateValue || (interpolateValue = esTemplateValue);
            source += text.slice(index, offset).replace(reUnescapedString, escapeStringChar);
            if (escapeValue) {
              source += "' +\n__e(" + escapeValue + ") +\n'";
            }
            if (evaluateValue) {
              isEvaluating = true;
              source += "';\n" + evaluateValue + ";\n__p += '";
            }
            if (interpolateValue) {
              source += "' +\n((__t = (" + interpolateValue + ")) == null ? '' : __t) +\n'";
            }
            index = offset + match.length;
            return match;
          });
          source += "';\n";
          var variable = options.variable,
              hasVariable = variable;
          if (!hasVariable) {
            variable = 'obj';
            source = 'with (' + variable + ') {\n' + source + '\n}\n';
          }
          source = (isEvaluating ? source.replace(reEmptyStringLeading, '') : source).replace(reEmptyStringMiddle, '$1').replace(reEmptyStringTrailing, '$1;');
          source = 'function(' + variable + ') {\n' + (hasVariable ? '' : variable + ' || (' + variable + ' = {});\n') + "var __t, __p = '', __e = _.escape" + (isEvaluating ? ', __j = Array.prototype.join;\n' + "function print() { __p += __j.call(arguments, '') }\n" : ';\n') + source + 'return __p\n}';
          var sourceURL = '\n/*\n//# sourceURL=' + (options.sourceURL || '/lodash/template/source[' + (templateCounter++) + ']') + '\n*/';
          try {
            var result = Function(importsKeys, 'return ' + source + sourceURL).apply(undefined, importsValues);
          } catch (e) {
            e.source = source;
            throw e;
          }
          if (data) {
            return result(data);
          }
          result.source = source;
          return result;
        }
        function times(n, callback, thisArg) {
          n = (n = +n) > -1 ? n : 0;
          var index = -1,
              result = Array(n);
          callback = baseCreateCallback(callback, thisArg, 1);
          while (++index < n) {
            result[index] = callback(index);
          }
          return result;
        }
        function unescape(string) {
          return string == null ? '' : String(string).replace(reEscapedHtml, unescapeHtmlChar);
        }
        function uniqueId(prefix) {
          var id = ++idCounter;
          return String(prefix == null ? '' : prefix) + id;
        }
        function chain(value) {
          value = new lodashWrapper(value);
          value.__chain__ = true;
          return value;
        }
        function tap(value, interceptor) {
          interceptor(value);
          return value;
        }
        function wrapperChain() {
          this.__chain__ = true;
          return this;
        }
        function wrapperToString() {
          return String(this.__wrapped__);
        }
        function wrapperValueOf() {
          return this.__wrapped__;
        }
        lodash.after = after;
        lodash.assign = assign;
        lodash.at = at;
        lodash.bind = bind;
        lodash.bindAll = bindAll;
        lodash.bindKey = bindKey;
        lodash.chain = chain;
        lodash.compact = compact;
        lodash.compose = compose;
        lodash.constant = constant;
        lodash.countBy = countBy;
        lodash.create = create;
        lodash.createCallback = createCallback;
        lodash.curry = curry;
        lodash.debounce = debounce;
        lodash.defaults = defaults;
        lodash.defer = defer;
        lodash.delay = delay;
        lodash.difference = difference;
        lodash.filter = filter;
        lodash.flatten = flatten;
        lodash.forEach = forEach;
        lodash.forEachRight = forEachRight;
        lodash.forIn = forIn;
        lodash.forInRight = forInRight;
        lodash.forOwn = forOwn;
        lodash.forOwnRight = forOwnRight;
        lodash.functions = functions;
        lodash.groupBy = groupBy;
        lodash.indexBy = indexBy;
        lodash.initial = initial;
        lodash.intersection = intersection;
        lodash.invert = invert;
        lodash.invoke = invoke;
        lodash.keys = keys;
        lodash.map = map;
        lodash.mapValues = mapValues;
        lodash.max = max;
        lodash.memoize = memoize;
        lodash.merge = merge;
        lodash.min = min;
        lodash.omit = omit;
        lodash.once = once;
        lodash.pairs = pairs;
        lodash.partial = partial;
        lodash.partialRight = partialRight;
        lodash.pick = pick;
        lodash.pluck = pluck;
        lodash.property = property;
        lodash.pull = pull;
        lodash.range = range;
        lodash.reject = reject;
        lodash.remove = remove;
        lodash.rest = rest;
        lodash.shuffle = shuffle;
        lodash.sortBy = sortBy;
        lodash.tap = tap;
        lodash.throttle = throttle;
        lodash.times = times;
        lodash.toArray = toArray;
        lodash.transform = transform;
        lodash.union = union;
        lodash.uniq = uniq;
        lodash.values = values;
        lodash.where = where;
        lodash.without = without;
        lodash.wrap = wrap;
        lodash.xor = xor;
        lodash.zip = zip;
        lodash.zipObject = zipObject;
        lodash.collect = map;
        lodash.drop = rest;
        lodash.each = forEach;
        lodash.eachRight = forEachRight;
        lodash.extend = assign;
        lodash.methods = functions;
        lodash.object = zipObject;
        lodash.select = filter;
        lodash.tail = rest;
        lodash.unique = uniq;
        lodash.unzip = zip;
        mixin(lodash);
        lodash.clone = clone;
        lodash.cloneDeep = cloneDeep;
        lodash.contains = contains;
        lodash.escape = escape;
        lodash.every = every;
        lodash.find = find;
        lodash.findIndex = findIndex;
        lodash.findKey = findKey;
        lodash.findLast = findLast;
        lodash.findLastIndex = findLastIndex;
        lodash.findLastKey = findLastKey;
        lodash.has = has;
        lodash.identity = identity;
        lodash.indexOf = indexOf;
        lodash.isArguments = isArguments;
        lodash.isArray = isArray;
        lodash.isBoolean = isBoolean;
        lodash.isDate = isDate;
        lodash.isElement = isElement;
        lodash.isEmpty = isEmpty;
        lodash.isEqual = isEqual;
        lodash.isFinite = isFinite;
        lodash.isFunction = isFunction;
        lodash.isNaN = isNaN;
        lodash.isNull = isNull;
        lodash.isNumber = isNumber;
        lodash.isObject = isObject;
        lodash.isPlainObject = isPlainObject;
        lodash.isRegExp = isRegExp;
        lodash.isString = isString;
        lodash.isUndefined = isUndefined;
        lodash.lastIndexOf = lastIndexOf;
        lodash.mixin = mixin;
        lodash.noConflict = noConflict;
        lodash.noop = noop;
        lodash.now = now;
        lodash.parseInt = parseInt;
        lodash.random = random;
        lodash.reduce = reduce;
        lodash.reduceRight = reduceRight;
        lodash.result = result;
        lodash.runInContext = runInContext;
        lodash.size = size;
        lodash.some = some;
        lodash.sortedIndex = sortedIndex;
        lodash.template = template;
        lodash.unescape = unescape;
        lodash.uniqueId = uniqueId;
        lodash.all = every;
        lodash.any = some;
        lodash.detect = find;
        lodash.findWhere = find;
        lodash.foldl = reduce;
        lodash.foldr = reduceRight;
        lodash.include = contains;
        lodash.inject = reduce;
        mixin(function() {
          var source = {};
          forOwn(lodash, function(func, methodName) {
            if (!lodash.prototype[methodName]) {
              source[methodName] = func;
            }
          });
          return source;
        }(), false);
        lodash.first = first;
        lodash.last = last;
        lodash.sample = sample;
        lodash.take = first;
        lodash.head = first;
        forOwn(lodash, function(func, methodName) {
          var callbackable = methodName !== 'sample';
          if (!lodash.prototype[methodName]) {
            lodash.prototype[methodName] = function(n, guard) {
              var chainAll = this.__chain__,
                  result = func(this.__wrapped__, n, guard);
              return !chainAll && (n == null || (guard && !(callbackable && typeof n == 'function'))) ? result : new lodashWrapper(result, chainAll);
            };
          }
        });
        lodash.VERSION = '2.4.1';
        lodash.prototype.chain = wrapperChain;
        lodash.prototype.toString = wrapperToString;
        lodash.prototype.value = wrapperValueOf;
        lodash.prototype.valueOf = wrapperValueOf;
        forEach(['join', 'pop', 'shift'], function(methodName) {
          var func = arrayRef[methodName];
          lodash.prototype[methodName] = function() {
            var chainAll = this.__chain__,
                result = func.apply(this.__wrapped__, arguments);
            return chainAll ? new lodashWrapper(result, chainAll) : result;
          };
        });
        forEach(['push', 'reverse', 'sort', 'unshift'], function(methodName) {
          var func = arrayRef[methodName];
          lodash.prototype[methodName] = function() {
            func.apply(this.__wrapped__, arguments);
            return this;
          };
        });
        forEach(['concat', 'slice', 'splice'], function(methodName) {
          var func = arrayRef[methodName];
          lodash.prototype[methodName] = function() {
            return new lodashWrapper(func.apply(this.__wrapped__, arguments), this.__chain__);
          };
        });
        return lodash;
      }
      var _ = runInContext();
      if (typeof define == 'function' && typeof define.amd == 'object' && define.amd) {
        root._ = _;
        define(function() {
          return _;
        });
      } else if (freeExports && freeModule) {
        if (moduleExports) {
          (freeModule.exports = _)._ = _;
        } else {
          freeExports._ = _;
        }
      } else {
        root._ = _;
      }
    }.call(this));
    THREE.Binder = {
      bind: function(context, globals) {
        return function(key, object) {
          if (!object.__binds) {
            object.__binds = [];
          }
          var fallback = context;
          if (_.isArray(key)) {
            fallback = key[0];
            key = key[1];
          }
          var match = /^([^.:]*(?:\.[^.:]+)*)?(?:\:(.*))?$/.exec(key);
          var path = match[1].split(/\./g);
          var name = path.pop();
          var dest = match[2] || name;
          var selector = path.shift();
          var target = {'this': object}[selector] || globals[selector] || context[selector] || fallback;
          while (target && (key = path.shift())) {
            target = target[key];
          }
          ;
          if (target && (target.on || target.addEventListener)) {
            var callback = function(event) {
              object[dest] && object[dest](event, context);
            };
            THREE.Binder._polyfill(target, ['addEventListener', 'on'], function(method) {
              target[method](name, callback);
            });
            var bind = {
              target: target,
              name: name,
              callback: callback
            };
            object.__binds.push(bind);
            return callback;
          } else {
            throw "Cannot bind '" + key + "' in " + this.__name;
          }
        };
      },
      unbind: function() {
        return function(object) {
          if (object.__binds) {
            object.__binds.forEach(function(bind) {
              THREE.Binder._polyfill(bind.target, ['removeEventListener', 'off'], function(method) {
                bind.target[method](bind.name, bind.callback);
              });
            }.bind(this));
            object.__binds = [];
          }
        };
      },
      apply: function(object) {
        THREE.EventDispatcher.prototype.apply(object);
        object.trigger = THREE.Binder._trigger;
        object.triggerOnce = THREE.Binder._triggerOnce;
        object.on = object.addEventListener;
        object.off = object.removeEventListener;
        object.dispatchEvent = object.trigger;
      },
      _triggerOnce: function(event) {
        this.trigger(event);
        if (this._listeners) {
          delete this._listeners[event.type];
        }
      },
      _trigger: function(event) {
        if (this._listeners === undefined)
          return ;
        var type = event.type;
        var listeners = this._listeners[type];
        if (listeners !== undefined) {
          listeners = listeners.slice();
          var length = listeners.length;
          event.target = this;
          for (var i = 0; i < length; i++) {
            listeners[i].call(this, event, this);
          }
        }
      },
      _polyfill: function(object, methods, callback) {
        methods.map(function(method) {
          return object.method;
        });
        if (methods.length)
          callback(methods[0]);
      }
    };
    THREE.Api = {apply: function(object) {
        object.set = function(options) {
          var o = this.options || {};
          var changes = _.reduce(options, function(result, value, key) {
            if (o[key] !== value)
              result[key] = value;
            return result;
          }, {});
          this.options = _.extend(o, changes);
          this.trigger({
            type: 'change',
            options: options,
            changes: changes
          });
        };
        object.get = function() {
          return this.options;
        };
        object.api = function(object, context) {
          object = object || {};
          context && _.each(object, function(callback, key, object) {
            if (_.isFunction(callback)) {
              object[key] = _.partialRight(callback, context);
            }
          });
          object.set = this.set.bind(this);
          object.get = this.get.bind(this);
          return object;
        };
      }};
    THREE.Bootstrap = function(options) {
      if (options) {
        args = [].slice.apply(arguments);
        options = {};
        if (args[0] instanceof Node) {
          node = args[0];
          args = args.slice(1);
          options.element = node;
        }
        if (_.isString(args[0])) {
          options.plugins = args;
        }
        if (_.isArray(args[0])) {
          options.plugins = args[0];
        }
        if (args[0]) {
          options = _.defaults(options, args[0]);
        }
      }
      if (!(this instanceof THREE.Bootstrap))
        return new THREE.Bootstrap(options);
      var defaults = {
        init: true,
        element: document.body,
        plugins: ['core'],
        aliases: {},
        plugindb: THREE.Bootstrap.Plugins || {},
        aliasdb: THREE.Bootstrap.Aliases || {}
      };
      this.__options = _.defaults(options || {}, defaults);
      this.__inited = false;
      this.__destroyed = false;
      this.__installed = [];
      this.plugins = {};
      this.element = this.__options.element;
      if (this.__options.init) {
        this.init();
      }
    };
    THREE.Bootstrap.prototype = {
      init: function() {
        if (this.__inited)
          return ;
        this.__inited = true;
        this.install(this.__options.plugins);
        return this;
      },
      destroy: function() {
        if (!this.__inited)
          return ;
        if (this.__destroyed)
          return ;
        this.__destroyed = true;
        this.trigger({type: 'destroy'});
        this.uninstall();
        return this;
      },
      resolve: function(plugins) {
        plugins = _.isArray(plugins) ? plugins : [plugins];
        var o = this.__options;
        var aliases = _.extend({}, o.aliasdb, o.aliases);
        var filter = function(name) {
          var key = name.split(':');
          if (!key[1])
            return true;
          aliases[key[0]] = [key[1]];
          return false;
        };
        plugins = _.filter(plugins, filter);
        _.each(aliases, function(alias, key) {
          aliases[key] = _.isArray(alias) ? alias : [alias];
        });
        function recurse(list, out, level) {
          if (level >= 256)
            throw "Plug-in alias recursion detected.";
          list = _.filter(list, filter);
          _.each(list, function(name) {
            var alias = aliases[name];
            if (!alias) {
              out.push(name);
            } else {
              out = out.concat(recurse(alias, [], level + 1));
            }
          });
          return out;
        }
        return recurse(plugins, [], 0);
      },
      install: function(plugins) {
        plugins = _.isArray(plugins) ? plugins : [plugins];
        plugins = this.resolve(plugins);
        _.each(plugins, this.__install, this);
        this.__ready();
      },
      uninstall: function(plugins) {
        if (plugins) {
          plugins = _.isArray(plugins) ? plugins : [plugins];
          plugins = this.resolve(plugins);
        }
        _.eachRight(plugins || this.__installed, this.__uninstall, this);
      },
      __install: function(name) {
        var ctor = this.__options.plugindb[name];
        if (!ctor)
          throw "[three.install] Cannot install. '" + name + "' is not registered.";
        if (this.plugins[name])
          return console.warn("[three.install] " + name + " is already installed.");
        var Plugin = ctor;
        var plugin = new Plugin(this.__options[name] || {}, name);
        this.plugins[name] = plugin;
        flag = plugin.install(this);
        this.__installed.push(plugin);
        this.trigger({
          type: 'install',
          plugin: plugin
        });
        return flag;
      },
      __uninstall: function(name, alias) {
        plugin = _.isString(name) ? this.plugins[name] : name;
        if (!plugin)
          return console.warn("[three.uninstall] " + name + "' is not installed.");
        name = plugin.__name;
        plugin.uninstall(this);
        this.__installed = _.without(this.__installed, plugin);
        delete this.plugins[name];
        this.trigger({
          type: 'uninstall',
          plugin: plugin
        });
      },
      __ready: function() {
        this.triggerOnce({type: 'ready'});
      }
    };
    THREE.Binder.apply(THREE.Bootstrap.prototype);
    THREE.Bootstrap.Plugins = {};
    THREE.Bootstrap.Aliases = {};
    THREE.Bootstrap.Plugin = function(options) {
      this.options = _.defaults(options || {}, this.defaults);
    };
    THREE.Bootstrap.Plugin.prototype = {
      listen: [],
      defaults: {},
      install: function(three) {},
      uninstall: function(three) {}
    };
    THREE.Binder.apply(THREE.Bootstrap.Plugin.prototype);
    THREE.Api.apply(THREE.Bootstrap.Plugin.prototype);
    THREE.Bootstrap.registerPlugin = function(name, spec) {
      var ctor = function(options) {
        THREE.Bootstrap.Plugin.call(this, options);
        this.__name = name;
      };
      ctor.prototype = _.extend(new THREE.Bootstrap.Plugin(), spec);
      THREE.Bootstrap.Plugins[name] = ctor;
    };
    THREE.Bootstrap.unregisterPlugin = function(name) {
      delete THREE.Bootstrap.Plugins[name];
    };
    THREE.Bootstrap.registerAlias = function(name, plugins) {
      THREE.Bootstrap.Aliases[name] = plugins;
    };
    THREE.Bootstrap.unregisterAlias = function(name) {
      delete THREE.Bootstrap.Aliases[name];
    };
    THREE.Bootstrap.registerAlias('empty', ['fallback', 'bind', 'renderer', 'size', 'fill', 'loop', 'time']);
    THREE.Bootstrap.registerAlias('core', ['empty', 'scene', 'camera', 'render', 'warmup']);
    THREE.Bootstrap.registerAlias('VR', ['core', 'cursor', 'fullscreen', 'render:vr']);
    THREE.Bootstrap.registerPlugin('fallback', {
      defaults: {
        force: false,
        fill: true,
        begin: '<div class="threestrap-fallback" style="display: table; width: 100%; height: 100%;' + 'box-sizing: border-box; border: 1px dashed rgba(0, 0, 0, .25);">' + '<div style="display: table-cell; padding: 10px; vertical-align: middle; text-align: center;">',
        end: '</div></div>',
        message: '<big><strong>This example requires WebGL</strong></big><br>' + 'Visit <a target="_blank" href="http://get.webgl.org/">get.webgl.org</a> for more info</a>'
      },
      install: function(three) {
        var cnv;
        try {
          cnv = document.createElement('canvas');
          gl = cnv.getContext('webgl') || cnv.getContext('experimental-webgl');
          if (!gl || this.options.force) {
            throw "WebGL unavailable.";
          }
          three.fallback = false;
        } catch (e) {
          var message = this.options.message;
          var begin = this.options.begin;
          var end = this.options.end;
          var fill = this.options.fill;
          var div = document.createElement('div');
          div.innerHTML = begin + message + end;
          this.children = [];
          while (div.childNodes.length > 0) {
            this.children.push(div.firstChild);
            three.element.appendChild(div.firstChild);
          }
          if (fill) {
            three.install('fill');
          }
          this.div = div;
          three.fallback = true;
          return false;
        }
      },
      uninstall: function(three) {
        if (this.children) {
          this.children.forEach(function(child) {
            child.parentNode.removeChild(child);
          });
          this.children = null;
        }
        delete three.fallback;
      }
    });
    THREE.Bootstrap.registerPlugin('renderer', {
      defaults: {
        klass: THREE.WebGLRenderer,
        parameters: {
          depth: true,
          stencil: true,
          preserveDrawingBuffer: true,
          antialias: true
        }
      },
      listen: ['resize'],
      install: function(three) {
        var renderer = three.renderer = new this.options.klass(this.options.parameters);
        three.canvas = renderer.domElement;
        three.element.appendChild(renderer.domElement);
      },
      uninstall: function(three) {
        three.element.removeChild(three.renderer.domElement);
        delete three.renderer;
        delete three.canvas;
      },
      resize: function(event, three) {
        var renderer = three.renderer;
        var el = renderer.domElement;
        if (el && el.tagName == 'CANVAS') {
          renderer.setSize(event.renderWidth, event.renderHeight, false);
        } else {
          if (renderer.setRenderSize) {
            renderer.setRenderSize(event.renderWidth, event.renderHeight);
          }
          renderer.setSize(event.viewWidth, event.viewHeight, false);
        }
      }
    });
    THREE.Bootstrap.registerPlugin('bind', {
      install: function(three) {
        var globals = {
          'three': three,
          'window': window
        };
        three.bind = THREE.Binder.bind(three, globals);
        three.unbind = THREE.Binder.unbind(three);
        three.bind('install:bind', this);
        three.bind('uninstall:unbind', this);
      },
      uninstall: function(three) {
        three.unbind(this);
        delete three.bind;
        delete three.unbind;
      },
      bind: function(event, three) {
        var plugin = event.plugin;
        var listen = plugin.listen;
        listen && listen.forEach(function(key) {
          three.bind(key, plugin);
        });
      },
      unbind: function(event, three) {
        three.unbind(event.plugin);
      }
    });
    THREE.Bootstrap.registerPlugin('size', {
      defaults: {
        width: null,
        height: null,
        aspect: null,
        scale: 1,
        maxRenderWidth: Infinity,
        maxRenderHeight: Infinity
      },
      listen: ['window.resize:queue', 'element.resize:queue', 'this.change:queue', 'ready:resize', 'pre:pre'],
      install: function(three) {
        three.Size = this.api({
          renderWidth: 0,
          renderHeight: 0,
          viewWidth: 0,
          viewHeight: 0
        });
        this.resized = false;
      },
      uninstall: function(three) {
        delete three.Size;
      },
      queue: function(event, three) {
        this.resized = true;
      },
      pre: function(event, three) {
        if (!this.resized)
          return ;
        this.resized = false;
        this.resize(event, three);
      },
      resize: function(event, three) {
        var options = this.options;
        var element = three.element;
        var renderer = three.renderer;
        var w,
            h,
            ew,
            eh,
            rw,
            rh,
            aspect,
            cut,
            style,
            ml = 0,
            mt = 0;
        w = ew = (options.width === undefined || options.width == null) ? element.offsetWidth || element.innerWidth || 0 : options.width;
        h = eh = (options.height === undefined || options.height == null) ? element.offsetHeight || element.innerHeight || 0 : options.height;
        aspect = w / h;
        if (options.aspect) {
          if (options.aspect > aspect) {
            h = Math.round(w / options.aspect);
            mt = Math.floor((eh - h) / 2);
          } else {
            w = Math.round(h * options.aspect);
            ml = Math.floor((ew - w) / 2);
          }
          aspect = w / h;
        }
        rw = Math.min(w * options.scale, options.maxRenderWidth);
        rh = Math.min(h * options.scale, options.maxRenderHeight);
        raspect = rw / rh;
        if (raspect > aspect) {
          rw = Math.round(rh * aspect);
        } else {
          rh = Math.round(rw / aspect);
        }
        style = renderer.domElement.style;
        style.width = w + "px";
        style.height = h + "px";
        style.marginLeft = ml + "px";
        style.marginTop = mt + "px";
        _.extend(three.Size, {
          renderWidth: rw,
          renderHeight: rh,
          viewWidth: w,
          viewHeight: h,
          aspect: aspect
        });
        three.trigger({
          type: 'resize',
          renderWidth: rw,
          renderHeight: rh,
          viewWidth: w,
          viewHeight: h,
          aspect: aspect
        });
      }
    });
    THREE.Bootstrap.registerPlugin('fill', {
      defaults: {
        block: true,
        body: true,
        layout: true
      },
      install: function(three) {
        function is(element) {
          var h = element.style.height;
          return h == 'auto' || h == '';
        }
        function set(element) {
          element.style.height = '100%';
          element.style.margin = 0;
          element.style.padding = 0;
          return element;
        }
        if (this.options.body && three.element == document.body) {
          this.applied = [three.element, document.documentElement].filter(is).map(set);
        }
        if (this.options.block && three.canvas) {
          three.canvas.style.display = 'block';
          this.block = true;
        }
        if (this.options.layout && three.element) {
          var style = window.getComputedStyle(three.element);
          if (style.position == 'static') {
            three.element.style.position = 'relative';
            this.layout = true;
          }
        }
      },
      uninstall: function(three) {
        if (this.applied) {
          function set(element) {
            element.style.height = '';
            element.style.margin = '';
            element.style.padding = '';
            return element;
          }
          this.applied.map(set);
          delete this.applied;
        }
        if (this.block && three.canvas) {
          three.canvas.style.display = '';
          delete this.block;
        }
        if (this.layout && three.element) {
          three.element.style.position = '';
          delete this.layout;
        }
      },
      change: function(three) {
        this.uninstall(three);
        this.install(three);
      }
    });
    THREE.Bootstrap.registerPlugin('loop', {
      defaults: {start: true},
      listen: ['ready'],
      install: function(three) {
        this.running = false;
        three.Loop = this.api({
          start: this.start.bind(this),
          stop: this.stop.bind(this),
          running: false
        }, three);
        this.events = ['pre', 'update', 'render', 'post'].map(function(type) {
          return {type: type};
        });
      },
      uninstall: function(three) {
        this.stop(three);
      },
      ready: function(event, three) {
        if (this.options.start)
          this.start(three);
      },
      start: function(three) {
        if (this.running)
          return ;
        three.Loop.running = this.running = true;
        var trigger = three.trigger.bind(three);
        var loop = function() {
          this.running && requestAnimationFrame(loop);
          this.events.map(trigger);
        }.bind(this);
        requestAnimationFrame(loop);
        three.trigger({type: 'start'});
      },
      stop: function(three) {
        if (!this.running)
          return ;
        three.Loop.running = this.running = false;
        three.trigger({type: 'stop'});
      }
    });
    THREE.Bootstrap.registerPlugin('time', {
      defaults: {speed: 1},
      listen: ['pre:tick', 'this.change'],
      now: function() {
        return +new Date() / 1000;
      },
      install: function(three) {
        three.Time = this.api({
          now: this.now(),
          clock: 0,
          step: 1 / 60,
          frames: 0,
          delta: 1 / 60,
          average: 0,
          fps: 0
        });
        this.last = 0;
        this.clock = 0;
      },
      tick: function(event, three) {
        var speed = this.options.speed;
        var api = three.Time;
        var now = api.now = this.now();
        var last = this.last;
        var clock = this.clock;
        if (last) {
          var delta = api.delta = now - last;
          var average = api.average || delta;
          var step = delta * speed;
          clock += step;
          if (api.frames > 0) {
            api.average = average + (delta - average) * .1;
            api.fps = 1 / average;
          }
          api.step = step;
          api.clock = clock;
          api.frames++;
        }
        this.last = now;
        this.clock = clock;
      },
      uninstall: function(three) {
        delete three.Time;
      }
    });
    THREE.Bootstrap.registerPlugin('scene', {
      install: function(three) {
        three.scene = new THREE.Scene();
      },
      uninstall: function(three) {
        delete three.scene;
      }
    });
    THREE.Bootstrap.registerPlugin('camera', {
      defaults: {
        near: .1,
        far: 10000,
        type: 'perspective',
        fov: 60,
        aspect: null,
        left: -1,
        right: 1,
        bottom: -1,
        top: 1,
        klass: null,
        parameters: null
      },
      listen: ['resize', 'this.change'],
      install: function(three) {
        three.Camera = this.api();
        three.camera = null;
        this.aspect = 1;
        this.change({}, three);
      },
      uninstall: function(three) {
        delete three.Camera;
        delete three.camera;
      },
      change: function(event, three) {
        var o = this.options;
        var old = three.camera;
        if (!three.camera || event.changes.type || event.changes.klass) {
          var klass = o.klass || {
            'perspective': THREE.PerspectiveCamera,
            'orthographic': THREE.OrthographicCamera
          }[o.type] || THREE.Camera;
          three.camera = o.parameters ? new klass(o.parameters) : new klass();
        }
        _.each(o, function(value, key) {
          if (three.camera.hasOwnProperty(key))
            three.camera[key] = o[key];
        }.bind(this));
        this.update(three);
        (old === three.camera) || three.trigger({
          type: 'camera',
          camera: three.camera
        });
      },
      resize: function(event, three) {
        this.aspect = event.viewWidth / Math.max(1, event.viewHeight);
        this.update(three);
      },
      update: function(three) {
        three.camera.aspect = this.options.aspect || this.aspect;
        three.camera.updateProjectionMatrix();
      }
    });
    THREE.Bootstrap.registerPlugin('render', {
      listen: ['render'],
      render: function(event, three) {
        if (three.scene && three.camera) {
          three.renderer.render(three.scene, three.camera);
        }
      }
    });
    THREE.Bootstrap.registerPlugin('warmup', {
      defaults: {delay: 2},
      listen: ['ready', 'post'],
      ready: function(event, three) {
        three.renderer.domElement.style.visibility = 'hidden';
        this.frame = 0;
        this.hidden = true;
      },
      post: function(event, three) {
        if (this.hidden && this.frame >= this.options.delay) {
          three.renderer.domElement.style.visibility = 'visible';
          this.hidden = false;
        }
        this.frame++;
      }
    });
    THREE.Stats = function() {
      var l = Date.now(),
          m = l,
          g = 0,
          n = Infinity,
          o = 0,
          h = 0,
          p = Infinity,
          q = 0,
          r = 0,
          s = 0,
          f = document.createElement("div");
      f.id = "stats";
      f.addEventListener("mousedown", function(b) {
        b.preventDefault();
        t(++s % 2);
      }, !1);
      f.style.cssText = "width:80px;opacity:0.9;cursor:pointer";
      var a = document.createElement("div");
      a.id = "fps";
      a.style.cssText = "padding:0 0 3px 3px;text-align:left;background-color:#002";
      f.appendChild(a);
      var i = document.createElement("div");
      i.id = "fpsText";
      i.style.cssText = "color:#0ff;font-family:Helvetica,Arial,sans-serif;font-size:9px;font-weight:bold;line-height:15px";
      i.innerHTML = "FPS";
      a.appendChild(i);
      var c = document.createElement("div");
      c.id = "fpsGraph";
      c.style.cssText = "position:relative;width:74px;height:30px;background-color:#0ff";
      for (a.appendChild(c); 74 > c.children.length; ) {
        var j = document.createElement("span");
        j.style.cssText = "width:1px;height:30px;float:left;background-color:#113";
        c.appendChild(j);
      }
      var d = document.createElement("div");
      d.id = "ms";
      d.style.cssText = "padding:0 0 3px 3px;text-align:left;background-color:#020;display:none";
      f.appendChild(d);
      var k = document.createElement("div");
      k.id = "msText";
      k.style.cssText = "color:#0f0;font-family:Helvetica,Arial,sans-serif;font-size:9px;font-weight:bold;line-height:15px";
      k.innerHTML = "MS";
      d.appendChild(k);
      var e = document.createElement("div");
      e.id = "msGraph";
      e.style.cssText = "position:relative;width:74px;height:30px;background-color:#0f0";
      for (d.appendChild(e); 74 > e.children.length; )
        j = document.createElement("span"), j.style.cssText = "width:1px;height:30px;float:left;background-color:#131", e.appendChild(j);
      var t = function(b) {
        s = b;
        switch (s) {
          case 0:
            a.style.display = "block";
            d.style.display = "none";
            break;
          case 1:
            a.style.display = "none", d.style.display = "block";
        }
      };
      return {
        REVISION: 11,
        domElement: f,
        setMode: t,
        begin: function() {
          l = Date.now();
        },
        end: function() {
          var b = Date.now();
          g = b - l;
          n = Math.min(n, g);
          o = Math.max(o, g);
          k.textContent = g + " MS (" + n + "-" + o + ")";
          var a = Math.min(30, 30 - 30 * (g / 200));
          e.appendChild(e.firstChild).style.height = a + "px";
          r++;
          b > m + 1E3 && (h = Math.round(1E3 * r / (b - m)), p = Math.min(p, h), q = Math.max(q, h), i.textContent = h + " FPS (" + p + "-" + q + ")", a = Math.min(30, 30 - 30 * (h / 100)), c.appendChild(c.firstChild).style.height = a + "px", m = b, r = 0);
          return b;
        },
        update: function() {
          l = this.end();
        }
      };
    };
    THREE.DeviceOrientationControls = function(object) {
      var scope = this;
      this.object = object;
      this.object.rotation.reorder("YXZ");
      this.freeze = true;
      this.deviceOrientation = {};
      this.screenOrientation = 0;
      var onDeviceOrientationChangeEvent = function(event) {
        scope.deviceOrientation = event;
      };
      var onScreenOrientationChangeEvent = function() {
        scope.screenOrientation = window.orientation || 0;
      };
      var setObjectQuaternion = function() {
        var zee = new THREE.Vector3(0, 0, 1);
        var euler = new THREE.Euler();
        var q0 = new THREE.Quaternion();
        var q1 = new THREE.Quaternion(-Math.sqrt(0.5), 0, 0, Math.sqrt(0.5));
        return function(quaternion, alpha, beta, gamma, orient) {
          euler.set(beta, alpha, -gamma, 'YXZ');
          quaternion.setFromEuler(euler);
          quaternion.multiply(q1);
          quaternion.multiply(q0.setFromAxisAngle(zee, -orient));
        };
      }();
      this.connect = function() {
        onScreenOrientationChangeEvent();
        window.addEventListener('orientationchange', onScreenOrientationChangeEvent, false);
        window.addEventListener('deviceorientation', onDeviceOrientationChangeEvent, false);
        scope.freeze = false;
      };
      this.disconnect = function() {
        scope.freeze = true;
        window.removeEventListener('orientationchange', onScreenOrientationChangeEvent, false);
        window.removeEventListener('deviceorientation', onDeviceOrientationChangeEvent, false);
      };
      this.update = function() {
        if (scope.freeze)
          return ;
        var alpha = scope.deviceOrientation.gamma ? THREE.Math.degToRad(scope.deviceOrientation.alpha) : 0;
        var beta = scope.deviceOrientation.beta ? THREE.Math.degToRad(scope.deviceOrientation.beta) : 0;
        var gamma = scope.deviceOrientation.gamma ? THREE.Math.degToRad(scope.deviceOrientation.gamma) : 0;
        var orient = scope.screenOrientation ? THREE.Math.degToRad(scope.screenOrientation) : 0;
        setObjectQuaternion(scope.object.quaternion, alpha, beta, gamma, orient);
      };
    };
    THREE.FirstPersonControls = function(object, domElement) {
      this.object = object;
      this.target = new THREE.Vector3(0, 0, 0);
      this.domElement = (domElement !== undefined) ? domElement : document;
      this.movementSpeed = 1.0;
      this.lookSpeed = 0.005;
      this.lookVertical = true;
      this.autoForward = false;
      this.activeLook = true;
      this.heightSpeed = false;
      this.heightCoef = 1.0;
      this.heightMin = 0.0;
      this.heightMax = 1.0;
      this.constrainVertical = false;
      this.verticalMin = 0;
      this.verticalMax = Math.PI;
      this.autoSpeedFactor = 0.0;
      this.mouseX = 0;
      this.mouseY = 0;
      this.lat = 0;
      this.lon = 0;
      this.phi = 0;
      this.theta = 0;
      this.moveForward = false;
      this.moveBackward = false;
      this.moveLeft = false;
      this.moveRight = false;
      this.freeze = false;
      this.mouseDragOn = false;
      this.viewHalfX = 0;
      this.viewHalfY = 0;
      if (this.domElement !== document) {
        this.domElement.setAttribute('tabindex', -1);
      }
      this.handleResize = function() {
        if (this.domElement === document) {
          this.viewHalfX = window.innerWidth / 2;
          this.viewHalfY = window.innerHeight / 2;
        } else {
          this.viewHalfX = this.domElement.offsetWidth / 2;
          this.viewHalfY = this.domElement.offsetHeight / 2;
        }
      };
      this.onMouseDown = function(event) {
        if (this.domElement !== document) {
          this.domElement.focus();
        }
        event.preventDefault();
        event.stopPropagation();
        if (this.activeLook) {
          switch (event.button) {
            case 0:
              this.moveForward = true;
              break;
            case 2:
              this.moveBackward = true;
              break;
          }
        }
        this.mouseDragOn = true;
      };
      this.onMouseUp = function(event) {
        event.preventDefault();
        event.stopPropagation();
        if (this.activeLook) {
          switch (event.button) {
            case 0:
              this.moveForward = false;
              break;
            case 2:
              this.moveBackward = false;
              break;
          }
        }
        this.mouseDragOn = false;
      };
      this.onMouseMove = function(event) {
        if (this.domElement === document) {
          this.mouseX = event.pageX - this.viewHalfX;
          this.mouseY = event.pageY - this.viewHalfY;
        } else {
          this.mouseX = event.pageX - this.domElement.offsetLeft - this.viewHalfX;
          this.mouseY = event.pageY - this.domElement.offsetTop - this.viewHalfY;
        }
      };
      this.onKeyDown = function(event) {
        switch (event.keyCode) {
          case 38:
          case 87:
            this.moveForward = true;
            break;
          case 37:
          case 65:
            this.moveLeft = true;
            break;
          case 40:
          case 83:
            this.moveBackward = true;
            break;
          case 39:
          case 68:
            this.moveRight = true;
            break;
          case 82:
            this.moveUp = true;
            break;
          case 70:
            this.moveDown = true;
            break;
          case 81:
            this.freeze = !this.freeze;
            break;
        }
      };
      this.onKeyUp = function(event) {
        switch (event.keyCode) {
          case 38:
          case 87:
            this.moveForward = false;
            break;
          case 37:
          case 65:
            this.moveLeft = false;
            break;
          case 40:
          case 83:
            this.moveBackward = false;
            break;
          case 39:
          case 68:
            this.moveRight = false;
            break;
          case 82:
            this.moveUp = false;
            break;
          case 70:
            this.moveDown = false;
            break;
        }
      };
      this.update = function(delta) {
        if (this.freeze) {
          return ;
        }
        if (this.heightSpeed) {
          var y = THREE.Math.clamp(this.object.position.y, this.heightMin, this.heightMax);
          var heightDelta = y - this.heightMin;
          this.autoSpeedFactor = delta * (heightDelta * this.heightCoef);
        } else {
          this.autoSpeedFactor = 0.0;
        }
        var actualMoveSpeed = delta * this.movementSpeed;
        if (this.moveForward || (this.autoForward && !this.moveBackward))
          this.object.translateZ(-(actualMoveSpeed + this.autoSpeedFactor));
        if (this.moveBackward)
          this.object.translateZ(actualMoveSpeed);
        if (this.moveLeft)
          this.object.translateX(-actualMoveSpeed);
        if (this.moveRight)
          this.object.translateX(actualMoveSpeed);
        if (this.moveUp)
          this.object.translateY(actualMoveSpeed);
        if (this.moveDown)
          this.object.translateY(-actualMoveSpeed);
        var actualLookSpeed = delta * this.lookSpeed;
        if (!this.activeLook) {
          actualLookSpeed = 0;
        }
        var verticalLookRatio = 1;
        if (this.constrainVertical) {
          verticalLookRatio = Math.PI / (this.verticalMax - this.verticalMin);
        }
        this.lon += this.mouseX * actualLookSpeed;
        if (this.lookVertical)
          this.lat -= this.mouseY * actualLookSpeed * verticalLookRatio;
        this.lat = Math.max(-85, Math.min(85, this.lat));
        this.phi = THREE.Math.degToRad(90 - this.lat);
        this.theta = THREE.Math.degToRad(this.lon);
        if (this.constrainVertical) {
          this.phi = THREE.Math.mapLinear(this.phi, 0, Math.PI, this.verticalMin, this.verticalMax);
        }
        var targetPosition = this.target,
            position = this.object.position;
        targetPosition.x = position.x + 100 * Math.sin(this.phi) * Math.cos(this.theta);
        targetPosition.y = position.y + 100 * Math.cos(this.phi);
        targetPosition.z = position.z + 100 * Math.sin(this.phi) * Math.sin(this.theta);
        this.object.lookAt(targetPosition);
      };
      this.domElement.addEventListener('contextmenu', function(event) {
        event.preventDefault();
      }, false);
      this.domElement.addEventListener('mousemove', bind(this, this.onMouseMove), false);
      this.domElement.addEventListener('mousedown', bind(this, this.onMouseDown), false);
      this.domElement.addEventListener('mouseup', bind(this, this.onMouseUp), false);
      this.domElement.addEventListener('keydown', bind(this, this.onKeyDown), false);
      this.domElement.addEventListener('keyup', bind(this, this.onKeyUp), false);
      function bind(scope, fn) {
        return function() {
          fn.apply(scope, arguments);
        };
      }
      ;
      this.handleResize();
    };
    THREE.OrbitControls = function(object, domElement) {
      this.object = object;
      this.domElement = (domElement !== undefined) ? domElement : document;
      this.enabled = true;
      this.target = new THREE.Vector3();
      this.center = this.target;
      this.noZoom = false;
      this.zoomSpeed = 1.0;
      this.minDistance = 0;
      this.maxDistance = Infinity;
      this.noRotate = false;
      this.rotateSpeed = 1.0;
      this.noPan = false;
      this.keyPanSpeed = 7.0;
      this.autoRotate = false;
      this.autoRotateSpeed = 2.0;
      this.minPolarAngle = 0;
      this.maxPolarAngle = Math.PI;
      this.noKeys = false;
      this.keys = {
        LEFT: 37,
        UP: 38,
        RIGHT: 39,
        BOTTOM: 40
      };
      var scope = this;
      var EPS = 0.000001;
      var rotateStart = new THREE.Vector2();
      var rotateEnd = new THREE.Vector2();
      var rotateDelta = new THREE.Vector2();
      var panStart = new THREE.Vector2();
      var panEnd = new THREE.Vector2();
      var panDelta = new THREE.Vector2();
      var panOffset = new THREE.Vector3();
      var offset = new THREE.Vector3();
      var dollyStart = new THREE.Vector2();
      var dollyEnd = new THREE.Vector2();
      var dollyDelta = new THREE.Vector2();
      var phiDelta = 0;
      var thetaDelta = 0;
      var scale = 1;
      var pan = new THREE.Vector3();
      var lastPosition = new THREE.Vector3();
      var STATE = {
        NONE: -1,
        ROTATE: 0,
        DOLLY: 1,
        PAN: 2,
        TOUCH_ROTATE: 3,
        TOUCH_DOLLY: 4,
        TOUCH_PAN: 5
      };
      var state = STATE.NONE;
      this.target0 = this.target.clone();
      this.position0 = this.object.position.clone();
      var quat = new THREE.Quaternion().setFromUnitVectors(object.up, new THREE.Vector3(0, 1, 0));
      var quatInverse = quat.clone().inverse();
      var changeEvent = {type: 'change'};
      var startEvent = {type: 'start'};
      var endEvent = {type: 'end'};
      this.rotateLeft = function(angle) {
        if (angle === undefined) {
          angle = getAutoRotationAngle();
        }
        thetaDelta -= angle;
      };
      this.rotateUp = function(angle) {
        if (angle === undefined) {
          angle = getAutoRotationAngle();
        }
        phiDelta -= angle;
      };
      this.panLeft = function(distance) {
        var te = this.object.matrix.elements;
        panOffset.set(te[0], te[1], te[2]);
        panOffset.multiplyScalar(-distance);
        pan.add(panOffset);
      };
      this.panUp = function(distance) {
        var te = this.object.matrix.elements;
        panOffset.set(te[4], te[5], te[6]);
        panOffset.multiplyScalar(distance);
        pan.add(panOffset);
      };
      this.pan = function(deltaX, deltaY) {
        var element = scope.domElement === document ? scope.domElement.body : scope.domElement;
        if (scope.object.fov !== undefined) {
          var position = scope.object.position;
          var offset = position.clone().sub(scope.target);
          var targetDistance = offset.length();
          targetDistance *= Math.tan((scope.object.fov / 2) * Math.PI / 180.0);
          scope.panLeft(2 * deltaX * targetDistance / element.clientHeight);
          scope.panUp(2 * deltaY * targetDistance / element.clientHeight);
        } else if (scope.object.top !== undefined) {
          scope.panLeft(deltaX * (scope.object.right - scope.object.left) / element.clientWidth);
          scope.panUp(deltaY * (scope.object.top - scope.object.bottom) / element.clientHeight);
        } else {
          console.warn('WARNING: OrbitControls.js encountered an unknown camera type - pan disabled.');
        }
      };
      this.dollyIn = function(dollyScale) {
        if (dollyScale === undefined) {
          dollyScale = getZoomScale();
        }
        scale /= dollyScale;
      };
      this.dollyOut = function(dollyScale) {
        if (dollyScale === undefined) {
          dollyScale = getZoomScale();
        }
        scale *= dollyScale;
      };
      this.update = function() {
        var position = this.object.position;
        offset.copy(position).sub(this.target);
        offset.applyQuaternion(quat);
        var theta = Math.atan2(offset.x, offset.z);
        var phi = Math.atan2(Math.sqrt(offset.x * offset.x + offset.z * offset.z), offset.y);
        if (this.autoRotate) {
          this.rotateLeft(getAutoRotationAngle());
        }
        theta += thetaDelta;
        phi += phiDelta;
        phi = Math.max(this.minPolarAngle, Math.min(this.maxPolarAngle, phi));
        phi = Math.max(EPS, Math.min(Math.PI - EPS, phi));
        var radius = offset.length() * scale;
        radius = Math.max(this.minDistance, Math.min(this.maxDistance, radius));
        this.target.add(pan);
        offset.x = radius * Math.sin(phi) * Math.sin(theta);
        offset.y = radius * Math.cos(phi);
        offset.z = radius * Math.sin(phi) * Math.cos(theta);
        offset.applyQuaternion(quatInverse);
        position.copy(this.target).add(offset);
        this.object.lookAt(this.target);
        thetaDelta = 0;
        phiDelta = 0;
        scale = 1;
        pan.set(0, 0, 0);
        if (lastPosition.distanceToSquared(this.object.position) > EPS) {
          this.dispatchEvent(changeEvent);
          lastPosition.copy(this.object.position);
        }
      };
      this.reset = function() {
        state = STATE.NONE;
        this.target.copy(this.target0);
        this.object.position.copy(this.position0);
        this.update();
      };
      function getAutoRotationAngle() {
        return 2 * Math.PI / 60 / 60 * scope.autoRotateSpeed;
      }
      function getZoomScale() {
        return Math.pow(0.95, scope.zoomSpeed);
      }
      function onMouseDown(event) {
        if (scope.enabled === false)
          return ;
        event.preventDefault();
        if (event.button === 0) {
          if (scope.noRotate === true)
            return ;
          state = STATE.ROTATE;
          rotateStart.set(event.clientX, event.clientY);
        } else if (event.button === 1) {
          if (scope.noZoom === true)
            return ;
          state = STATE.DOLLY;
          dollyStart.set(event.clientX, event.clientY);
        } else if (event.button === 2) {
          if (scope.noPan === true)
            return ;
          state = STATE.PAN;
          panStart.set(event.clientX, event.clientY);
        }
        document.documentElement.addEventListener('mousemove', onMouseMove, false);
        document.documentElement.addEventListener('mouseup', onMouseUp, false);
        scope.dispatchEvent(startEvent);
      }
      function onMouseMove(event) {
        if (scope.enabled === false)
          return ;
        event.preventDefault();
        var element = scope.domElement === document ? scope.domElement.body : scope.domElement;
        if (state === STATE.ROTATE) {
          if (scope.noRotate === true)
            return ;
          rotateEnd.set(event.clientX, event.clientY);
          rotateDelta.subVectors(rotateEnd, rotateStart);
          scope.rotateLeft(2 * Math.PI * rotateDelta.x / element.clientWidth * scope.rotateSpeed);
          scope.rotateUp(2 * Math.PI * rotateDelta.y / element.clientHeight * scope.rotateSpeed);
          rotateStart.copy(rotateEnd);
        } else if (state === STATE.DOLLY) {
          if (scope.noZoom === true)
            return ;
          dollyEnd.set(event.clientX, event.clientY);
          dollyDelta.subVectors(dollyEnd, dollyStart);
          if (dollyDelta.y > 0) {
            scope.dollyIn();
          } else {
            scope.dollyOut();
          }
          dollyStart.copy(dollyEnd);
        } else if (state === STATE.PAN) {
          if (scope.noPan === true)
            return ;
          panEnd.set(event.clientX, event.clientY);
          panDelta.subVectors(panEnd, panStart);
          scope.pan(panDelta.x, panDelta.y);
          panStart.copy(panEnd);
        }
        scope.update();
      }
      function onMouseUp() {
        if (scope.enabled === false)
          return ;
        document.documentElement.removeEventListener('mousemove', onMouseMove, false);
        document.documentElement.removeEventListener('mouseup', onMouseUp, false);
        scope.dispatchEvent(endEvent);
        state = STATE.NONE;
      }
      function onMouseWheel(event) {
        if (scope.enabled === false || scope.noZoom === true)
          return ;
        event.preventDefault();
        event.stopPropagation();
        var delta = 0;
        if (event.wheelDelta !== undefined) {
          delta = event.wheelDelta;
        } else if (event.detail !== undefined) {
          delta = -event.detail;
        }
        if (delta > 0) {
          scope.dollyOut();
        } else {
          scope.dollyIn();
        }
        scope.update();
        scope.dispatchEvent(startEvent);
        scope.dispatchEvent(endEvent);
      }
      function onKeyDown(event) {
        if (scope.enabled === false || scope.noKeys === true || scope.noPan === true)
          return ;
        switch (event.keyCode) {
          case scope.keys.UP:
            scope.pan(0, scope.keyPanSpeed);
            scope.update();
            break;
          case scope.keys.BOTTOM:
            scope.pan(0, -scope.keyPanSpeed);
            scope.update();
            break;
          case scope.keys.LEFT:
            scope.pan(scope.keyPanSpeed, 0);
            scope.update();
            break;
          case scope.keys.RIGHT:
            scope.pan(-scope.keyPanSpeed, 0);
            scope.update();
            break;
        }
      }
      function touchstart(event) {
        if (scope.enabled === false)
          return ;
        switch (event.touches.length) {
          case 1:
            if (scope.noRotate === true)
              return ;
            state = STATE.TOUCH_ROTATE;
            rotateStart.set(event.touches[0].pageX, event.touches[0].pageY);
            break;
          case 2:
            if (scope.noZoom === true)
              return ;
            state = STATE.TOUCH_DOLLY;
            var dx = event.touches[0].pageX - event.touches[1].pageX;
            var dy = event.touches[0].pageY - event.touches[1].pageY;
            var distance = Math.sqrt(dx * dx + dy * dy);
            dollyStart.set(0, distance);
            break;
          case 3:
            if (scope.noPan === true)
              return ;
            state = STATE.TOUCH_PAN;
            panStart.set(event.touches[0].pageX, event.touches[0].pageY);
            break;
          default:
            state = STATE.NONE;
        }
        scope.dispatchEvent(startEvent);
      }
      function touchmove(event) {
        if (scope.enabled === false)
          return ;
        event.preventDefault();
        event.stopPropagation();
        var element = scope.domElement === document ? scope.domElement.body : scope.domElement;
        switch (event.touches.length) {
          case 1:
            if (scope.noRotate === true)
              return ;
            if (state !== STATE.TOUCH_ROTATE)
              return ;
            rotateEnd.set(event.touches[0].pageX, event.touches[0].pageY);
            rotateDelta.subVectors(rotateEnd, rotateStart);
            scope.rotateLeft(2 * Math.PI * rotateDelta.x / element.clientWidth * scope.rotateSpeed);
            scope.rotateUp(2 * Math.PI * rotateDelta.y / element.clientHeight * scope.rotateSpeed);
            rotateStart.copy(rotateEnd);
            scope.update();
            break;
          case 2:
            if (scope.noZoom === true)
              return ;
            if (state !== STATE.TOUCH_DOLLY)
              return ;
            var dx = event.touches[0].pageX - event.touches[1].pageX;
            var dy = event.touches[0].pageY - event.touches[1].pageY;
            var distance = Math.sqrt(dx * dx + dy * dy);
            dollyEnd.set(0, distance);
            dollyDelta.subVectors(dollyEnd, dollyStart);
            if (dollyDelta.y > 0) {
              scope.dollyOut();
            } else {
              scope.dollyIn();
            }
            dollyStart.copy(dollyEnd);
            scope.update();
            break;
          case 3:
            if (scope.noPan === true)
              return ;
            if (state !== STATE.TOUCH_PAN)
              return ;
            panEnd.set(event.touches[0].pageX, event.touches[0].pageY);
            panDelta.subVectors(panEnd, panStart);
            scope.pan(panDelta.x, panDelta.y);
            panStart.copy(panEnd);
            scope.update();
            break;
          default:
            state = STATE.NONE;
        }
      }
      function touchend() {
        if (scope.enabled === false)
          return ;
        scope.dispatchEvent(endEvent);
        state = STATE.NONE;
      }
      this.domElement.addEventListener('contextmenu', function(event) {
        event.preventDefault();
      }, false);
      this.domElement.addEventListener('mousedown', onMouseDown, false);
      this.domElement.addEventListener('mousewheel', onMouseWheel, false);
      this.domElement.addEventListener('DOMMouseScroll', onMouseWheel, false);
      this.domElement.addEventListener('touchstart', touchstart, false);
      this.domElement.addEventListener('touchend', touchend, false);
      this.domElement.addEventListener('touchmove', touchmove, false);
      window.addEventListener('keydown', onKeyDown, false);
      this.update();
    };
    THREE.OrbitControls.prototype = Object.create(THREE.EventDispatcher.prototype);
    THREE.VRControls = function(object, domElement) {
      var EPSILON = 1e-5;
      var dummy = this.dummy = new THREE.Object3D();
      this.object = object;
      this.device = new THREE.DeviceOrientationControls(dummy, domElement);
      this.orbit = new THREE.OrbitControls(dummy, domElement);
      this.orbit.target.copy(object.position);
      this.orbit.target.z += EPSILON;
      this.orbit.rotateSpeed = -0.25;
      this.supported = false;
      var callback = function(event) {
        this.supported = event && event.alpha == +event.alpha;
        window.removeEventListener('deviceorientation', callback, false);
      }.bind(this);
      window.addEventListener('deviceorientation', callback, false);
    };
    THREE.VRControls.prototype.vr = function(vrstate) {
      this.vrstate = vrstate;
    };
    THREE.VRControls.prototype.update = function(delta) {
      var freeze = false;
      if (this.vrstate && this.vrstate.orientation) {
        freeze = true;
        this.object.quaternion.copy(this.vrstate.orientation);
        this.object.position.copy(this.vrstate.position);
        this.device.object = this.dummy;
        this.orbit.object = this.dummy;
      } else if (this.vrstate && this.supported) {
        if (this.device.freeze)
          this.device.connect();
        this.device.object = this.object;
        this.orbit.object = this.dummy;
        this.device.update(delta);
      } else {
        freeze = true;
        this.device.object = this.dummy;
        this.orbit.object = this.object;
        this.orbit.update(delta);
      }
      if (freeze && !this.device.freeze)
        this.device.disconnect();
    };
    THREE.Bootstrap.registerPlugin('stats', {
      listen: ['pre', 'post'],
      install: function(three) {
        var stats = this.stats = new THREE.Stats();
        var style = stats.domElement.style;
        style.position = 'absolute';
        style.top = style.left = 0;
        three.element.appendChild(stats.domElement);
        three.stats = stats;
      },
      uninstall: function(three) {
        document.body.removeChild(this.stats.domElement);
        delete three.stats;
      },
      pre: function(event, three) {
        this.stats.begin();
      },
      post: function(event, three) {
        this.stats.end();
      }
    });
    THREE.Bootstrap.registerPlugin('controls', {
      listen: ['update', 'resize', 'camera', 'this.change'],
      defaults: {
        klass: null,
        parameters: {}
      },
      install: function(three) {
        if (!this.options.klass)
          throw "Must provide class for `controls.klass`";
        three.controls = null;
        this._camera = three.camera || new THREE.PerspectiveCamera();
        this.change(null, three);
      },
      uninstall: function(three) {
        delete three.controls;
      },
      change: function(event, three) {
        if (this.options.klass) {
          if (!event || event.changes.klass) {
            three.controls = new this.options.klass(this._camera, three.renderer.domElement);
          }
          _.extend(three.controls, this.options.parameters);
        } else {
          three.controls = null;
        }
      },
      update: function(event, three) {
        var delta = three.Time && three.Time.delta || 1 / 60;
        var vr = three.VR && three.VR.state;
        if (three.controls.vr)
          three.controls.vr(vr);
        three.controls.update(delta);
      },
      camera: function(event, three) {
        three.controls.object = this._camera = event.camera;
      },
      resize: function(event, three) {
        three.controls.handleResize && three.controls.handleResize();
      }
    });
    THREE.Bootstrap.registerPlugin('cursor', {
      listen: ['update', 'this.change', 'install:change', 'uninstall:change', 'element.mousemove', 'vr'],
      defaults: {
        cursor: null,
        hide: false,
        timeout: 3
      },
      install: function(three) {
        this.timeout = this.options.timeout;
        this.element = three.element;
        this.change(null, three);
      },
      uninstall: function(three) {
        delete three.controls;
      },
      change: function(event, three) {
        this.applyCursor(three);
      },
      mousemove: function(event, three) {
        if (this.options.hide) {
          this.applyCursor(three);
          this.timeout = +this.options.timeout || 0;
        }
      },
      update: function(event, three) {
        var delta = three.Time && three.Time.delta || 1 / 60;
        if (this.options.hide) {
          this.timeout -= delta;
          if (this.timeout < 0) {
            this.applyCursor(three, 'none');
          }
        }
      },
      vr: function(event, three) {
        this.hide = event.active && !event.hmd.fake;
        this.applyCursor(three);
      },
      applyCursor: function(three, cursor) {
        var auto = three.controls ? 'move' : '';
        cursor = cursor || this.options.cursor || auto;
        if (this.hide)
          cursor = 'none';
        if (this.cursor != cursor) {
          this.element.style.cursor = cursor;
        }
      }
    });
    THREE.Bootstrap.registerPlugin('fullscreen', {
      defaults: {key: 'f'},
      listen: ['ready', 'update'],
      install: function(three) {
        three.Fullscreen = this.api({
          active: false,
          toggle: this.toggle.bind(this)
        }, three);
      },
      uninstall: function(three) {
        delete three.Fullscreen;
      },
      ready: function(event, three) {
        document.body.addEventListener('keypress', function(event) {
          if (this.options.key && event.charCode == this.options.key.charCodeAt(0)) {
            this.toggle(three);
          }
        }.bind(this));
        var changeHandler = function() {
          var active = !!document.fullscreenElement || !!document.mozFullScreenElement || !!document.webkitFullscreenElement || !!document.msFullscreenElement;
          three.Fullscreen.active = this.active = active;
          three.trigger({
            type: 'fullscreen',
            active: active
          });
        }.bind(this);
        document.addEventListener("fullscreenchange", changeHandler, false);
        document.addEventListener("webkitfullscreenchange", changeHandler, false);
        document.addEventListener("mozfullscreenchange", changeHandler, false);
      },
      toggle: function(three) {
        var canvas = three.canvas;
        var options = (three.VR && three.VR.active) ? {vrDisplay: three.VR.hmd} : {};
        if (!this.active) {
          if (canvas.requestFullScreen) {
            canvas.requestFullScreen(options);
          } else if (canvas.msRequestFullScreen) {
            canvas.msRequestFullscreen(options);
          } else if (canvas.webkitRequestFullscreen) {
            canvas.webkitRequestFullscreen(options);
          } else if (canvas.mozRequestFullScreen) {
            canvas.mozRequestFullScreen(options);
          }
        } else {
          if (document.exitFullscreen) {
            document.exitFullscreen();
          } else if (document.msExitFullscreen) {
            document.msExitFullscreen();
          } else if (document.webkitExitFullscreen) {
            document.webkitExitFullscreen();
          } else if (document.mozCancelFullScreen) {
            document.mozCancelFullScreen();
          }
        }
      }
    });
    THREE.Bootstrap.registerPlugin('vr', {
      defaults: {
        mode: 'auto',
        device: null,
        fov: 90
      },
      listen: ['window.load', 'pre', 'render', 'resize', 'this.change'],
      install: function(three) {
        three.VR = this.api({
          active: false,
          devices: [],
          hmd: null,
          sensor: null,
          renderer: null,
          state: null
        }, three);
      },
      uninstall: function(three) {
        delete three.VR;
      },
      mocks: function(three, fov, def) {
        var ipd = 0.03;
        var getEyeTranslation = function(key) {
          return {
            left: {
              x: -ipd,
              y: 0,
              z: 0
            },
            right: {
              x: ipd,
              y: 0,
              z: 0
            }
          }[key];
        };
        var getRecommendedEyeFieldOfView = function(key) {
          var camera = three.camera;
          var aspect = camera && camera.aspect || 16 / 9;
          var fov2 = (fov || (camera && camera.fov || def)) / 2;
          var fovX = Math.atan(Math.tan(fov2 * Math.PI / 180) * aspect / 2) * 180 / Math.PI;
          var fovY = fov2;
          return {
            left: {
              "rightDegrees": fovX,
              "leftDegrees": fovX,
              "downDegrees": fovY,
              "upDegrees": fovY
            },
            right: {
              "rightDegrees": fovX,
              "leftDegrees": fovX,
              "downDegrees": fovY,
              "upDegrees": fovY
            }
          }[key];
        };
        var getState = function() {
          return {};
        };
        return [{
          fake: true,
          force: 1,
          deviceId: 'emu',
          deviceName: 'Emulated',
          getEyeTranslation: getEyeTranslation,
          getRecommendedEyeFieldOfView: getRecommendedEyeFieldOfView
        }, {
          force: 2,
          getState: getState
        }];
      },
      load: function(event, three) {
        var callback = function(devs) {
          this.callback(devs, three);
        }.bind(this);
        if (navigator.getVRDevices) {
          navigator.getVRDevices().then(callback);
        } else if (navigator.mozGetVRDevices) {
          navigator.mozGetVRDevices(callback);
        } else {
          console.warn('No native VR support detected.');
          callback(this.mocks(three, this.options.fov, this.defaults.fov), three);
        }
      },
      callback: function(vrdevs, three) {
        var hmd,
            sensor;
        var HMD = window.HMDVRDevice || function() {};
        var SENSOR = window.PositionSensorVRDevice || function() {};
        vrdevs = three.VR.devices = vrdevs || three.VR.devices;
        var deviceId = this.options.device;
        for (var i = 0; i < vrdevs.length; ++i) {
          var dev = vrdevs[i];
          if (dev.force == 1 || (dev instanceof HMD)) {
            if (deviceId && deviceId != dev.deviceId)
              continue;
            hmd = dev;
            break;
          }
        }
        if (hmd) {
          for (var i = 0; i < vrdevs.length; ++i) {
            var dev = vrdevs[i];
            if (dev.force == 2 || (dev instanceof SENSOR && dev.hardwareUnitId == hmd.hardwareUnitId)) {
              sensor = dev;
              break;
            }
          }
          this.hookup(hmd, sensor, three);
        }
      },
      hookup: function(hmd, sensor, three) {
        if (!THREE.VRRenderer)
          console.log("THREE.VRRenderer not found");
        var klass = THREE.VRRenderer || function() {};
        this.renderer = new klass(three.renderer, hmd);
        this.hmd = hmd;
        this.sensor = sensor;
        three.VR.renderer = this.renderer;
        three.VR.hmd = hmd;
        three.VR.sensor = sensor;
        console.log("THREE.VRRenderer", hmd.deviceName);
      },
      change: function(event, three) {
        if (event.changes.device) {
          this.callback(null, three);
        }
        this.pre(event, three);
      },
      pre: function(event, three) {
        var last = this.active;
        var active = this.active = this.renderer && this.options.mode != '2d';
        three.VR.active = active;
        if (active && this.sensor) {
          var state = this.sensor.getState();
          three.VR.state = state;
        } else {
          three.VR.state = null;
        }
        if (last != this.active) {
          three.trigger({
            type: 'vr',
            active: active,
            hmd: this.hmd,
            sensor: this.sensor
          });
        }
      },
      resize: function(event, three) {
        if (this.active) {
          this.renderer.initialize();
        }
      },
      render: function(event, three) {
        if (three.scene && three.camera) {
          var renderer = this.active ? this.renderer : three.renderer;
          if (this.last != renderer) {
            if (renderer == three.renderer) {
              var dpr = renderer.devicePixelRatio;
              var width = renderer.domElement.width / dpr;
              var height = renderer.domElement.height / dpr;
              renderer.enableScissorTest(false);
              renderer.setViewport(0, 0, width, height);
            }
          }
          this.last = renderer;
          renderer.render(three.scene, three.camera);
        }
      }
    });
    THREE.Bootstrap.registerPlugin('ui', {
      defaults: {
        theme: 'white',
        style: '.threestrap-ui { position: absolute; bottom: 5px; right: 5px; float: left; }' + '.threestrap-ui button { border: 0; background: none;' + '  vertical-align: middle; font-weight: bold; } ' + '.threestrap-ui .glyphicon { top: 2px; font-weight: bold; } ' + '@media (max-width: 640px) { .threestrap-ui button { font-size: 120% } }' + '.threestrap-white button { color: #fff; text-shadow: 0 1px 1px rgba(0, 0, 0, 1), ' + '0 1px 3px rgba(0, 0, 0, 1); }' + '.threestrap-black button { color: #000; text-shadow: 0 0px 1px rgba(255, 255, 255, 1), ' + '0 0px 2px rgba(255, 255, 255, 1), ' + '0 0px 2px rgba(255, 255, 255, 1) }'
      },
      listen: ['fullscreen'],
      markup: function(three, theme, style) {
        var url = "//netdna.bootstrapcdn.com/bootstrap/3.0.0/css/bootstrap-glyphicons.css";
        if (location.href.match(/^file:\/\//))
          url = 'http://' + url;
        var buttons = [];
        if (three.Fullscreen) {
          buttons.push('<button class="fullscreen" title="Full Screen">' + '<span class="glyphicon glyphicon-fullscreen"></span>' + '</button>');
        }
        if (three.VR) {
          buttons.push('<button class="vr" title="VR Headset">VR</button>');
        }
        return '<style type="text/css">@import url("' + url + '"); ' + style + '</style>' + '<div class="threestrap-ui threestrap-' + theme + '">' + buttons.join("\n") + '</div>';
      },
      install: function(three) {
        var ui = this.ui = document.createElement('div');
        ui.innerHTML = this.markup(three, this.options.theme, this.options.style);
        document.body.appendChild(ui);
        var fullscreen = this.ui.fullscreen = ui.querySelector('button.fullscreen');
        if (fullscreen) {
          three.bind([fullscreen, 'click:goFullscreen'], this);
        }
        var vr = this.ui.vr = ui.querySelector('button.vr');
        if (vr) {
          three.VR.set({mode: '2d'});
          three.bind([vr, 'click:goVR'], this);
        }
      },
      uninstall: function(three) {
        document.body.removeChild(ui);
      },
      fullscreen: function(event, three) {
        this.ui.style.display = event.active ? 'none' : 'block';
        if (!event.active)
          three.VR.set({mode: '2d'});
      },
      goFullscreen: function(event, three) {
        if (three.Fullscreen) {
          three.Fullscreen.toggle();
        }
      },
      goVR: function(event, three) {
        if (three.VR) {
          three.VR.set({mode: 'auto'});
          three.Fullscreen.toggle();
        }
      },
      uninstall: function(three) {
        document.body.removeChild(this.ui);
      }
    });
  }).call(System.global);
  return System.get("@@global-helpers").retrieveGlobal(__module.id, "THREE");
});

System.register("github:jspm/nodelibs-process@0.1.1/index", ["process"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  module.exports = System._nodeRequire ? process : require('process');
  global.define = __define;
  return module.exports;
});

System.register("github:unconed/threestrap@0.0.9", ["github:unconed/threestrap@0.0.9/threestrap"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  module.exports = require("github:unconed/threestrap@0.0.9/threestrap");
  global.define = __define;
  return module.exports;
});

System.register("github:jspm/nodelibs-process@0.1.1", ["github:jspm/nodelibs-process@0.1.1/index"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  module.exports = require("github:jspm/nodelibs-process@0.1.1/index");
  global.define = __define;
  return module.exports;
});

System.register("npm:lodash@3.5.0/index", ["process"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  "format cjs";
  (function(process) {
    ;
    (function() {
      var undefined;
      var VERSION = '3.5.0';
      var BIND_FLAG = 1,
          BIND_KEY_FLAG = 2,
          CURRY_BOUND_FLAG = 4,
          CURRY_FLAG = 8,
          CURRY_RIGHT_FLAG = 16,
          PARTIAL_FLAG = 32,
          PARTIAL_RIGHT_FLAG = 64,
          REARG_FLAG = 128,
          ARY_FLAG = 256;
      var DEFAULT_TRUNC_LENGTH = 30,
          DEFAULT_TRUNC_OMISSION = '...';
      var HOT_COUNT = 150,
          HOT_SPAN = 16;
      var LAZY_DROP_WHILE_FLAG = 0,
          LAZY_FILTER_FLAG = 1,
          LAZY_MAP_FLAG = 2;
      var FUNC_ERROR_TEXT = 'Expected a function';
      var PLACEHOLDER = '__lodash_placeholder__';
      var argsTag = '[object Arguments]',
          arrayTag = '[object Array]',
          boolTag = '[object Boolean]',
          dateTag = '[object Date]',
          errorTag = '[object Error]',
          funcTag = '[object Function]',
          mapTag = '[object Map]',
          numberTag = '[object Number]',
          objectTag = '[object Object]',
          regexpTag = '[object RegExp]',
          setTag = '[object Set]',
          stringTag = '[object String]',
          weakMapTag = '[object WeakMap]';
      var arrayBufferTag = '[object ArrayBuffer]',
          float32Tag = '[object Float32Array]',
          float64Tag = '[object Float64Array]',
          int8Tag = '[object Int8Array]',
          int16Tag = '[object Int16Array]',
          int32Tag = '[object Int32Array]',
          uint8Tag = '[object Uint8Array]',
          uint8ClampedTag = '[object Uint8ClampedArray]',
          uint16Tag = '[object Uint16Array]',
          uint32Tag = '[object Uint32Array]';
      var reEmptyStringLeading = /\b__p \+= '';/g,
          reEmptyStringMiddle = /\b(__p \+=) '' \+/g,
          reEmptyStringTrailing = /(__e\(.*?\)|\b__t\)) \+\n'';/g;
      var reEscapedHtml = /&(?:amp|lt|gt|quot|#39|#96);/g,
          reUnescapedHtml = /[&<>"'`]/g,
          reHasEscapedHtml = RegExp(reEscapedHtml.source),
          reHasUnescapedHtml = RegExp(reUnescapedHtml.source);
      var reEscape = /<%-([\s\S]+?)%>/g,
          reEvaluate = /<%([\s\S]+?)%>/g,
          reInterpolate = /<%=([\s\S]+?)%>/g;
      var reEsTemplate = /\$\{([^\\}]*(?:\\.[^\\}]*)*)\}/g;
      var reFlags = /\w*$/;
      var reFuncName = /^\s*function[ \n\r\t]+\w/;
      var reHexPrefix = /^0[xX]/;
      var reHostCtor = /^\[object .+?Constructor\]$/;
      var reLatin1 = /[\xc0-\xd6\xd8-\xde\xdf-\xf6\xf8-\xff]/g;
      var reNoMatch = /($^)/;
      var reRegExpChars = /[.*+?^${}()|[\]\/\\]/g,
          reHasRegExpChars = RegExp(reRegExpChars.source);
      var reThis = /\bthis\b/;
      var reUnescapedString = /['\n\r\u2028\u2029\\]/g;
      var reWords = (function() {
        var upper = '[A-Z\\xc0-\\xd6\\xd8-\\xde]',
            lower = '[a-z\\xdf-\\xf6\\xf8-\\xff]+';
        return RegExp(upper + '+(?=' + upper + lower + ')|' + upper + '?' + lower + '|' + upper + '+|[0-9]+', 'g');
      }());
      var whitespace = (' \t\x0b\f\xa0\ufeff' + '\n\r\u2028\u2029' + '\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000');
      var contextProps = ['Array', 'ArrayBuffer', 'Date', 'Error', 'Float32Array', 'Float64Array', 'Function', 'Int8Array', 'Int16Array', 'Int32Array', 'Math', 'Number', 'Object', 'RegExp', 'Set', 'String', '_', 'clearTimeout', 'document', 'isFinite', 'parseInt', 'setTimeout', 'TypeError', 'Uint8Array', 'Uint8ClampedArray', 'Uint16Array', 'Uint32Array', 'WeakMap', 'window', 'WinRTError'];
      var templateCounter = -1;
      var typedArrayTags = {};
      typedArrayTags[float32Tag] = typedArrayTags[float64Tag] = typedArrayTags[int8Tag] = typedArrayTags[int16Tag] = typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] = typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] = typedArrayTags[uint32Tag] = true;
      typedArrayTags[argsTag] = typedArrayTags[arrayTag] = typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] = typedArrayTags[dateTag] = typedArrayTags[errorTag] = typedArrayTags[funcTag] = typedArrayTags[mapTag] = typedArrayTags[numberTag] = typedArrayTags[objectTag] = typedArrayTags[regexpTag] = typedArrayTags[setTag] = typedArrayTags[stringTag] = typedArrayTags[weakMapTag] = false;
      var cloneableTags = {};
      cloneableTags[argsTag] = cloneableTags[arrayTag] = cloneableTags[arrayBufferTag] = cloneableTags[boolTag] = cloneableTags[dateTag] = cloneableTags[float32Tag] = cloneableTags[float64Tag] = cloneableTags[int8Tag] = cloneableTags[int16Tag] = cloneableTags[int32Tag] = cloneableTags[numberTag] = cloneableTags[objectTag] = cloneableTags[regexpTag] = cloneableTags[stringTag] = cloneableTags[uint8Tag] = cloneableTags[uint8ClampedTag] = cloneableTags[uint16Tag] = cloneableTags[uint32Tag] = true;
      cloneableTags[errorTag] = cloneableTags[funcTag] = cloneableTags[mapTag] = cloneableTags[setTag] = cloneableTags[weakMapTag] = false;
      var debounceOptions = {
        'leading': false,
        'maxWait': 0,
        'trailing': false
      };
      var deburredLetters = {
        '\xc0': 'A',
        '\xc1': 'A',
        '\xc2': 'A',
        '\xc3': 'A',
        '\xc4': 'A',
        '\xc5': 'A',
        '\xe0': 'a',
        '\xe1': 'a',
        '\xe2': 'a',
        '\xe3': 'a',
        '\xe4': 'a',
        '\xe5': 'a',
        '\xc7': 'C',
        '\xe7': 'c',
        '\xd0': 'D',
        '\xf0': 'd',
        '\xc8': 'E',
        '\xc9': 'E',
        '\xca': 'E',
        '\xcb': 'E',
        '\xe8': 'e',
        '\xe9': 'e',
        '\xea': 'e',
        '\xeb': 'e',
        '\xcC': 'I',
        '\xcd': 'I',
        '\xce': 'I',
        '\xcf': 'I',
        '\xeC': 'i',
        '\xed': 'i',
        '\xee': 'i',
        '\xef': 'i',
        '\xd1': 'N',
        '\xf1': 'n',
        '\xd2': 'O',
        '\xd3': 'O',
        '\xd4': 'O',
        '\xd5': 'O',
        '\xd6': 'O',
        '\xd8': 'O',
        '\xf2': 'o',
        '\xf3': 'o',
        '\xf4': 'o',
        '\xf5': 'o',
        '\xf6': 'o',
        '\xf8': 'o',
        '\xd9': 'U',
        '\xda': 'U',
        '\xdb': 'U',
        '\xdc': 'U',
        '\xf9': 'u',
        '\xfa': 'u',
        '\xfb': 'u',
        '\xfc': 'u',
        '\xdd': 'Y',
        '\xfd': 'y',
        '\xff': 'y',
        '\xc6': 'Ae',
        '\xe6': 'ae',
        '\xde': 'Th',
        '\xfe': 'th',
        '\xdf': 'ss'
      };
      var htmlEscapes = {
        '&': '&amp;',
        '<': '&lt;',
        '>': '&gt;',
        '"': '&quot;',
        "'": '&#39;',
        '`': '&#96;'
      };
      var htmlUnescapes = {
        '&amp;': '&',
        '&lt;': '<',
        '&gt;': '>',
        '&quot;': '"',
        '&#39;': "'",
        '&#96;': '`'
      };
      var objectTypes = {
        'function': true,
        'object': true
      };
      var stringEscapes = {
        '\\': '\\',
        "'": "'",
        '\n': 'n',
        '\r': 'r',
        '\u2028': 'u2028',
        '\u2029': 'u2029'
      };
      var freeExports = objectTypes[typeof exports] && exports && !exports.nodeType && exports;
      var freeModule = objectTypes[typeof module] && module && !module.nodeType && module;
      var freeGlobal = freeExports && freeModule && typeof global == 'object' && global;
      var freeWindow = objectTypes[typeof window] && window;
      var moduleExports = freeModule && freeModule.exports === freeExports && freeExports;
      var root = freeGlobal || ((freeWindow !== (this && this.window)) && freeWindow) || this;
      function baseCompareAscending(value, other) {
        if (value !== other) {
          var valIsReflexive = value === value,
              othIsReflexive = other === other;
          if (value > other || !valIsReflexive || (typeof value == 'undefined' && othIsReflexive)) {
            return 1;
          }
          if (value < other || !othIsReflexive || (typeof other == 'undefined' && valIsReflexive)) {
            return -1;
          }
        }
        return 0;
      }
      function baseIndexOf(array, value, fromIndex) {
        if (value !== value) {
          return indexOfNaN(array, fromIndex);
        }
        var index = fromIndex - 1,
            length = array.length;
        while (++index < length) {
          if (array[index] === value) {
            return index;
          }
        }
        return -1;
      }
      function baseIsFunction(value) {
        return typeof value == 'function' || false;
      }
      function baseToString(value) {
        if (typeof value == 'string') {
          return value;
        }
        return value == null ? '' : (value + '');
      }
      function charAtCallback(string) {
        return string.charCodeAt(0);
      }
      function charsLeftIndex(string, chars) {
        var index = -1,
            length = string.length;
        while (++index < length && chars.indexOf(string.charAt(index)) > -1) {}
        return index;
      }
      function charsRightIndex(string, chars) {
        var index = string.length;
        while (index-- && chars.indexOf(string.charAt(index)) > -1) {}
        return index;
      }
      function compareAscending(object, other) {
        return baseCompareAscending(object.criteria, other.criteria) || (object.index - other.index);
      }
      function compareMultiple(object, other, orders) {
        var index = -1,
            objCriteria = object.criteria,
            othCriteria = other.criteria,
            length = objCriteria.length,
            ordersLength = orders.length;
        while (++index < length) {
          var result = baseCompareAscending(objCriteria[index], othCriteria[index]);
          if (result) {
            if (index >= ordersLength) {
              return result;
            }
            return result * (orders[index] ? 1 : -1);
          }
        }
        return object.index - other.index;
      }
      function deburrLetter(letter) {
        return deburredLetters[letter];
      }
      function escapeHtmlChar(chr) {
        return htmlEscapes[chr];
      }
      function escapeStringChar(chr) {
        return '\\' + stringEscapes[chr];
      }
      function indexOfNaN(array, fromIndex, fromRight) {
        var length = array.length,
            index = fromIndex + (fromRight ? 0 : -1);
        while ((fromRight ? index-- : ++index < length)) {
          var other = array[index];
          if (other !== other) {
            return index;
          }
        }
        return -1;
      }
      function isObjectLike(value) {
        return (value && typeof value == 'object') || false;
      }
      function isSpace(charCode) {
        return ((charCode <= 160 && (charCode >= 9 && charCode <= 13) || charCode == 32 || charCode == 160) || charCode == 5760 || charCode == 6158 || (charCode >= 8192 && (charCode <= 8202 || charCode == 8232 || charCode == 8233 || charCode == 8239 || charCode == 8287 || charCode == 12288 || charCode == 65279)));
      }
      function replaceHolders(array, placeholder) {
        var index = -1,
            length = array.length,
            resIndex = -1,
            result = [];
        while (++index < length) {
          if (array[index] === placeholder) {
            array[index] = PLACEHOLDER;
            result[++resIndex] = index;
          }
        }
        return result;
      }
      function sortedUniq(array, iteratee) {
        var seen,
            index = -1,
            length = array.length,
            resIndex = -1,
            result = [];
        while (++index < length) {
          var value = array[index],
              computed = iteratee ? iteratee(value, index, array) : value;
          if (!index || seen !== computed) {
            seen = computed;
            result[++resIndex] = value;
          }
        }
        return result;
      }
      function trimmedLeftIndex(string) {
        var index = -1,
            length = string.length;
        while (++index < length && isSpace(string.charCodeAt(index))) {}
        return index;
      }
      function trimmedRightIndex(string) {
        var index = string.length;
        while (index-- && isSpace(string.charCodeAt(index))) {}
        return index;
      }
      function unescapeHtmlChar(chr) {
        return htmlUnescapes[chr];
      }
      function runInContext(context) {
        context = context ? _.defaults(root.Object(), context, _.pick(root, contextProps)) : root;
        var Array = context.Array,
            Date = context.Date,
            Error = context.Error,
            Function = context.Function,
            Math = context.Math,
            Number = context.Number,
            Object = context.Object,
            RegExp = context.RegExp,
            String = context.String,
            TypeError = context.TypeError;
        var arrayProto = Array.prototype,
            objectProto = Object.prototype,
            stringProto = String.prototype;
        var document = (document = context.window) && document.document;
        var fnToString = Function.prototype.toString;
        var getLength = baseProperty('length');
        var hasOwnProperty = objectProto.hasOwnProperty;
        var idCounter = 0;
        var objToString = objectProto.toString;
        var oldDash = context._;
        var reNative = RegExp('^' + escapeRegExp(objToString).replace(/toString|(function).*?(?=\\\()| for .+?(?=\\\])/g, '$1.*?') + '$');
        var ArrayBuffer = isNative(ArrayBuffer = context.ArrayBuffer) && ArrayBuffer,
            bufferSlice = isNative(bufferSlice = ArrayBuffer && new ArrayBuffer(0).slice) && bufferSlice,
            ceil = Math.ceil,
            clearTimeout = context.clearTimeout,
            floor = Math.floor,
            getPrototypeOf = isNative(getPrototypeOf = Object.getPrototypeOf) && getPrototypeOf,
            push = arrayProto.push,
            propertyIsEnumerable = objectProto.propertyIsEnumerable,
            Set = isNative(Set = context.Set) && Set,
            setTimeout = context.setTimeout,
            splice = arrayProto.splice,
            Uint8Array = isNative(Uint8Array = context.Uint8Array) && Uint8Array,
            WeakMap = isNative(WeakMap = context.WeakMap) && WeakMap;
        var Float64Array = (function() {
          try {
            var func = isNative(func = context.Float64Array) && func,
                result = new func(new ArrayBuffer(10), 0, 1) && func;
          } catch (e) {}
          return result;
        }());
        var nativeIsArray = isNative(nativeIsArray = Array.isArray) && nativeIsArray,
            nativeCreate = isNative(nativeCreate = Object.create) && nativeCreate,
            nativeIsFinite = context.isFinite,
            nativeKeys = isNative(nativeKeys = Object.keys) && nativeKeys,
            nativeMax = Math.max,
            nativeMin = Math.min,
            nativeNow = isNative(nativeNow = Date.now) && nativeNow,
            nativeNumIsFinite = isNative(nativeNumIsFinite = Number.isFinite) && nativeNumIsFinite,
            nativeParseInt = context.parseInt,
            nativeRandom = Math.random;
        var NEGATIVE_INFINITY = Number.NEGATIVE_INFINITY,
            POSITIVE_INFINITY = Number.POSITIVE_INFINITY;
        var MAX_ARRAY_LENGTH = Math.pow(2, 32) - 1,
            MAX_ARRAY_INDEX = MAX_ARRAY_LENGTH - 1,
            HALF_MAX_ARRAY_LENGTH = MAX_ARRAY_LENGTH >>> 1;
        var FLOAT64_BYTES_PER_ELEMENT = Float64Array ? Float64Array.BYTES_PER_ELEMENT : 0;
        var MAX_SAFE_INTEGER = Math.pow(2, 53) - 1;
        var metaMap = WeakMap && new WeakMap;
        function lodash(value) {
          if (isObjectLike(value) && !isArray(value) && !(value instanceof LazyWrapper)) {
            if (value instanceof LodashWrapper) {
              return value;
            }
            if (hasOwnProperty.call(value, '__chain__') && hasOwnProperty.call(value, '__wrapped__')) {
              return wrapperClone(value);
            }
          }
          return new LodashWrapper(value);
        }
        function baseLodash() {}
        function LodashWrapper(value, chainAll, actions) {
          this.__wrapped__ = value;
          this.__actions__ = actions || [];
          this.__chain__ = !!chainAll;
        }
        var support = lodash.support = {};
        (function(x) {
          support.funcDecomp = !isNative(context.WinRTError) && reThis.test(runInContext);
          support.funcNames = typeof Function.name == 'string';
          try {
            support.dom = document.createDocumentFragment().nodeType === 11;
          } catch (e) {
            support.dom = false;
          }
          try {
            support.nonEnumArgs = !propertyIsEnumerable.call(arguments, 1);
          } catch (e) {
            support.nonEnumArgs = true;
          }
        }(0, 0));
        lodash.templateSettings = {
          'escape': reEscape,
          'evaluate': reEvaluate,
          'interpolate': reInterpolate,
          'variable': '',
          'imports': {'_': lodash}
        };
        function LazyWrapper(value) {
          this.__wrapped__ = value;
          this.__actions__ = null;
          this.__dir__ = 1;
          this.__dropCount__ = 0;
          this.__filtered__ = false;
          this.__iteratees__ = null;
          this.__takeCount__ = POSITIVE_INFINITY;
          this.__views__ = null;
        }
        function lazyClone() {
          var actions = this.__actions__,
              iteratees = this.__iteratees__,
              views = this.__views__,
              result = new LazyWrapper(this.__wrapped__);
          result.__actions__ = actions ? arrayCopy(actions) : null;
          result.__dir__ = this.__dir__;
          result.__filtered__ = this.__filtered__;
          result.__iteratees__ = iteratees ? arrayCopy(iteratees) : null;
          result.__takeCount__ = this.__takeCount__;
          result.__views__ = views ? arrayCopy(views) : null;
          return result;
        }
        function lazyReverse() {
          if (this.__filtered__) {
            var result = new LazyWrapper(this);
            result.__dir__ = -1;
            result.__filtered__ = true;
          } else {
            result = this.clone();
            result.__dir__ *= -1;
          }
          return result;
        }
        function lazyValue() {
          var array = this.__wrapped__.value();
          if (!isArray(array)) {
            return baseWrapperValue(array, this.__actions__);
          }
          var dir = this.__dir__,
              isRight = dir < 0,
              view = getView(0, array.length, this.__views__),
              start = view.start,
              end = view.end,
              length = end - start,
              index = isRight ? end : (start - 1),
              takeCount = nativeMin(length, this.__takeCount__),
              iteratees = this.__iteratees__,
              iterLength = iteratees ? iteratees.length : 0,
              resIndex = 0,
              result = [];
          outer: while (length-- && resIndex < takeCount) {
            index += dir;
            var iterIndex = -1,
                value = array[index];
            while (++iterIndex < iterLength) {
              var data = iteratees[iterIndex],
                  iteratee = data.iteratee,
                  type = data.type;
              if (type == LAZY_DROP_WHILE_FLAG) {
                if (data.done && (isRight ? (index > data.index) : (index < data.index))) {
                  data.count = 0;
                  data.done = false;
                }
                data.index = index;
                if (!data.done) {
                  var limit = data.limit;
                  if (!(data.done = limit > -1 ? (data.count++ >= limit) : !iteratee(value))) {
                    continue outer;
                  }
                }
              } else {
                var computed = iteratee(value);
                if (type == LAZY_MAP_FLAG) {
                  value = computed;
                } else if (!computed) {
                  if (type == LAZY_FILTER_FLAG) {
                    continue outer;
                  } else {
                    break outer;
                  }
                }
              }
            }
            result[resIndex++] = value;
          }
          return result;
        }
        function MapCache() {
          this.__data__ = {};
        }
        function mapDelete(key) {
          return this.has(key) && delete this.__data__[key];
        }
        function mapGet(key) {
          return key == '__proto__' ? undefined : this.__data__[key];
        }
        function mapHas(key) {
          return key != '__proto__' && hasOwnProperty.call(this.__data__, key);
        }
        function mapSet(key, value) {
          if (key != '__proto__') {
            this.__data__[key] = value;
          }
          return this;
        }
        function SetCache(values) {
          var length = values ? values.length : 0;
          this.data = {
            'hash': nativeCreate(null),
            'set': new Set
          };
          while (length--) {
            this.push(values[length]);
          }
        }
        function cacheIndexOf(cache, value) {
          var data = cache.data,
              result = (typeof value == 'string' || isObject(value)) ? data.set.has(value) : data.hash[value];
          return result ? 0 : -1;
        }
        function cachePush(value) {
          var data = this.data;
          if (typeof value == 'string' || isObject(value)) {
            data.set.add(value);
          } else {
            data.hash[value] = true;
          }
        }
        function arrayCopy(source, array) {
          var index = -1,
              length = source.length;
          array || (array = Array(length));
          while (++index < length) {
            array[index] = source[index];
          }
          return array;
        }
        function arrayEach(array, iteratee) {
          var index = -1,
              length = array.length;
          while (++index < length) {
            if (iteratee(array[index], index, array) === false) {
              break;
            }
          }
          return array;
        }
        function arrayEachRight(array, iteratee) {
          var length = array.length;
          while (length--) {
            if (iteratee(array[length], length, array) === false) {
              break;
            }
          }
          return array;
        }
        function arrayEvery(array, predicate) {
          var index = -1,
              length = array.length;
          while (++index < length) {
            if (!predicate(array[index], index, array)) {
              return false;
            }
          }
          return true;
        }
        function arrayFilter(array, predicate) {
          var index = -1,
              length = array.length,
              resIndex = -1,
              result = [];
          while (++index < length) {
            var value = array[index];
            if (predicate(value, index, array)) {
              result[++resIndex] = value;
            }
          }
          return result;
        }
        function arrayMap(array, iteratee) {
          var index = -1,
              length = array.length,
              result = Array(length);
          while (++index < length) {
            result[index] = iteratee(array[index], index, array);
          }
          return result;
        }
        function arrayMax(array) {
          var index = -1,
              length = array.length,
              result = NEGATIVE_INFINITY;
          while (++index < length) {
            var value = array[index];
            if (value > result) {
              result = value;
            }
          }
          return result;
        }
        function arrayMin(array) {
          var index = -1,
              length = array.length,
              result = POSITIVE_INFINITY;
          while (++index < length) {
            var value = array[index];
            if (value < result) {
              result = value;
            }
          }
          return result;
        }
        function arrayReduce(array, iteratee, accumulator, initFromArray) {
          var index = -1,
              length = array.length;
          if (initFromArray && length) {
            accumulator = array[++index];
          }
          while (++index < length) {
            accumulator = iteratee(accumulator, array[index], index, array);
          }
          return accumulator;
        }
        function arrayReduceRight(array, iteratee, accumulator, initFromArray) {
          var length = array.length;
          if (initFromArray && length) {
            accumulator = array[--length];
          }
          while (length--) {
            accumulator = iteratee(accumulator, array[length], length, array);
          }
          return accumulator;
        }
        function arraySome(array, predicate) {
          var index = -1,
              length = array.length;
          while (++index < length) {
            if (predicate(array[index], index, array)) {
              return true;
            }
          }
          return false;
        }
        function assignDefaults(objectValue, sourceValue) {
          return typeof objectValue == 'undefined' ? sourceValue : objectValue;
        }
        function assignOwnDefaults(objectValue, sourceValue, key, object) {
          return (typeof objectValue == 'undefined' || !hasOwnProperty.call(object, key)) ? sourceValue : objectValue;
        }
        function baseAssign(object, source, customizer) {
          var props = keys(source);
          if (!customizer) {
            return baseCopy(source, object, props);
          }
          var index = -1,
              length = props.length;
          while (++index < length) {
            var key = props[index],
                value = object[key],
                result = customizer(value, source[key], key, object, source);
            if ((result === result ? (result !== value) : (value === value)) || (typeof value == 'undefined' && !(key in object))) {
              object[key] = result;
            }
          }
          return object;
        }
        function baseAt(collection, props) {
          var index = -1,
              length = collection.length,
              isArr = isLength(length),
              propsLength = props.length,
              result = Array(propsLength);
          while (++index < propsLength) {
            var key = props[index];
            if (isArr) {
              key = parseFloat(key);
              result[index] = isIndex(key, length) ? collection[key] : undefined;
            } else {
              result[index] = collection[key];
            }
          }
          return result;
        }
        function baseCopy(source, object, props) {
          if (!props) {
            props = object;
            object = {};
          }
          var index = -1,
              length = props.length;
          while (++index < length) {
            var key = props[index];
            object[key] = source[key];
          }
          return object;
        }
        function baseBindAll(object, methodNames) {
          var index = -1,
              length = methodNames.length;
          while (++index < length) {
            var key = methodNames[index];
            object[key] = createWrapper(object[key], BIND_FLAG, object);
          }
          return object;
        }
        function baseCallback(func, thisArg, argCount) {
          var type = typeof func;
          if (type == 'function') {
            return (typeof thisArg != 'undefined' && isBindable(func)) ? bindCallback(func, thisArg, argCount) : func;
          }
          if (func == null) {
            return identity;
          }
          if (type == 'object') {
            return baseMatches(func);
          }
          return typeof thisArg == 'undefined' ? baseProperty(func + '') : baseMatchesProperty(func + '', thisArg);
        }
        function baseClone(value, isDeep, customizer, key, object, stackA, stackB) {
          var result;
          if (customizer) {
            result = object ? customizer(value, key, object) : customizer(value);
          }
          if (typeof result != 'undefined') {
            return result;
          }
          if (!isObject(value)) {
            return value;
          }
          var isArr = isArray(value);
          if (isArr) {
            result = initCloneArray(value);
            if (!isDeep) {
              return arrayCopy(value, result);
            }
          } else {
            var tag = objToString.call(value),
                isFunc = tag == funcTag;
            if (tag == objectTag || tag == argsTag || (isFunc && !object)) {
              result = initCloneObject(isFunc ? {} : value);
              if (!isDeep) {
                return baseCopy(value, result, keys(value));
              }
            } else {
              return cloneableTags[tag] ? initCloneByTag(value, tag, isDeep) : (object ? value : {});
            }
          }
          stackA || (stackA = []);
          stackB || (stackB = []);
          var length = stackA.length;
          while (length--) {
            if (stackA[length] == value) {
              return stackB[length];
            }
          }
          stackA.push(value);
          stackB.push(result);
          (isArr ? arrayEach : baseForOwn)(value, function(subValue, key) {
            result[key] = baseClone(subValue, isDeep, customizer, key, value, stackA, stackB);
          });
          return result;
        }
        var baseCreate = (function() {
          function Object() {}
          return function(prototype) {
            if (isObject(prototype)) {
              Object.prototype = prototype;
              var result = new Object;
              Object.prototype = null;
            }
            return result || context.Object();
          };
        }());
        function baseDelay(func, wait, args, fromIndex) {
          if (typeof func != 'function') {
            throw new TypeError(FUNC_ERROR_TEXT);
          }
          return setTimeout(function() {
            func.apply(undefined, baseSlice(args, fromIndex));
          }, wait);
        }
        function baseDifference(array, values) {
          var length = array ? array.length : 0,
              result = [];
          if (!length) {
            return result;
          }
          var index = -1,
              indexOf = getIndexOf(),
              isCommon = indexOf == baseIndexOf,
              cache = (isCommon && values.length >= 200) ? createCache(values) : null,
              valuesLength = values.length;
          if (cache) {
            indexOf = cacheIndexOf;
            isCommon = false;
            values = cache;
          }
          outer: while (++index < length) {
            var value = array[index];
            if (isCommon && value === value) {
              var valuesIndex = valuesLength;
              while (valuesIndex--) {
                if (values[valuesIndex] === value) {
                  continue outer;
                }
              }
              result.push(value);
            } else if (indexOf(values, value, 0) < 0) {
              result.push(value);
            }
          }
          return result;
        }
        function baseEach(collection, iteratee) {
          var length = collection ? collection.length : 0;
          if (!isLength(length)) {
            return baseForOwn(collection, iteratee);
          }
          var index = -1,
              iterable = toObject(collection);
          while (++index < length) {
            if (iteratee(iterable[index], index, iterable) === false) {
              break;
            }
          }
          return collection;
        }
        function baseEachRight(collection, iteratee) {
          var length = collection ? collection.length : 0;
          if (!isLength(length)) {
            return baseForOwnRight(collection, iteratee);
          }
          var iterable = toObject(collection);
          while (length--) {
            if (iteratee(iterable[length], length, iterable) === false) {
              break;
            }
          }
          return collection;
        }
        function baseEvery(collection, predicate) {
          var result = true;
          baseEach(collection, function(value, index, collection) {
            result = !!predicate(value, index, collection);
            return result;
          });
          return result;
        }
        function baseFill(array, value, start, end) {
          var length = array.length;
          start = start == null ? 0 : (+start || 0);
          if (start < 0) {
            start = -start > length ? 0 : (length + start);
          }
          end = (typeof end == 'undefined' || end > length) ? length : (+end || 0);
          if (end < 0) {
            end += length;
          }
          length = start > end ? 0 : (end >>> 0);
          start >>>= 0;
          while (start < length) {
            array[start++] = value;
          }
          return array;
        }
        function baseFilter(collection, predicate) {
          var result = [];
          baseEach(collection, function(value, index, collection) {
            if (predicate(value, index, collection)) {
              result.push(value);
            }
          });
          return result;
        }
        function baseFind(collection, predicate, eachFunc, retKey) {
          var result;
          eachFunc(collection, function(value, key, collection) {
            if (predicate(value, key, collection)) {
              result = retKey ? key : value;
              return false;
            }
          });
          return result;
        }
        function baseFlatten(array, isDeep, isStrict, fromIndex) {
          var index = fromIndex - 1,
              length = array.length,
              resIndex = -1,
              result = [];
          while (++index < length) {
            var value = array[index];
            if (isObjectLike(value) && isLength(value.length) && (isArray(value) || isArguments(value))) {
              if (isDeep) {
                value = baseFlatten(value, isDeep, isStrict, 0);
              }
              var valIndex = -1,
                  valLength = value.length;
              result.length += valLength;
              while (++valIndex < valLength) {
                result[++resIndex] = value[valIndex];
              }
            } else if (!isStrict) {
              result[++resIndex] = value;
            }
          }
          return result;
        }
        function baseFor(object, iteratee, keysFunc) {
          var index = -1,
              iterable = toObject(object),
              props = keysFunc(object),
              length = props.length;
          while (++index < length) {
            var key = props[index];
            if (iteratee(iterable[key], key, iterable) === false) {
              break;
            }
          }
          return object;
        }
        function baseForRight(object, iteratee, keysFunc) {
          var iterable = toObject(object),
              props = keysFunc(object),
              length = props.length;
          while (length--) {
            var key = props[length];
            if (iteratee(iterable[key], key, iterable) === false) {
              break;
            }
          }
          return object;
        }
        function baseForIn(object, iteratee) {
          return baseFor(object, iteratee, keysIn);
        }
        function baseForOwn(object, iteratee) {
          return baseFor(object, iteratee, keys);
        }
        function baseForOwnRight(object, iteratee) {
          return baseForRight(object, iteratee, keys);
        }
        function baseFunctions(object, props) {
          var index = -1,
              length = props.length,
              resIndex = -1,
              result = [];
          while (++index < length) {
            var key = props[index];
            if (isFunction(object[key])) {
              result[++resIndex] = key;
            }
          }
          return result;
        }
        function baseInvoke(collection, methodName, args) {
          var index = -1,
              isFunc = typeof methodName == 'function',
              length = collection ? collection.length : 0,
              result = isLength(length) ? Array(length) : [];
          baseEach(collection, function(value) {
            var func = isFunc ? methodName : (value != null && value[methodName]);
            result[++index] = func ? func.apply(value, args) : undefined;
          });
          return result;
        }
        function baseIsEqual(value, other, customizer, isWhere, stackA, stackB) {
          if (value === other) {
            return value !== 0 || (1 / value == 1 / other);
          }
          var valType = typeof value,
              othType = typeof other;
          if ((valType != 'function' && valType != 'object' && othType != 'function' && othType != 'object') || value == null || other == null) {
            return value !== value && other !== other;
          }
          return baseIsEqualDeep(value, other, baseIsEqual, customizer, isWhere, stackA, stackB);
        }
        function baseIsEqualDeep(object, other, equalFunc, customizer, isWhere, stackA, stackB) {
          var objIsArr = isArray(object),
              othIsArr = isArray(other),
              objTag = arrayTag,
              othTag = arrayTag;
          if (!objIsArr) {
            objTag = objToString.call(object);
            if (objTag == argsTag) {
              objTag = objectTag;
            } else if (objTag != objectTag) {
              objIsArr = isTypedArray(object);
            }
          }
          if (!othIsArr) {
            othTag = objToString.call(other);
            if (othTag == argsTag) {
              othTag = objectTag;
            } else if (othTag != objectTag) {
              othIsArr = isTypedArray(other);
            }
          }
          var objIsObj = objTag == objectTag,
              othIsObj = othTag == objectTag,
              isSameTag = objTag == othTag;
          if (isSameTag && !(objIsArr || objIsObj)) {
            return equalByTag(object, other, objTag);
          }
          var valWrapped = objIsObj && hasOwnProperty.call(object, '__wrapped__'),
              othWrapped = othIsObj && hasOwnProperty.call(other, '__wrapped__');
          if (valWrapped || othWrapped) {
            return equalFunc(valWrapped ? object.value() : object, othWrapped ? other.value() : other, customizer, isWhere, stackA, stackB);
          }
          if (!isSameTag) {
            return false;
          }
          stackA || (stackA = []);
          stackB || (stackB = []);
          var length = stackA.length;
          while (length--) {
            if (stackA[length] == object) {
              return stackB[length] == other;
            }
          }
          stackA.push(object);
          stackB.push(other);
          var result = (objIsArr ? equalArrays : equalObjects)(object, other, equalFunc, customizer, isWhere, stackA, stackB);
          stackA.pop();
          stackB.pop();
          return result;
        }
        function baseIsMatch(object, props, values, strictCompareFlags, customizer) {
          var length = props.length;
          if (object == null) {
            return !length;
          }
          var index = -1,
              noCustomizer = !customizer;
          while (++index < length) {
            if ((noCustomizer && strictCompareFlags[index]) ? values[index] !== object[props[index]] : !hasOwnProperty.call(object, props[index])) {
              return false;
            }
          }
          index = -1;
          while (++index < length) {
            var key = props[index];
            if (noCustomizer && strictCompareFlags[index]) {
              var result = hasOwnProperty.call(object, key);
            } else {
              var objValue = object[key],
                  srcValue = values[index];
              result = customizer ? customizer(objValue, srcValue, key) : undefined;
              if (typeof result == 'undefined') {
                result = baseIsEqual(srcValue, objValue, customizer, true);
              }
            }
            if (!result) {
              return false;
            }
          }
          return true;
        }
        function baseMap(collection, iteratee) {
          var result = [];
          baseEach(collection, function(value, key, collection) {
            result.push(iteratee(value, key, collection));
          });
          return result;
        }
        function baseMatches(source) {
          var props = keys(source),
              length = props.length;
          if (length == 1) {
            var key = props[0],
                value = source[key];
            if (isStrictComparable(value)) {
              return function(object) {
                return object != null && object[key] === value && hasOwnProperty.call(object, key);
              };
            }
          }
          var values = Array(length),
              strictCompareFlags = Array(length);
          while (length--) {
            value = source[props[length]];
            values[length] = value;
            strictCompareFlags[length] = isStrictComparable(value);
          }
          return function(object) {
            return baseIsMatch(object, props, values, strictCompareFlags);
          };
        }
        function baseMatchesProperty(key, value) {
          if (isStrictComparable(value)) {
            return function(object) {
              return object != null && object[key] === value;
            };
          }
          return function(object) {
            return object != null && baseIsEqual(value, object[key], null, true);
          };
        }
        function baseMerge(object, source, customizer, stackA, stackB) {
          if (!isObject(object)) {
            return object;
          }
          var isSrcArr = isLength(source.length) && (isArray(source) || isTypedArray(source));
          (isSrcArr ? arrayEach : baseForOwn)(source, function(srcValue, key, source) {
            if (isObjectLike(srcValue)) {
              stackA || (stackA = []);
              stackB || (stackB = []);
              return baseMergeDeep(object, source, key, baseMerge, customizer, stackA, stackB);
            }
            var value = object[key],
                result = customizer ? customizer(value, srcValue, key, object, source) : undefined,
                isCommon = typeof result == 'undefined';
            if (isCommon) {
              result = srcValue;
            }
            if ((isSrcArr || typeof result != 'undefined') && (isCommon || (result === result ? (result !== value) : (value === value)))) {
              object[key] = result;
            }
          });
          return object;
        }
        function baseMergeDeep(object, source, key, mergeFunc, customizer, stackA, stackB) {
          var length = stackA.length,
              srcValue = source[key];
          while (length--) {
            if (stackA[length] == srcValue) {
              object[key] = stackB[length];
              return ;
            }
          }
          var value = object[key],
              result = customizer ? customizer(value, srcValue, key, object, source) : undefined,
              isCommon = typeof result == 'undefined';
          if (isCommon) {
            result = srcValue;
            if (isLength(srcValue.length) && (isArray(srcValue) || isTypedArray(srcValue))) {
              result = isArray(value) ? value : (value ? arrayCopy(value) : []);
            } else if (isPlainObject(srcValue) || isArguments(srcValue)) {
              result = isArguments(value) ? toPlainObject(value) : (isPlainObject(value) ? value : {});
            } else {
              isCommon = false;
            }
          }
          stackA.push(srcValue);
          stackB.push(result);
          if (isCommon) {
            object[key] = mergeFunc(result, srcValue, customizer, stackA, stackB);
          } else if (result === result ? (result !== value) : (value === value)) {
            object[key] = result;
          }
        }
        function baseProperty(key) {
          return function(object) {
            return object == null ? undefined : object[key];
          };
        }
        function basePullAt(array, indexes) {
          var length = indexes.length,
              result = baseAt(array, indexes);
          indexes.sort(baseCompareAscending);
          while (length--) {
            var index = parseFloat(indexes[length]);
            if (index != previous && isIndex(index)) {
              var previous = index;
              splice.call(array, index, 1);
            }
          }
          return result;
        }
        function baseRandom(min, max) {
          return min + floor(nativeRandom() * (max - min + 1));
        }
        function baseReduce(collection, iteratee, accumulator, initFromCollection, eachFunc) {
          eachFunc(collection, function(value, index, collection) {
            accumulator = initFromCollection ? (initFromCollection = false, value) : iteratee(accumulator, value, index, collection);
          });
          return accumulator;
        }
        var baseSetData = !metaMap ? identity : function(func, data) {
          metaMap.set(func, data);
          return func;
        };
        function baseSlice(array, start, end) {
          var index = -1,
              length = array.length;
          start = start == null ? 0 : (+start || 0);
          if (start < 0) {
            start = -start > length ? 0 : (length + start);
          }
          end = (typeof end == 'undefined' || end > length) ? length : (+end || 0);
          if (end < 0) {
            end += length;
          }
          length = start > end ? 0 : ((end - start) >>> 0);
          start >>>= 0;
          var result = Array(length);
          while (++index < length) {
            result[index] = array[index + start];
          }
          return result;
        }
        function baseSome(collection, predicate) {
          var result;
          baseEach(collection, function(value, index, collection) {
            result = predicate(value, index, collection);
            return !result;
          });
          return !!result;
        }
        function baseSortBy(array, comparer) {
          var length = array.length;
          array.sort(comparer);
          while (length--) {
            array[length] = array[length].value;
          }
          return array;
        }
        function baseSortByOrder(collection, props, orders) {
          var index = -1,
              length = collection.length,
              result = isLength(length) ? Array(length) : [];
          baseEach(collection, function(value) {
            var length = props.length,
                criteria = Array(length);
            while (length--) {
              criteria[length] = value == null ? undefined : value[props[length]];
            }
            result[++index] = {
              'criteria': criteria,
              'index': index,
              'value': value
            };
          });
          return baseSortBy(result, function(object, other) {
            return compareMultiple(object, other, orders);
          });
        }
        function baseUniq(array, iteratee) {
          var index = -1,
              indexOf = getIndexOf(),
              length = array.length,
              isCommon = indexOf == baseIndexOf,
              isLarge = isCommon && length >= 200,
              seen = isLarge ? createCache() : null,
              result = [];
          if (seen) {
            indexOf = cacheIndexOf;
            isCommon = false;
          } else {
            isLarge = false;
            seen = iteratee ? [] : result;
          }
          outer: while (++index < length) {
            var value = array[index],
                computed = iteratee ? iteratee(value, index, array) : value;
            if (isCommon && value === value) {
              var seenIndex = seen.length;
              while (seenIndex--) {
                if (seen[seenIndex] === computed) {
                  continue outer;
                }
              }
              if (iteratee) {
                seen.push(computed);
              }
              result.push(value);
            } else if (indexOf(seen, computed, 0) < 0) {
              if (iteratee || isLarge) {
                seen.push(computed);
              }
              result.push(value);
            }
          }
          return result;
        }
        function baseValues(object, props) {
          var index = -1,
              length = props.length,
              result = Array(length);
          while (++index < length) {
            result[index] = object[props[index]];
          }
          return result;
        }
        function baseWrapperValue(value, actions) {
          var result = value;
          if (result instanceof LazyWrapper) {
            result = result.value();
          }
          var index = -1,
              length = actions.length;
          while (++index < length) {
            var args = [result],
                action = actions[index];
            push.apply(args, action.args);
            result = action.func.apply(action.thisArg, args);
          }
          return result;
        }
        function binaryIndex(array, value, retHighest) {
          var low = 0,
              high = array ? array.length : low;
          if (typeof value == 'number' && value === value && high <= HALF_MAX_ARRAY_LENGTH) {
            while (low < high) {
              var mid = (low + high) >>> 1,
                  computed = array[mid];
              if (retHighest ? (computed <= value) : (computed < value)) {
                low = mid + 1;
              } else {
                high = mid;
              }
            }
            return high;
          }
          return binaryIndexBy(array, value, identity, retHighest);
        }
        function binaryIndexBy(array, value, iteratee, retHighest) {
          value = iteratee(value);
          var low = 0,
              high = array ? array.length : 0,
              valIsNaN = value !== value,
              valIsUndef = typeof value == 'undefined';
          while (low < high) {
            var mid = floor((low + high) / 2),
                computed = iteratee(array[mid]),
                isReflexive = computed === computed;
            if (valIsNaN) {
              var setLow = isReflexive || retHighest;
            } else if (valIsUndef) {
              setLow = isReflexive && (retHighest || typeof computed != 'undefined');
            } else {
              setLow = retHighest ? (computed <= value) : (computed < value);
            }
            if (setLow) {
              low = mid + 1;
            } else {
              high = mid;
            }
          }
          return nativeMin(high, MAX_ARRAY_INDEX);
        }
        function bindCallback(func, thisArg, argCount) {
          if (typeof func != 'function') {
            return identity;
          }
          if (typeof thisArg == 'undefined') {
            return func;
          }
          switch (argCount) {
            case 1:
              return function(value) {
                return func.call(thisArg, value);
              };
            case 3:
              return function(value, index, collection) {
                return func.call(thisArg, value, index, collection);
              };
            case 4:
              return function(accumulator, value, index, collection) {
                return func.call(thisArg, accumulator, value, index, collection);
              };
            case 5:
              return function(value, other, key, object, source) {
                return func.call(thisArg, value, other, key, object, source);
              };
          }
          return function() {
            return func.apply(thisArg, arguments);
          };
        }
        function bufferClone(buffer) {
          return bufferSlice.call(buffer, 0);
        }
        if (!bufferSlice) {
          bufferClone = !(ArrayBuffer && Uint8Array) ? constant(null) : function(buffer) {
            var byteLength = buffer.byteLength,
                floatLength = Float64Array ? floor(byteLength / FLOAT64_BYTES_PER_ELEMENT) : 0,
                offset = floatLength * FLOAT64_BYTES_PER_ELEMENT,
                result = new ArrayBuffer(byteLength);
            if (floatLength) {
              var view = new Float64Array(result, 0, floatLength);
              view.set(new Float64Array(buffer, 0, floatLength));
            }
            if (byteLength != offset) {
              view = new Uint8Array(result, offset);
              view.set(new Uint8Array(buffer, offset));
            }
            return result;
          };
        }
        function composeArgs(args, partials, holders) {
          var holdersLength = holders.length,
              argsIndex = -1,
              argsLength = nativeMax(args.length - holdersLength, 0),
              leftIndex = -1,
              leftLength = partials.length,
              result = Array(argsLength + leftLength);
          while (++leftIndex < leftLength) {
            result[leftIndex] = partials[leftIndex];
          }
          while (++argsIndex < holdersLength) {
            result[holders[argsIndex]] = args[argsIndex];
          }
          while (argsLength--) {
            result[leftIndex++] = args[argsIndex++];
          }
          return result;
        }
        function composeArgsRight(args, partials, holders) {
          var holdersIndex = -1,
              holdersLength = holders.length,
              argsIndex = -1,
              argsLength = nativeMax(args.length - holdersLength, 0),
              rightIndex = -1,
              rightLength = partials.length,
              result = Array(argsLength + rightLength);
          while (++argsIndex < argsLength) {
            result[argsIndex] = args[argsIndex];
          }
          var pad = argsIndex;
          while (++rightIndex < rightLength) {
            result[pad + rightIndex] = partials[rightIndex];
          }
          while (++holdersIndex < holdersLength) {
            result[pad + holders[holdersIndex]] = args[argsIndex++];
          }
          return result;
        }
        function createAggregator(setter, initializer) {
          return function(collection, iteratee, thisArg) {
            var result = initializer ? initializer() : {};
            iteratee = getCallback(iteratee, thisArg, 3);
            if (isArray(collection)) {
              var index = -1,
                  length = collection.length;
              while (++index < length) {
                var value = collection[index];
                setter(result, value, iteratee(value, index, collection), collection);
              }
            } else {
              baseEach(collection, function(value, key, collection) {
                setter(result, value, iteratee(value, key, collection), collection);
              });
            }
            return result;
          };
        }
        function createAssigner(assigner) {
          return function() {
            var args = arguments,
                length = args.length,
                object = args[0];
            if (length < 2 || object == null) {
              return object;
            }
            var customizer = args[length - 2],
                thisArg = args[length - 1],
                guard = args[3];
            if (length > 3 && typeof customizer == 'function') {
              customizer = bindCallback(customizer, thisArg, 5);
              length -= 2;
            } else {
              customizer = (length > 2 && typeof thisArg == 'function') ? thisArg : null;
              length -= (customizer ? 1 : 0);
            }
            if (guard && isIterateeCall(args[1], args[2], guard)) {
              customizer = length == 3 ? null : customizer;
              length = 2;
            }
            var index = 0;
            while (++index < length) {
              var source = args[index];
              if (source) {
                assigner(object, source, customizer);
              }
            }
            return object;
          };
        }
        function createBindWrapper(func, thisArg) {
          var Ctor = createCtorWrapper(func);
          function wrapper() {
            var fn = (this && this !== root && this instanceof wrapper) ? Ctor : func;
            return fn.apply(thisArg, arguments);
          }
          return wrapper;
        }
        var createCache = !(nativeCreate && Set) ? constant(null) : function(values) {
          return new SetCache(values);
        };
        function createComposer(fromRight) {
          return function() {
            var length = arguments.length,
                index = length,
                fromIndex = fromRight ? (length - 1) : 0;
            if (!length) {
              return function() {
                return arguments[0];
              };
            }
            var funcs = Array(length);
            while (index--) {
              funcs[index] = arguments[index];
              if (typeof funcs[index] != 'function') {
                throw new TypeError(FUNC_ERROR_TEXT);
              }
            }
            return function() {
              var index = fromIndex,
                  result = funcs[index].apply(this, arguments);
              while ((fromRight ? index-- : ++index < length)) {
                result = funcs[index].call(this, result);
              }
              return result;
            };
          };
        }
        function createCompounder(callback) {
          return function(string) {
            var index = -1,
                array = words(deburr(string)),
                length = array.length,
                result = '';
            while (++index < length) {
              result = callback(result, array[index], index);
            }
            return result;
          };
        }
        function createCtorWrapper(Ctor) {
          return function() {
            var thisBinding = baseCreate(Ctor.prototype),
                result = Ctor.apply(thisBinding, arguments);
            return isObject(result) ? result : thisBinding;
          };
        }
        function createExtremum(arrayFunc, isMin) {
          return function(collection, iteratee, thisArg) {
            if (thisArg && isIterateeCall(collection, iteratee, thisArg)) {
              iteratee = null;
            }
            var func = getCallback(),
                noIteratee = iteratee == null;
            if (!(func === baseCallback && noIteratee)) {
              noIteratee = false;
              iteratee = func(iteratee, thisArg, 3);
            }
            if (noIteratee) {
              var isArr = isArray(collection);
              if (!isArr && isString(collection)) {
                iteratee = charAtCallback;
              } else {
                return arrayFunc(isArr ? collection : toIterable(collection));
              }
            }
            return extremumBy(collection, iteratee, isMin);
          };
        }
        function createHybridWrapper(func, bitmask, thisArg, partials, holders, partialsRight, holdersRight, argPos, ary, arity) {
          var isAry = bitmask & ARY_FLAG,
              isBind = bitmask & BIND_FLAG,
              isBindKey = bitmask & BIND_KEY_FLAG,
              isCurry = bitmask & CURRY_FLAG,
              isCurryBound = bitmask & CURRY_BOUND_FLAG,
              isCurryRight = bitmask & CURRY_RIGHT_FLAG;
          var Ctor = !isBindKey && createCtorWrapper(func),
              key = func;
          function wrapper() {
            var length = arguments.length,
                index = length,
                args = Array(length);
            while (index--) {
              args[index] = arguments[index];
            }
            if (partials) {
              args = composeArgs(args, partials, holders);
            }
            if (partialsRight) {
              args = composeArgsRight(args, partialsRight, holdersRight);
            }
            if (isCurry || isCurryRight) {
              var placeholder = wrapper.placeholder,
                  argsHolders = replaceHolders(args, placeholder);
              length -= argsHolders.length;
              if (length < arity) {
                var newArgPos = argPos ? arrayCopy(argPos) : null,
                    newArity = nativeMax(arity - length, 0),
                    newsHolders = isCurry ? argsHolders : null,
                    newHoldersRight = isCurry ? null : argsHolders,
                    newPartials = isCurry ? args : null,
                    newPartialsRight = isCurry ? null : args;
                bitmask |= (isCurry ? PARTIAL_FLAG : PARTIAL_RIGHT_FLAG);
                bitmask &= ~(isCurry ? PARTIAL_RIGHT_FLAG : PARTIAL_FLAG);
                if (!isCurryBound) {
                  bitmask &= ~(BIND_FLAG | BIND_KEY_FLAG);
                }
                var result = createHybridWrapper(func, bitmask, thisArg, newPartials, newsHolders, newPartialsRight, newHoldersRight, newArgPos, ary, newArity);
                result.placeholder = placeholder;
                return result;
              }
            }
            var thisBinding = isBind ? thisArg : this;
            if (isBindKey) {
              func = thisBinding[key];
            }
            if (argPos) {
              args = reorder(args, argPos);
            }
            if (isAry && ary < args.length) {
              args.length = ary;
            }
            var fn = (this && this !== root && this instanceof wrapper) ? (Ctor || createCtorWrapper(func)) : func;
            return fn.apply(thisBinding, args);
          }
          return wrapper;
        }
        function createPad(string, length, chars) {
          var strLength = string.length;
          length = +length;
          if (strLength >= length || !nativeIsFinite(length)) {
            return '';
          }
          var padLength = length - strLength;
          chars = chars == null ? ' ' : (chars + '');
          return repeat(chars, ceil(padLength / chars.length)).slice(0, padLength);
        }
        function createPartialWrapper(func, bitmask, thisArg, partials) {
          var isBind = bitmask & BIND_FLAG,
              Ctor = createCtorWrapper(func);
          function wrapper() {
            var argsIndex = -1,
                argsLength = arguments.length,
                leftIndex = -1,
                leftLength = partials.length,
                args = Array(argsLength + leftLength);
            while (++leftIndex < leftLength) {
              args[leftIndex] = partials[leftIndex];
            }
            while (argsLength--) {
              args[leftIndex++] = arguments[++argsIndex];
            }
            var fn = (this && this !== root && this instanceof wrapper) ? Ctor : func;
            return fn.apply(isBind ? thisArg : this, args);
          }
          return wrapper;
        }
        function createWrapper(func, bitmask, thisArg, partials, holders, argPos, ary, arity) {
          var isBindKey = bitmask & BIND_KEY_FLAG;
          if (!isBindKey && typeof func != 'function') {
            throw new TypeError(FUNC_ERROR_TEXT);
          }
          var length = partials ? partials.length : 0;
          if (!length) {
            bitmask &= ~(PARTIAL_FLAG | PARTIAL_RIGHT_FLAG);
            partials = holders = null;
          }
          length -= (holders ? holders.length : 0);
          if (bitmask & PARTIAL_RIGHT_FLAG) {
            var partialsRight = partials,
                holdersRight = holders;
            partials = holders = null;
          }
          var data = !isBindKey && getData(func),
              newData = [func, bitmask, thisArg, partials, holders, partialsRight, holdersRight, argPos, ary, arity];
          if (data && data !== true) {
            mergeData(newData, data);
            bitmask = newData[1];
            arity = newData[9];
          }
          newData[9] = arity == null ? (isBindKey ? 0 : func.length) : (nativeMax(arity - length, 0) || 0);
          if (bitmask == BIND_FLAG) {
            var result = createBindWrapper(newData[0], newData[2]);
          } else if ((bitmask == PARTIAL_FLAG || bitmask == (BIND_FLAG | PARTIAL_FLAG)) && !newData[4].length) {
            result = createPartialWrapper.apply(undefined, newData);
          } else {
            result = createHybridWrapper.apply(undefined, newData);
          }
          var setter = data ? baseSetData : setData;
          return setter(result, newData);
        }
        function equalArrays(array, other, equalFunc, customizer, isWhere, stackA, stackB) {
          var index = -1,
              arrLength = array.length,
              othLength = other.length,
              result = true;
          if (arrLength != othLength && !(isWhere && othLength > arrLength)) {
            return false;
          }
          while (result && ++index < arrLength) {
            var arrValue = array[index],
                othValue = other[index];
            result = undefined;
            if (customizer) {
              result = isWhere ? customizer(othValue, arrValue, index) : customizer(arrValue, othValue, index);
            }
            if (typeof result == 'undefined') {
              if (isWhere) {
                var othIndex = othLength;
                while (othIndex--) {
                  othValue = other[othIndex];
                  result = (arrValue && arrValue === othValue) || equalFunc(arrValue, othValue, customizer, isWhere, stackA, stackB);
                  if (result) {
                    break;
                  }
                }
              } else {
                result = (arrValue && arrValue === othValue) || equalFunc(arrValue, othValue, customizer, isWhere, stackA, stackB);
              }
            }
          }
          return !!result;
        }
        function equalByTag(object, other, tag) {
          switch (tag) {
            case boolTag:
            case dateTag:
              return +object == +other;
            case errorTag:
              return object.name == other.name && object.message == other.message;
            case numberTag:
              return (object != +object) ? other != +other : (object == 0 ? ((1 / object) == (1 / other)) : object == +other);
            case regexpTag:
            case stringTag:
              return object == (other + '');
          }
          return false;
        }
        function equalObjects(object, other, equalFunc, customizer, isWhere, stackA, stackB) {
          var objProps = keys(object),
              objLength = objProps.length,
              othProps = keys(other),
              othLength = othProps.length;
          if (objLength != othLength && !isWhere) {
            return false;
          }
          var hasCtor,
              index = -1;
          while (++index < objLength) {
            var key = objProps[index],
                result = hasOwnProperty.call(other, key);
            if (result) {
              var objValue = object[key],
                  othValue = other[key];
              result = undefined;
              if (customizer) {
                result = isWhere ? customizer(othValue, objValue, key) : customizer(objValue, othValue, key);
              }
              if (typeof result == 'undefined') {
                result = (objValue && objValue === othValue) || equalFunc(objValue, othValue, customizer, isWhere, stackA, stackB);
              }
            }
            if (!result) {
              return false;
            }
            hasCtor || (hasCtor = key == 'constructor');
          }
          if (!hasCtor) {
            var objCtor = object.constructor,
                othCtor = other.constructor;
            if (objCtor != othCtor && ('constructor' in object && 'constructor' in other) && !(typeof objCtor == 'function' && objCtor instanceof objCtor && typeof othCtor == 'function' && othCtor instanceof othCtor)) {
              return false;
            }
          }
          return true;
        }
        function extremumBy(collection, iteratee, isMin) {
          var exValue = isMin ? POSITIVE_INFINITY : NEGATIVE_INFINITY,
              computed = exValue,
              result = computed;
          baseEach(collection, function(value, index, collection) {
            var current = iteratee(value, index, collection);
            if ((isMin ? (current < computed) : (current > computed)) || (current === exValue && current === result)) {
              computed = current;
              result = value;
            }
          });
          return result;
        }
        function getCallback(func, thisArg, argCount) {
          var result = lodash.callback || callback;
          result = result === callback ? baseCallback : result;
          return argCount ? result(func, thisArg, argCount) : result;
        }
        var getData = !metaMap ? noop : function(func) {
          return metaMap.get(func);
        };
        function getIndexOf(collection, target, fromIndex) {
          var result = lodash.indexOf || indexOf;
          result = result === indexOf ? baseIndexOf : result;
          return collection ? result(collection, target, fromIndex) : result;
        }
        function getView(start, end, transforms) {
          var index = -1,
              length = transforms ? transforms.length : 0;
          while (++index < length) {
            var data = transforms[index],
                size = data.size;
            switch (data.type) {
              case 'drop':
                start += size;
                break;
              case 'dropRight':
                end -= size;
                break;
              case 'take':
                end = nativeMin(end, start + size);
                break;
              case 'takeRight':
                start = nativeMax(start, end - size);
                break;
            }
          }
          return {
            'start': start,
            'end': end
          };
        }
        function initCloneArray(array) {
          var length = array.length,
              result = new array.constructor(length);
          if (length && typeof array[0] == 'string' && hasOwnProperty.call(array, 'index')) {
            result.index = array.index;
            result.input = array.input;
          }
          return result;
        }
        function initCloneObject(object) {
          var Ctor = object.constructor;
          if (!(typeof Ctor == 'function' && Ctor instanceof Ctor)) {
            Ctor = Object;
          }
          return new Ctor;
        }
        function initCloneByTag(object, tag, isDeep) {
          var Ctor = object.constructor;
          switch (tag) {
            case arrayBufferTag:
              return bufferClone(object);
            case boolTag:
            case dateTag:
              return new Ctor(+object);
            case float32Tag:
            case float64Tag:
            case int8Tag:
            case int16Tag:
            case int32Tag:
            case uint8Tag:
            case uint8ClampedTag:
            case uint16Tag:
            case uint32Tag:
              var buffer = object.buffer;
              return new Ctor(isDeep ? bufferClone(buffer) : buffer, object.byteOffset, object.length);
            case numberTag:
            case stringTag:
              return new Ctor(object);
            case regexpTag:
              var result = new Ctor(object.source, reFlags.exec(object));
              result.lastIndex = object.lastIndex;
          }
          return result;
        }
        function isBindable(func) {
          var support = lodash.support,
              result = !(support.funcNames ? func.name : support.funcDecomp);
          if (!result) {
            var source = fnToString.call(func);
            if (!support.funcNames) {
              result = !reFuncName.test(source);
            }
            if (!result) {
              result = reThis.test(source) || isNative(func);
              baseSetData(func, result);
            }
          }
          return result;
        }
        function isIndex(value, length) {
          value = +value;
          length = length == null ? MAX_SAFE_INTEGER : length;
          return value > -1 && value % 1 == 0 && value < length;
        }
        function isIterateeCall(value, index, object) {
          if (!isObject(object)) {
            return false;
          }
          var type = typeof index;
          if (type == 'number') {
            var length = object.length,
                prereq = isLength(length) && isIndex(index, length);
          } else {
            prereq = type == 'string' && index in object;
          }
          if (prereq) {
            var other = object[index];
            return value === value ? (value === other) : (other !== other);
          }
          return false;
        }
        function isLength(value) {
          return typeof value == 'number' && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
        }
        function isStrictComparable(value) {
          return value === value && (value === 0 ? ((1 / value) > 0) : !isObject(value));
        }
        function mergeData(data, source) {
          var bitmask = data[1],
              srcBitmask = source[1],
              newBitmask = bitmask | srcBitmask;
          var arityFlags = ARY_FLAG | REARG_FLAG,
              bindFlags = BIND_FLAG | BIND_KEY_FLAG,
              comboFlags = arityFlags | bindFlags | CURRY_BOUND_FLAG | CURRY_RIGHT_FLAG;
          var isAry = bitmask & ARY_FLAG && !(srcBitmask & ARY_FLAG),
              isRearg = bitmask & REARG_FLAG && !(srcBitmask & REARG_FLAG),
              argPos = (isRearg ? data : source)[7],
              ary = (isAry ? data : source)[8];
          var isCommon = !(bitmask >= REARG_FLAG && srcBitmask > bindFlags) && !(bitmask > bindFlags && srcBitmask >= REARG_FLAG);
          var isCombo = (newBitmask >= arityFlags && newBitmask <= comboFlags) && (bitmask < REARG_FLAG || ((isRearg || isAry) && argPos.length <= ary));
          if (!(isCommon || isCombo)) {
            return data;
          }
          if (srcBitmask & BIND_FLAG) {
            data[2] = source[2];
            newBitmask |= (bitmask & BIND_FLAG) ? 0 : CURRY_BOUND_FLAG;
          }
          var value = source[3];
          if (value) {
            var partials = data[3];
            data[3] = partials ? composeArgs(partials, value, source[4]) : arrayCopy(value);
            data[4] = partials ? replaceHolders(data[3], PLACEHOLDER) : arrayCopy(source[4]);
          }
          value = source[5];
          if (value) {
            partials = data[5];
            data[5] = partials ? composeArgsRight(partials, value, source[6]) : arrayCopy(value);
            data[6] = partials ? replaceHolders(data[5], PLACEHOLDER) : arrayCopy(source[6]);
          }
          value = source[7];
          if (value) {
            data[7] = arrayCopy(value);
          }
          if (srcBitmask & ARY_FLAG) {
            data[8] = data[8] == null ? source[8] : nativeMin(data[8], source[8]);
          }
          if (data[9] == null) {
            data[9] = source[9];
          }
          data[0] = source[0];
          data[1] = newBitmask;
          return data;
        }
        function pickByArray(object, props) {
          object = toObject(object);
          var index = -1,
              length = props.length,
              result = {};
          while (++index < length) {
            var key = props[index];
            if (key in object) {
              result[key] = object[key];
            }
          }
          return result;
        }
        function pickByCallback(object, predicate) {
          var result = {};
          baseForIn(object, function(value, key, object) {
            if (predicate(value, key, object)) {
              result[key] = value;
            }
          });
          return result;
        }
        function reorder(array, indexes) {
          var arrLength = array.length,
              length = nativeMin(indexes.length, arrLength),
              oldArray = arrayCopy(array);
          while (length--) {
            var index = indexes[length];
            array[length] = isIndex(index, arrLength) ? oldArray[index] : undefined;
          }
          return array;
        }
        var setData = (function() {
          var count = 0,
              lastCalled = 0;
          return function(key, value) {
            var stamp = now(),
                remaining = HOT_SPAN - (stamp - lastCalled);
            lastCalled = stamp;
            if (remaining > 0) {
              if (++count >= HOT_COUNT) {
                return key;
              }
            } else {
              count = 0;
            }
            return baseSetData(key, value);
          };
        }());
        function shimIsPlainObject(value) {
          var Ctor,
              support = lodash.support;
          if (!(isObjectLike(value) && objToString.call(value) == objectTag) || (!hasOwnProperty.call(value, 'constructor') && (Ctor = value.constructor, typeof Ctor == 'function' && !(Ctor instanceof Ctor)))) {
            return false;
          }
          var result;
          baseForIn(value, function(subValue, key) {
            result = key;
          });
          return typeof result == 'undefined' || hasOwnProperty.call(value, result);
        }
        function shimKeys(object) {
          var props = keysIn(object),
              propsLength = props.length,
              length = propsLength && object.length,
              support = lodash.support;
          var allowIndexes = length && isLength(length) && (isArray(object) || (support.nonEnumArgs && isArguments(object)));
          var index = -1,
              result = [];
          while (++index < propsLength) {
            var key = props[index];
            if ((allowIndexes && isIndex(key, length)) || hasOwnProperty.call(object, key)) {
              result.push(key);
            }
          }
          return result;
        }
        function toIterable(value) {
          if (value == null) {
            return [];
          }
          if (!isLength(value.length)) {
            return values(value);
          }
          return isObject(value) ? value : Object(value);
        }
        function toObject(value) {
          return isObject(value) ? value : Object(value);
        }
        function wrapperClone(wrapper) {
          return wrapper instanceof LazyWrapper ? wrapper.clone() : new LodashWrapper(wrapper.__wrapped__, wrapper.__chain__, arrayCopy(wrapper.__actions__));
        }
        function chunk(array, size, guard) {
          if (guard ? isIterateeCall(array, size, guard) : size == null) {
            size = 1;
          } else {
            size = nativeMax(+size || 1, 1);
          }
          var index = 0,
              length = array ? array.length : 0,
              resIndex = -1,
              result = Array(ceil(length / size));
          while (index < length) {
            result[++resIndex] = baseSlice(array, index, (index += size));
          }
          return result;
        }
        function compact(array) {
          var index = -1,
              length = array ? array.length : 0,
              resIndex = -1,
              result = [];
          while (++index < length) {
            var value = array[index];
            if (value) {
              result[++resIndex] = value;
            }
          }
          return result;
        }
        function difference() {
          var args = arguments,
              index = -1,
              length = args.length;
          while (++index < length) {
            var value = args[index];
            if (isArray(value) || isArguments(value)) {
              break;
            }
          }
          return baseDifference(value, baseFlatten(args, false, true, ++index));
        }
        function drop(array, n, guard) {
          var length = array ? array.length : 0;
          if (!length) {
            return [];
          }
          if (guard ? isIterateeCall(array, n, guard) : n == null) {
            n = 1;
          }
          return baseSlice(array, n < 0 ? 0 : n);
        }
        function dropRight(array, n, guard) {
          var length = array ? array.length : 0;
          if (!length) {
            return [];
          }
          if (guard ? isIterateeCall(array, n, guard) : n == null) {
            n = 1;
          }
          n = length - (+n || 0);
          return baseSlice(array, 0, n < 0 ? 0 : n);
        }
        function dropRightWhile(array, predicate, thisArg) {
          var length = array ? array.length : 0;
          if (!length) {
            return [];
          }
          predicate = getCallback(predicate, thisArg, 3);
          while (length-- && predicate(array[length], length, array)) {}
          return baseSlice(array, 0, length + 1);
        }
        function dropWhile(array, predicate, thisArg) {
          var length = array ? array.length : 0;
          if (!length) {
            return [];
          }
          var index = -1;
          predicate = getCallback(predicate, thisArg, 3);
          while (++index < length && predicate(array[index], index, array)) {}
          return baseSlice(array, index);
        }
        function fill(array, value, start, end) {
          var length = array ? array.length : 0;
          if (!length) {
            return [];
          }
          if (start && typeof start != 'number' && isIterateeCall(array, value, start)) {
            start = 0;
            end = length;
          }
          return baseFill(array, value, start, end);
        }
        function findIndex(array, predicate, thisArg) {
          var index = -1,
              length = array ? array.length : 0;
          predicate = getCallback(predicate, thisArg, 3);
          while (++index < length) {
            if (predicate(array[index], index, array)) {
              return index;
            }
          }
          return -1;
        }
        function findLastIndex(array, predicate, thisArg) {
          var length = array ? array.length : 0;
          predicate = getCallback(predicate, thisArg, 3);
          while (length--) {
            if (predicate(array[length], length, array)) {
              return length;
            }
          }
          return -1;
        }
        function first(array) {
          return array ? array[0] : undefined;
        }
        function flatten(array, isDeep, guard) {
          var length = array ? array.length : 0;
          if (guard && isIterateeCall(array, isDeep, guard)) {
            isDeep = false;
          }
          return length ? baseFlatten(array, isDeep, false, 0) : [];
        }
        function flattenDeep(array) {
          var length = array ? array.length : 0;
          return length ? baseFlatten(array, true, false, 0) : [];
        }
        function indexOf(array, value, fromIndex) {
          var length = array ? array.length : 0;
          if (!length) {
            return -1;
          }
          if (typeof fromIndex == 'number') {
            fromIndex = fromIndex < 0 ? nativeMax(length + fromIndex, 0) : fromIndex;
          } else if (fromIndex) {
            var index = binaryIndex(array, value),
                other = array[index];
            if (value === value ? (value === other) : (other !== other)) {
              return index;
            }
            return -1;
          }
          return baseIndexOf(array, value, fromIndex || 0);
        }
        function initial(array) {
          return dropRight(array, 1);
        }
        function intersection() {
          var args = [],
              argsIndex = -1,
              argsLength = arguments.length,
              caches = [],
              indexOf = getIndexOf(),
              isCommon = indexOf == baseIndexOf;
          while (++argsIndex < argsLength) {
            var value = arguments[argsIndex];
            if (isArray(value) || isArguments(value)) {
              args.push(value);
              caches.push((isCommon && value.length >= 120) ? createCache(argsIndex && value) : null);
            }
          }
          argsLength = args.length;
          var array = args[0],
              index = -1,
              length = array ? array.length : 0,
              result = [],
              seen = caches[0];
          outer: while (++index < length) {
            value = array[index];
            if ((seen ? cacheIndexOf(seen, value) : indexOf(result, value, 0)) < 0) {
              argsIndex = argsLength;
              while (--argsIndex) {
                var cache = caches[argsIndex];
                if ((cache ? cacheIndexOf(cache, value) : indexOf(args[argsIndex], value, 0)) < 0) {
                  continue outer;
                }
              }
              if (seen) {
                seen.push(value);
              }
              result.push(value);
            }
          }
          return result;
        }
        function last(array) {
          var length = array ? array.length : 0;
          return length ? array[length - 1] : undefined;
        }
        function lastIndexOf(array, value, fromIndex) {
          var length = array ? array.length : 0;
          if (!length) {
            return -1;
          }
          var index = length;
          if (typeof fromIndex == 'number') {
            index = (fromIndex < 0 ? nativeMax(length + fromIndex, 0) : nativeMin(fromIndex || 0, length - 1)) + 1;
          } else if (fromIndex) {
            index = binaryIndex(array, value, true) - 1;
            var other = array[index];
            if (value === value ? (value === other) : (other !== other)) {
              return index;
            }
            return -1;
          }
          if (value !== value) {
            return indexOfNaN(array, index, true);
          }
          while (index--) {
            if (array[index] === value) {
              return index;
            }
          }
          return -1;
        }
        function pull() {
          var args = arguments,
              array = args[0];
          if (!(array && array.length)) {
            return array;
          }
          var index = 0,
              indexOf = getIndexOf(),
              length = args.length;
          while (++index < length) {
            var fromIndex = 0,
                value = args[index];
            while ((fromIndex = indexOf(array, value, fromIndex)) > -1) {
              splice.call(array, fromIndex, 1);
            }
          }
          return array;
        }
        function pullAt(array) {
          return basePullAt(array || [], baseFlatten(arguments, false, false, 1));
        }
        function remove(array, predicate, thisArg) {
          var index = -1,
              length = array ? array.length : 0,
              result = [];
          predicate = getCallback(predicate, thisArg, 3);
          while (++index < length) {
            var value = array[index];
            if (predicate(value, index, array)) {
              result.push(value);
              splice.call(array, index--, 1);
              length--;
            }
          }
          return result;
        }
        function rest(array) {
          return drop(array, 1);
        }
        function slice(array, start, end) {
          var length = array ? array.length : 0;
          if (!length) {
            return [];
          }
          if (end && typeof end != 'number' && isIterateeCall(array, start, end)) {
            start = 0;
            end = length;
          }
          return baseSlice(array, start, end);
        }
        function sortedIndex(array, value, iteratee, thisArg) {
          var func = getCallback(iteratee);
          return (func === baseCallback && iteratee == null) ? binaryIndex(array, value) : binaryIndexBy(array, value, func(iteratee, thisArg, 1));
        }
        function sortedLastIndex(array, value, iteratee, thisArg) {
          var func = getCallback(iteratee);
          return (func === baseCallback && iteratee == null) ? binaryIndex(array, value, true) : binaryIndexBy(array, value, func(iteratee, thisArg, 1), true);
        }
        function take(array, n, guard) {
          var length = array ? array.length : 0;
          if (!length) {
            return [];
          }
          if (guard ? isIterateeCall(array, n, guard) : n == null) {
            n = 1;
          }
          return baseSlice(array, 0, n < 0 ? 0 : n);
        }
        function takeRight(array, n, guard) {
          var length = array ? array.length : 0;
          if (!length) {
            return [];
          }
          if (guard ? isIterateeCall(array, n, guard) : n == null) {
            n = 1;
          }
          n = length - (+n || 0);
          return baseSlice(array, n < 0 ? 0 : n);
        }
        function takeRightWhile(array, predicate, thisArg) {
          var length = array ? array.length : 0;
          if (!length) {
            return [];
          }
          predicate = getCallback(predicate, thisArg, 3);
          while (length-- && predicate(array[length], length, array)) {}
          return baseSlice(array, length + 1);
        }
        function takeWhile(array, predicate, thisArg) {
          var length = array ? array.length : 0;
          if (!length) {
            return [];
          }
          var index = -1;
          predicate = getCallback(predicate, thisArg, 3);
          while (++index < length && predicate(array[index], index, array)) {}
          return baseSlice(array, 0, index);
        }
        function union() {
          return baseUniq(baseFlatten(arguments, false, true, 0));
        }
        function uniq(array, isSorted, iteratee, thisArg) {
          var length = array ? array.length : 0;
          if (!length) {
            return [];
          }
          if (isSorted != null && typeof isSorted != 'boolean') {
            thisArg = iteratee;
            iteratee = isIterateeCall(array, isSorted, thisArg) ? null : isSorted;
            isSorted = false;
          }
          var func = getCallback();
          if (!(func === baseCallback && iteratee == null)) {
            iteratee = func(iteratee, thisArg, 3);
          }
          return (isSorted && getIndexOf() == baseIndexOf) ? sortedUniq(array, iteratee) : baseUniq(array, iteratee);
        }
        function unzip(array) {
          var index = -1,
              length = (array && array.length && arrayMax(arrayMap(array, getLength))) >>> 0,
              result = Array(length);
          while (++index < length) {
            result[index] = arrayMap(array, baseProperty(index));
          }
          return result;
        }
        function without(array) {
          return baseDifference(array, baseSlice(arguments, 1));
        }
        function xor() {
          var index = -1,
              length = arguments.length;
          while (++index < length) {
            var array = arguments[index];
            if (isArray(array) || isArguments(array)) {
              var result = result ? baseDifference(result, array).concat(baseDifference(array, result)) : array;
            }
          }
          return result ? baseUniq(result) : [];
        }
        function zip() {
          var length = arguments.length,
              array = Array(length);
          while (length--) {
            array[length] = arguments[length];
          }
          return unzip(array);
        }
        function zipObject(props, values) {
          var index = -1,
              length = props ? props.length : 0,
              result = {};
          if (length && !values && !isArray(props[0])) {
            values = [];
          }
          while (++index < length) {
            var key = props[index];
            if (values) {
              result[key] = values[index];
            } else if (key) {
              result[key[0]] = key[1];
            }
          }
          return result;
        }
        function chain(value) {
          var result = lodash(value);
          result.__chain__ = true;
          return result;
        }
        function tap(value, interceptor, thisArg) {
          interceptor.call(thisArg, value);
          return value;
        }
        function thru(value, interceptor, thisArg) {
          return interceptor.call(thisArg, value);
        }
        function wrapperChain() {
          return chain(this);
        }
        function wrapperCommit() {
          return new LodashWrapper(this.value(), this.__chain__);
        }
        function wrapperPlant(value) {
          var result,
              parent = this;
          while (parent instanceof baseLodash) {
            var clone = wrapperClone(parent);
            if (result) {
              previous.__wrapped__ = clone;
            } else {
              result = clone;
            }
            var previous = clone;
            parent = parent.__wrapped__;
          }
          previous.__wrapped__ = value;
          return result;
        }
        function wrapperReverse() {
          var value = this.__wrapped__;
          if (value instanceof LazyWrapper) {
            if (this.__actions__.length) {
              value = new LazyWrapper(this);
            }
            return new LodashWrapper(value.reverse(), this.__chain__);
          }
          return this.thru(function(value) {
            return value.reverse();
          });
        }
        function wrapperToString() {
          return (this.value() + '');
        }
        function wrapperValue() {
          return baseWrapperValue(this.__wrapped__, this.__actions__);
        }
        function at(collection) {
          var length = collection ? collection.length : 0;
          if (isLength(length)) {
            collection = toIterable(collection);
          }
          return baseAt(collection, baseFlatten(arguments, false, false, 1));
        }
        var countBy = createAggregator(function(result, value, key) {
          hasOwnProperty.call(result, key) ? ++result[key] : (result[key] = 1);
        });
        function every(collection, predicate, thisArg) {
          var func = isArray(collection) ? arrayEvery : baseEvery;
          if (typeof predicate != 'function' || typeof thisArg != 'undefined') {
            predicate = getCallback(predicate, thisArg, 3);
          }
          return func(collection, predicate);
        }
        function filter(collection, predicate, thisArg) {
          var func = isArray(collection) ? arrayFilter : baseFilter;
          predicate = getCallback(predicate, thisArg, 3);
          return func(collection, predicate);
        }
        function find(collection, predicate, thisArg) {
          if (isArray(collection)) {
            var index = findIndex(collection, predicate, thisArg);
            return index > -1 ? collection[index] : undefined;
          }
          predicate = getCallback(predicate, thisArg, 3);
          return baseFind(collection, predicate, baseEach);
        }
        function findLast(collection, predicate, thisArg) {
          predicate = getCallback(predicate, thisArg, 3);
          return baseFind(collection, predicate, baseEachRight);
        }
        function findWhere(collection, source) {
          return find(collection, baseMatches(source));
        }
        function forEach(collection, iteratee, thisArg) {
          return (typeof iteratee == 'function' && typeof thisArg == 'undefined' && isArray(collection)) ? arrayEach(collection, iteratee) : baseEach(collection, bindCallback(iteratee, thisArg, 3));
        }
        function forEachRight(collection, iteratee, thisArg) {
          return (typeof iteratee == 'function' && typeof thisArg == 'undefined' && isArray(collection)) ? arrayEachRight(collection, iteratee) : baseEachRight(collection, bindCallback(iteratee, thisArg, 3));
        }
        var groupBy = createAggregator(function(result, value, key) {
          if (hasOwnProperty.call(result, key)) {
            result[key].push(value);
          } else {
            result[key] = [value];
          }
        });
        function includes(collection, target, fromIndex) {
          var length = collection ? collection.length : 0;
          if (!isLength(length)) {
            collection = values(collection);
            length = collection.length;
          }
          if (!length) {
            return false;
          }
          if (typeof fromIndex == 'number') {
            fromIndex = fromIndex < 0 ? nativeMax(length + fromIndex, 0) : (fromIndex || 0);
          } else {
            fromIndex = 0;
          }
          return (typeof collection == 'string' || !isArray(collection) && isString(collection)) ? (fromIndex < length && collection.indexOf(target, fromIndex) > -1) : (getIndexOf(collection, target, fromIndex) > -1);
        }
        var indexBy = createAggregator(function(result, value, key) {
          result[key] = value;
        });
        function invoke(collection, methodName) {
          return baseInvoke(collection, methodName, baseSlice(arguments, 2));
        }
        function map(collection, iteratee, thisArg) {
          var func = isArray(collection) ? arrayMap : baseMap;
          iteratee = getCallback(iteratee, thisArg, 3);
          return func(collection, iteratee);
        }
        var partition = createAggregator(function(result, value, key) {
          result[key ? 0 : 1].push(value);
        }, function() {
          return [[], []];
        });
        function pluck(collection, key) {
          return map(collection, baseProperty(key));
        }
        function reduce(collection, iteratee, accumulator, thisArg) {
          var func = isArray(collection) ? arrayReduce : baseReduce;
          return func(collection, getCallback(iteratee, thisArg, 4), accumulator, arguments.length < 3, baseEach);
        }
        function reduceRight(collection, iteratee, accumulator, thisArg) {
          var func = isArray(collection) ? arrayReduceRight : baseReduce;
          return func(collection, getCallback(iteratee, thisArg, 4), accumulator, arguments.length < 3, baseEachRight);
        }
        function reject(collection, predicate, thisArg) {
          var func = isArray(collection) ? arrayFilter : baseFilter;
          predicate = getCallback(predicate, thisArg, 3);
          return func(collection, function(value, index, collection) {
            return !predicate(value, index, collection);
          });
        }
        function sample(collection, n, guard) {
          if (guard ? isIterateeCall(collection, n, guard) : n == null) {
            collection = toIterable(collection);
            var length = collection.length;
            return length > 0 ? collection[baseRandom(0, length - 1)] : undefined;
          }
          var result = shuffle(collection);
          result.length = nativeMin(n < 0 ? 0 : (+n || 0), result.length);
          return result;
        }
        function shuffle(collection) {
          collection = toIterable(collection);
          var index = -1,
              length = collection.length,
              result = Array(length);
          while (++index < length) {
            var rand = baseRandom(0, index);
            if (index != rand) {
              result[index] = result[rand];
            }
            result[rand] = collection[index];
          }
          return result;
        }
        function size(collection) {
          var length = collection ? collection.length : 0;
          return isLength(length) ? length : keys(collection).length;
        }
        function some(collection, predicate, thisArg) {
          var func = isArray(collection) ? arraySome : baseSome;
          if (typeof predicate != 'function' || typeof thisArg != 'undefined') {
            predicate = getCallback(predicate, thisArg, 3);
          }
          return func(collection, predicate);
        }
        function sortBy(collection, iteratee, thisArg) {
          if (collection == null) {
            return [];
          }
          var index = -1,
              length = collection.length,
              result = isLength(length) ? Array(length) : [];
          if (thisArg && isIterateeCall(collection, iteratee, thisArg)) {
            iteratee = null;
          }
          iteratee = getCallback(iteratee, thisArg, 3);
          baseEach(collection, function(value, key, collection) {
            result[++index] = {
              'criteria': iteratee(value, key, collection),
              'index': index,
              'value': value
            };
          });
          return baseSortBy(result, compareAscending);
        }
        function sortByAll(collection) {
          if (collection == null) {
            return [];
          }
          var args = arguments,
              guard = args[3];
          if (guard && isIterateeCall(args[1], args[2], guard)) {
            args = [collection, args[1]];
          }
          return baseSortByOrder(collection, baseFlatten(args, false, false, 1), []);
        }
        function sortByOrder(collection, props, orders, guard) {
          if (collection == null) {
            return [];
          }
          if (guard && isIterateeCall(props, orders, guard)) {
            orders = null;
          }
          if (!isArray(props)) {
            props = props == null ? [] : [props];
          }
          if (!isArray(orders)) {
            orders = orders == null ? [] : [orders];
          }
          return baseSortByOrder(collection, props, orders);
        }
        function where(collection, source) {
          return filter(collection, baseMatches(source));
        }
        var now = nativeNow || function() {
          return new Date().getTime();
        };
        function after(n, func) {
          if (typeof func != 'function') {
            if (typeof n == 'function') {
              var temp = n;
              n = func;
              func = temp;
            } else {
              throw new TypeError(FUNC_ERROR_TEXT);
            }
          }
          n = nativeIsFinite(n = +n) ? n : 0;
          return function() {
            if (--n < 1) {
              return func.apply(this, arguments);
            }
          };
        }
        function ary(func, n, guard) {
          if (guard && isIterateeCall(func, n, guard)) {
            n = null;
          }
          n = (func && n == null) ? func.length : nativeMax(+n || 0, 0);
          return createWrapper(func, ARY_FLAG, null, null, null, null, n);
        }
        function before(n, func) {
          var result;
          if (typeof func != 'function') {
            if (typeof n == 'function') {
              var temp = n;
              n = func;
              func = temp;
            } else {
              throw new TypeError(FUNC_ERROR_TEXT);
            }
          }
          return function() {
            if (--n > 0) {
              result = func.apply(this, arguments);
            } else {
              func = null;
            }
            return result;
          };
        }
        function bind(func, thisArg) {
          var bitmask = BIND_FLAG;
          if (arguments.length > 2) {
            var partials = baseSlice(arguments, 2),
                holders = replaceHolders(partials, bind.placeholder);
            bitmask |= PARTIAL_FLAG;
          }
          return createWrapper(func, bitmask, thisArg, partials, holders);
        }
        function bindAll(object) {
          return baseBindAll(object, arguments.length > 1 ? baseFlatten(arguments, false, false, 1) : functions(object));
        }
        function bindKey(object, key) {
          var bitmask = BIND_FLAG | BIND_KEY_FLAG;
          if (arguments.length > 2) {
            var partials = baseSlice(arguments, 2),
                holders = replaceHolders(partials, bindKey.placeholder);
            bitmask |= PARTIAL_FLAG;
          }
          return createWrapper(key, bitmask, object, partials, holders);
        }
        function curry(func, arity, guard) {
          if (guard && isIterateeCall(func, arity, guard)) {
            arity = null;
          }
          var result = createWrapper(func, CURRY_FLAG, null, null, null, null, null, arity);
          result.placeholder = curry.placeholder;
          return result;
        }
        function curryRight(func, arity, guard) {
          if (guard && isIterateeCall(func, arity, guard)) {
            arity = null;
          }
          var result = createWrapper(func, CURRY_RIGHT_FLAG, null, null, null, null, null, arity);
          result.placeholder = curryRight.placeholder;
          return result;
        }
        function debounce(func, wait, options) {
          var args,
              maxTimeoutId,
              result,
              stamp,
              thisArg,
              timeoutId,
              trailingCall,
              lastCalled = 0,
              maxWait = false,
              trailing = true;
          if (typeof func != 'function') {
            throw new TypeError(FUNC_ERROR_TEXT);
          }
          wait = wait < 0 ? 0 : (+wait || 0);
          if (options === true) {
            var leading = true;
            trailing = false;
          } else if (isObject(options)) {
            leading = options.leading;
            maxWait = 'maxWait' in options && nativeMax(+options.maxWait || 0, wait);
            trailing = 'trailing' in options ? options.trailing : trailing;
          }
          function cancel() {
            if (timeoutId) {
              clearTimeout(timeoutId);
            }
            if (maxTimeoutId) {
              clearTimeout(maxTimeoutId);
            }
            maxTimeoutId = timeoutId = trailingCall = undefined;
          }
          function delayed() {
            var remaining = wait - (now() - stamp);
            if (remaining <= 0 || remaining > wait) {
              if (maxTimeoutId) {
                clearTimeout(maxTimeoutId);
              }
              var isCalled = trailingCall;
              maxTimeoutId = timeoutId = trailingCall = undefined;
              if (isCalled) {
                lastCalled = now();
                result = func.apply(thisArg, args);
                if (!timeoutId && !maxTimeoutId) {
                  args = thisArg = null;
                }
              }
            } else {
              timeoutId = setTimeout(delayed, remaining);
            }
          }
          function maxDelayed() {
            if (timeoutId) {
              clearTimeout(timeoutId);
            }
            maxTimeoutId = timeoutId = trailingCall = undefined;
            if (trailing || (maxWait !== wait)) {
              lastCalled = now();
              result = func.apply(thisArg, args);
              if (!timeoutId && !maxTimeoutId) {
                args = thisArg = null;
              }
            }
          }
          function debounced() {
            args = arguments;
            stamp = now();
            thisArg = this;
            trailingCall = trailing && (timeoutId || !leading);
            if (maxWait === false) {
              var leadingCall = leading && !timeoutId;
            } else {
              if (!maxTimeoutId && !leading) {
                lastCalled = stamp;
              }
              var remaining = maxWait - (stamp - lastCalled),
                  isCalled = remaining <= 0 || remaining > maxWait;
              if (isCalled) {
                if (maxTimeoutId) {
                  maxTimeoutId = clearTimeout(maxTimeoutId);
                }
                lastCalled = stamp;
                result = func.apply(thisArg, args);
              } else if (!maxTimeoutId) {
                maxTimeoutId = setTimeout(maxDelayed, remaining);
              }
            }
            if (isCalled && timeoutId) {
              timeoutId = clearTimeout(timeoutId);
            } else if (!timeoutId && wait !== maxWait) {
              timeoutId = setTimeout(delayed, wait);
            }
            if (leadingCall) {
              isCalled = true;
              result = func.apply(thisArg, args);
            }
            if (isCalled && !timeoutId && !maxTimeoutId) {
              args = thisArg = null;
            }
            return result;
          }
          debounced.cancel = cancel;
          return debounced;
        }
        function defer(func) {
          return baseDelay(func, 1, arguments, 1);
        }
        function delay(func, wait) {
          return baseDelay(func, wait, arguments, 2);
        }
        var flow = createComposer();
        var flowRight = createComposer(true);
        function memoize(func, resolver) {
          if (typeof func != 'function' || (resolver && typeof resolver != 'function')) {
            throw new TypeError(FUNC_ERROR_TEXT);
          }
          var memoized = function() {
            var args = arguments,
                cache = memoized.cache,
                key = resolver ? resolver.apply(this, args) : args[0];
            if (cache.has(key)) {
              return cache.get(key);
            }
            var result = func.apply(this, args);
            cache.set(key, result);
            return result;
          };
          memoized.cache = new memoize.Cache;
          return memoized;
        }
        function negate(predicate) {
          if (typeof predicate != 'function') {
            throw new TypeError(FUNC_ERROR_TEXT);
          }
          return function() {
            return !predicate.apply(this, arguments);
          };
        }
        function once(func) {
          return before(func, 2);
        }
        function partial(func) {
          var partials = baseSlice(arguments, 1),
              holders = replaceHolders(partials, partial.placeholder);
          return createWrapper(func, PARTIAL_FLAG, null, partials, holders);
        }
        function partialRight(func) {
          var partials = baseSlice(arguments, 1),
              holders = replaceHolders(partials, partialRight.placeholder);
          return createWrapper(func, PARTIAL_RIGHT_FLAG, null, partials, holders);
        }
        function rearg(func) {
          var indexes = baseFlatten(arguments, false, false, 1);
          return createWrapper(func, REARG_FLAG, null, null, null, indexes);
        }
        function spread(func) {
          if (typeof func != 'function') {
            throw new TypeError(FUNC_ERROR_TEXT);
          }
          return function(array) {
            return func.apply(this, array);
          };
        }
        function throttle(func, wait, options) {
          var leading = true,
              trailing = true;
          if (typeof func != 'function') {
            throw new TypeError(FUNC_ERROR_TEXT);
          }
          if (options === false) {
            leading = false;
          } else if (isObject(options)) {
            leading = 'leading' in options ? !!options.leading : leading;
            trailing = 'trailing' in options ? !!options.trailing : trailing;
          }
          debounceOptions.leading = leading;
          debounceOptions.maxWait = +wait;
          debounceOptions.trailing = trailing;
          return debounce(func, wait, debounceOptions);
        }
        function wrap(value, wrapper) {
          wrapper = wrapper == null ? identity : wrapper;
          return createWrapper(wrapper, PARTIAL_FLAG, null, [value], []);
        }
        function clone(value, isDeep, customizer, thisArg) {
          if (isDeep && typeof isDeep != 'boolean' && isIterateeCall(value, isDeep, customizer)) {
            isDeep = false;
          } else if (typeof isDeep == 'function') {
            thisArg = customizer;
            customizer = isDeep;
            isDeep = false;
          }
          customizer = typeof customizer == 'function' && bindCallback(customizer, thisArg, 1);
          return baseClone(value, isDeep, customizer);
        }
        function cloneDeep(value, customizer, thisArg) {
          customizer = typeof customizer == 'function' && bindCallback(customizer, thisArg, 1);
          return baseClone(value, true, customizer);
        }
        function isArguments(value) {
          var length = isObjectLike(value) ? value.length : undefined;
          return (isLength(length) && objToString.call(value) == argsTag) || false;
        }
        var isArray = nativeIsArray || function(value) {
          return (isObjectLike(value) && isLength(value.length) && objToString.call(value) == arrayTag) || false;
        };
        function isBoolean(value) {
          return (value === true || value === false || isObjectLike(value) && objToString.call(value) == boolTag) || false;
        }
        function isDate(value) {
          return (isObjectLike(value) && objToString.call(value) == dateTag) || false;
        }
        function isElement(value) {
          return (value && value.nodeType === 1 && isObjectLike(value) && (objToString.call(value).indexOf('Element') > -1)) || false;
        }
        if (!support.dom) {
          isElement = function(value) {
            return (value && value.nodeType === 1 && isObjectLike(value) && !isPlainObject(value)) || false;
          };
        }
        function isEmpty(value) {
          if (value == null) {
            return true;
          }
          var length = value.length;
          if (isLength(length) && (isArray(value) || isString(value) || isArguments(value) || (isObjectLike(value) && isFunction(value.splice)))) {
            return !length;
          }
          return !keys(value).length;
        }
        function isEqual(value, other, customizer, thisArg) {
          customizer = typeof customizer == 'function' && bindCallback(customizer, thisArg, 3);
          if (!customizer && isStrictComparable(value) && isStrictComparable(other)) {
            return value === other;
          }
          var result = customizer ? customizer(value, other) : undefined;
          return typeof result == 'undefined' ? baseIsEqual(value, other, customizer) : !!result;
        }
        function isError(value) {
          return (isObjectLike(value) && typeof value.message == 'string' && objToString.call(value) == errorTag) || false;
        }
        var isFinite = nativeNumIsFinite || function(value) {
          return typeof value == 'number' && nativeIsFinite(value);
        };
        var isFunction = !(baseIsFunction(/x/) || (Uint8Array && !baseIsFunction(Uint8Array))) ? baseIsFunction : function(value) {
          return objToString.call(value) == funcTag;
        };
        function isObject(value) {
          var type = typeof value;
          return type == 'function' || (value && type == 'object') || false;
        }
        function isMatch(object, source, customizer, thisArg) {
          var props = keys(source),
              length = props.length;
          customizer = typeof customizer == 'function' && bindCallback(customizer, thisArg, 3);
          if (!customizer && length == 1) {
            var key = props[0],
                value = source[key];
            if (isStrictComparable(value)) {
              return object != null && value === object[key] && hasOwnProperty.call(object, key);
            }
          }
          var values = Array(length),
              strictCompareFlags = Array(length);
          while (length--) {
            value = values[length] = source[props[length]];
            strictCompareFlags[length] = isStrictComparable(value);
          }
          return baseIsMatch(object, props, values, strictCompareFlags, customizer);
        }
        function isNaN(value) {
          return isNumber(value) && value != +value;
        }
        function isNative(value) {
          if (value == null) {
            return false;
          }
          if (objToString.call(value) == funcTag) {
            return reNative.test(fnToString.call(value));
          }
          return (isObjectLike(value) && reHostCtor.test(value)) || false;
        }
        function isNull(value) {
          return value === null;
        }
        function isNumber(value) {
          return typeof value == 'number' || (isObjectLike(value) && objToString.call(value) == numberTag) || false;
        }
        var isPlainObject = !getPrototypeOf ? shimIsPlainObject : function(value) {
          if (!(value && objToString.call(value) == objectTag)) {
            return false;
          }
          var valueOf = value.valueOf,
              objProto = isNative(valueOf) && (objProto = getPrototypeOf(valueOf)) && getPrototypeOf(objProto);
          return objProto ? (value == objProto || getPrototypeOf(value) == objProto) : shimIsPlainObject(value);
        };
        function isRegExp(value) {
          return (isObjectLike(value) && objToString.call(value) == regexpTag) || false;
        }
        function isString(value) {
          return typeof value == 'string' || (isObjectLike(value) && objToString.call(value) == stringTag) || false;
        }
        function isTypedArray(value) {
          return (isObjectLike(value) && isLength(value.length) && typedArrayTags[objToString.call(value)]) || false;
        }
        function isUndefined(value) {
          return typeof value == 'undefined';
        }
        function toArray(value) {
          var length = value ? value.length : 0;
          if (!isLength(length)) {
            return values(value);
          }
          if (!length) {
            return [];
          }
          return arrayCopy(value);
        }
        function toPlainObject(value) {
          return baseCopy(value, keysIn(value));
        }
        var assign = createAssigner(baseAssign);
        function create(prototype, properties, guard) {
          var result = baseCreate(prototype);
          if (guard && isIterateeCall(prototype, properties, guard)) {
            properties = null;
          }
          return properties ? baseCopy(properties, result, keys(properties)) : result;
        }
        function defaults(object) {
          if (object == null) {
            return object;
          }
          var args = arrayCopy(arguments);
          args.push(assignDefaults);
          return assign.apply(undefined, args);
        }
        function findKey(object, predicate, thisArg) {
          predicate = getCallback(predicate, thisArg, 3);
          return baseFind(object, predicate, baseForOwn, true);
        }
        function findLastKey(object, predicate, thisArg) {
          predicate = getCallback(predicate, thisArg, 3);
          return baseFind(object, predicate, baseForOwnRight, true);
        }
        function forIn(object, iteratee, thisArg) {
          if (typeof iteratee != 'function' || typeof thisArg != 'undefined') {
            iteratee = bindCallback(iteratee, thisArg, 3);
          }
          return baseFor(object, iteratee, keysIn);
        }
        function forInRight(object, iteratee, thisArg) {
          iteratee = bindCallback(iteratee, thisArg, 3);
          return baseForRight(object, iteratee, keysIn);
        }
        function forOwn(object, iteratee, thisArg) {
          if (typeof iteratee != 'function' || typeof thisArg != 'undefined') {
            iteratee = bindCallback(iteratee, thisArg, 3);
          }
          return baseForOwn(object, iteratee);
        }
        function forOwnRight(object, iteratee, thisArg) {
          iteratee = bindCallback(iteratee, thisArg, 3);
          return baseForRight(object, iteratee, keys);
        }
        function functions(object) {
          return baseFunctions(object, keysIn(object));
        }
        function has(object, key) {
          return object ? hasOwnProperty.call(object, key) : false;
        }
        function invert(object, multiValue, guard) {
          if (guard && isIterateeCall(object, multiValue, guard)) {
            multiValue = null;
          }
          var index = -1,
              props = keys(object),
              length = props.length,
              result = {};
          while (++index < length) {
            var key = props[index],
                value = object[key];
            if (multiValue) {
              if (hasOwnProperty.call(result, value)) {
                result[value].push(key);
              } else {
                result[value] = [key];
              }
            } else {
              result[value] = key;
            }
          }
          return result;
        }
        var keys = !nativeKeys ? shimKeys : function(object) {
          if (object) {
            var Ctor = object.constructor,
                length = object.length;
          }
          if ((typeof Ctor == 'function' && Ctor.prototype === object) || (typeof object != 'function' && (length && isLength(length)))) {
            return shimKeys(object);
          }
          return isObject(object) ? nativeKeys(object) : [];
        };
        function keysIn(object) {
          if (object == null) {
            return [];
          }
          if (!isObject(object)) {
            object = Object(object);
          }
          var length = object.length;
          length = (length && isLength(length) && (isArray(object) || (support.nonEnumArgs && isArguments(object))) && length) || 0;
          var Ctor = object.constructor,
              index = -1,
              isProto = typeof Ctor == 'function' && Ctor.prototype === object,
              result = Array(length),
              skipIndexes = length > 0;
          while (++index < length) {
            result[index] = (index + '');
          }
          for (var key in object) {
            if (!(skipIndexes && isIndex(key, length)) && !(key == 'constructor' && (isProto || !hasOwnProperty.call(object, key)))) {
              result.push(key);
            }
          }
          return result;
        }
        function mapValues(object, iteratee, thisArg) {
          var result = {};
          iteratee = getCallback(iteratee, thisArg, 3);
          baseForOwn(object, function(value, key, object) {
            result[key] = iteratee(value, key, object);
          });
          return result;
        }
        var merge = createAssigner(baseMerge);
        function omit(object, predicate, thisArg) {
          if (object == null) {
            return {};
          }
          if (typeof predicate != 'function') {
            var props = arrayMap(baseFlatten(arguments, false, false, 1), String);
            return pickByArray(object, baseDifference(keysIn(object), props));
          }
          predicate = bindCallback(predicate, thisArg, 3);
          return pickByCallback(object, function(value, key, object) {
            return !predicate(value, key, object);
          });
        }
        function pairs(object) {
          var index = -1,
              props = keys(object),
              length = props.length,
              result = Array(length);
          while (++index < length) {
            var key = props[index];
            result[index] = [key, object[key]];
          }
          return result;
        }
        function pick(object, predicate, thisArg) {
          if (object == null) {
            return {};
          }
          return typeof predicate == 'function' ? pickByCallback(object, bindCallback(predicate, thisArg, 3)) : pickByArray(object, baseFlatten(arguments, false, false, 1));
        }
        function result(object, key, defaultValue) {
          var value = object == null ? undefined : object[key];
          if (typeof value == 'undefined') {
            value = defaultValue;
          }
          return isFunction(value) ? value.call(object) : value;
        }
        function transform(object, iteratee, accumulator, thisArg) {
          var isArr = isArray(object) || isTypedArray(object);
          iteratee = getCallback(iteratee, thisArg, 4);
          if (accumulator == null) {
            if (isArr || isObject(object)) {
              var Ctor = object.constructor;
              if (isArr) {
                accumulator = isArray(object) ? new Ctor : [];
              } else {
                accumulator = baseCreate(isFunction(Ctor) && Ctor.prototype);
              }
            } else {
              accumulator = {};
            }
          }
          (isArr ? arrayEach : baseForOwn)(object, function(value, index, object) {
            return iteratee(accumulator, value, index, object);
          });
          return accumulator;
        }
        function values(object) {
          return baseValues(object, keys(object));
        }
        function valuesIn(object) {
          return baseValues(object, keysIn(object));
        }
        function inRange(value, start, end) {
          start = +start || 0;
          if (typeof end === 'undefined') {
            end = start;
            start = 0;
          } else {
            end = +end || 0;
          }
          return value >= start && value < end;
        }
        function random(min, max, floating) {
          if (floating && isIterateeCall(min, max, floating)) {
            max = floating = null;
          }
          var noMin = min == null,
              noMax = max == null;
          if (floating == null) {
            if (noMax && typeof min == 'boolean') {
              floating = min;
              min = 1;
            } else if (typeof max == 'boolean') {
              floating = max;
              noMax = true;
            }
          }
          if (noMin && noMax) {
            max = 1;
            noMax = false;
          }
          min = +min || 0;
          if (noMax) {
            max = min;
            min = 0;
          } else {
            max = +max || 0;
          }
          if (floating || min % 1 || max % 1) {
            var rand = nativeRandom();
            return nativeMin(min + (rand * (max - min + parseFloat('1e-' + ((rand + '').length - 1)))), max);
          }
          return baseRandom(min, max);
        }
        var camelCase = createCompounder(function(result, word, index) {
          word = word.toLowerCase();
          return result + (index ? (word.charAt(0).toUpperCase() + word.slice(1)) : word);
        });
        function capitalize(string) {
          string = baseToString(string);
          return string && (string.charAt(0).toUpperCase() + string.slice(1));
        }
        function deburr(string) {
          string = baseToString(string);
          return string && string.replace(reLatin1, deburrLetter);
        }
        function endsWith(string, target, position) {
          string = baseToString(string);
          target = (target + '');
          var length = string.length;
          position = typeof position == 'undefined' ? length : nativeMin(position < 0 ? 0 : (+position || 0), length);
          position -= target.length;
          return position >= 0 && string.indexOf(target, position) == position;
        }
        function escape(string) {
          string = baseToString(string);
          return (string && reHasUnescapedHtml.test(string)) ? string.replace(reUnescapedHtml, escapeHtmlChar) : string;
        }
        function escapeRegExp(string) {
          string = baseToString(string);
          return (string && reHasRegExpChars.test(string)) ? string.replace(reRegExpChars, '\\$&') : string;
        }
        var kebabCase = createCompounder(function(result, word, index) {
          return result + (index ? '-' : '') + word.toLowerCase();
        });
        function pad(string, length, chars) {
          string = baseToString(string);
          length = +length;
          var strLength = string.length;
          if (strLength >= length || !nativeIsFinite(length)) {
            return string;
          }
          var mid = (length - strLength) / 2,
              leftLength = floor(mid),
              rightLength = ceil(mid);
          chars = createPad('', rightLength, chars);
          return chars.slice(0, leftLength) + string + chars;
        }
        function padLeft(string, length, chars) {
          string = baseToString(string);
          return string && (createPad(string, length, chars) + string);
        }
        function padRight(string, length, chars) {
          string = baseToString(string);
          return string && (string + createPad(string, length, chars));
        }
        function parseInt(string, radix, guard) {
          if (guard && isIterateeCall(string, radix, guard)) {
            radix = 0;
          }
          return nativeParseInt(string, radix);
        }
        if (nativeParseInt(whitespace + '08') != 8) {
          parseInt = function(string, radix, guard) {
            if (guard ? isIterateeCall(string, radix, guard) : radix == null) {
              radix = 0;
            } else if (radix) {
              radix = +radix;
            }
            string = trim(string);
            return nativeParseInt(string, radix || (reHexPrefix.test(string) ? 16 : 10));
          };
        }
        function repeat(string, n) {
          var result = '';
          string = baseToString(string);
          n = +n;
          if (n < 1 || !string || !nativeIsFinite(n)) {
            return result;
          }
          do {
            if (n % 2) {
              result += string;
            }
            n = floor(n / 2);
            string += string;
          } while (n);
          return result;
        }
        var snakeCase = createCompounder(function(result, word, index) {
          return result + (index ? '_' : '') + word.toLowerCase();
        });
        var startCase = createCompounder(function(result, word, index) {
          return result + (index ? ' ' : '') + (word.charAt(0).toUpperCase() + word.slice(1));
        });
        function startsWith(string, target, position) {
          string = baseToString(string);
          position = position == null ? 0 : nativeMin(position < 0 ? 0 : (+position || 0), string.length);
          return string.lastIndexOf(target, position) == position;
        }
        function template(string, options, otherOptions) {
          var settings = lodash.templateSettings;
          if (otherOptions && isIterateeCall(string, options, otherOptions)) {
            options = otherOptions = null;
          }
          string = baseToString(string);
          options = baseAssign(baseAssign({}, otherOptions || options), settings, assignOwnDefaults);
          var imports = baseAssign(baseAssign({}, options.imports), settings.imports, assignOwnDefaults),
              importsKeys = keys(imports),
              importsValues = baseValues(imports, importsKeys);
          var isEscaping,
              isEvaluating,
              index = 0,
              interpolate = options.interpolate || reNoMatch,
              source = "__p += '";
          var reDelimiters = RegExp((options.escape || reNoMatch).source + '|' + interpolate.source + '|' + (interpolate === reInterpolate ? reEsTemplate : reNoMatch).source + '|' + (options.evaluate || reNoMatch).source + '|$', 'g');
          var sourceURL = '//# sourceURL=' + ('sourceURL' in options ? options.sourceURL : ('lodash.templateSources[' + (++templateCounter) + ']')) + '\n';
          string.replace(reDelimiters, function(match, escapeValue, interpolateValue, esTemplateValue, evaluateValue, offset) {
            interpolateValue || (interpolateValue = esTemplateValue);
            source += string.slice(index, offset).replace(reUnescapedString, escapeStringChar);
            if (escapeValue) {
              isEscaping = true;
              source += "' +\n__e(" + escapeValue + ") +\n'";
            }
            if (evaluateValue) {
              isEvaluating = true;
              source += "';\n" + evaluateValue + ";\n__p += '";
            }
            if (interpolateValue) {
              source += "' +\n((__t = (" + interpolateValue + ")) == null ? '' : __t) +\n'";
            }
            index = offset + match.length;
            return match;
          });
          source += "';\n";
          var variable = options.variable;
          if (!variable) {
            source = 'with (obj) {\n' + source + '\n}\n';
          }
          source = (isEvaluating ? source.replace(reEmptyStringLeading, '') : source).replace(reEmptyStringMiddle, '$1').replace(reEmptyStringTrailing, '$1;');
          source = 'function(' + (variable || 'obj') + ') {\n' + (variable ? '' : 'obj || (obj = {});\n') + "var __t, __p = ''" + (isEscaping ? ', __e = _.escape' : '') + (isEvaluating ? ', __j = Array.prototype.join;\n' + "function print() { __p += __j.call(arguments, '') }\n" : ';\n') + source + 'return __p\n}';
          var result = attempt(function() {
            return Function(importsKeys, sourceURL + 'return ' + source).apply(undefined, importsValues);
          });
          result.source = source;
          if (isError(result)) {
            throw result;
          }
          return result;
        }
        function trim(string, chars, guard) {
          var value = string;
          string = baseToString(string);
          if (!string) {
            return string;
          }
          if (guard ? isIterateeCall(value, chars, guard) : chars == null) {
            return string.slice(trimmedLeftIndex(string), trimmedRightIndex(string) + 1);
          }
          chars = (chars + '');
          return string.slice(charsLeftIndex(string, chars), charsRightIndex(string, chars) + 1);
        }
        function trimLeft(string, chars, guard) {
          var value = string;
          string = baseToString(string);
          if (!string) {
            return string;
          }
          if (guard ? isIterateeCall(value, chars, guard) : chars == null) {
            return string.slice(trimmedLeftIndex(string));
          }
          return string.slice(charsLeftIndex(string, (chars + '')));
        }
        function trimRight(string, chars, guard) {
          var value = string;
          string = baseToString(string);
          if (!string) {
            return string;
          }
          if (guard ? isIterateeCall(value, chars, guard) : chars == null) {
            return string.slice(0, trimmedRightIndex(string) + 1);
          }
          return string.slice(0, charsRightIndex(string, (chars + '')) + 1);
        }
        function trunc(string, options, guard) {
          if (guard && isIterateeCall(string, options, guard)) {
            options = null;
          }
          var length = DEFAULT_TRUNC_LENGTH,
              omission = DEFAULT_TRUNC_OMISSION;
          if (options != null) {
            if (isObject(options)) {
              var separator = 'separator' in options ? options.separator : separator;
              length = 'length' in options ? (+options.length || 0) : length;
              omission = 'omission' in options ? baseToString(options.omission) : omission;
            } else {
              length = +options || 0;
            }
          }
          string = baseToString(string);
          if (length >= string.length) {
            return string;
          }
          var end = length - omission.length;
          if (end < 1) {
            return omission;
          }
          var result = string.slice(0, end);
          if (separator == null) {
            return result + omission;
          }
          if (isRegExp(separator)) {
            if (string.slice(end).search(separator)) {
              var match,
                  newEnd,
                  substring = string.slice(0, end);
              if (!separator.global) {
                separator = RegExp(separator.source, (reFlags.exec(separator) || '') + 'g');
              }
              separator.lastIndex = 0;
              while ((match = separator.exec(substring))) {
                newEnd = match.index;
              }
              result = result.slice(0, newEnd == null ? end : newEnd);
            }
          } else if (string.indexOf(separator, end) != end) {
            var index = result.lastIndexOf(separator);
            if (index > -1) {
              result = result.slice(0, index);
            }
          }
          return result + omission;
        }
        function unescape(string) {
          string = baseToString(string);
          return (string && reHasEscapedHtml.test(string)) ? string.replace(reEscapedHtml, unescapeHtmlChar) : string;
        }
        function words(string, pattern, guard) {
          if (guard && isIterateeCall(string, pattern, guard)) {
            pattern = null;
          }
          string = baseToString(string);
          return string.match(pattern || reWords) || [];
        }
        function attempt() {
          var func = arguments[0],
              length = arguments.length,
              args = Array(length ? (length - 1) : 0);
          while (--length > 0) {
            args[length - 1] = arguments[length];
          }
          try {
            return func.apply(undefined, args);
          } catch (e) {
            return isError(e) ? e : new Error(e);
          }
        }
        function callback(func, thisArg, guard) {
          if (guard && isIterateeCall(func, thisArg, guard)) {
            thisArg = null;
          }
          return isObjectLike(func) ? matches(func) : baseCallback(func, thisArg);
        }
        function constant(value) {
          return function() {
            return value;
          };
        }
        function identity(value) {
          return value;
        }
        function matches(source) {
          return baseMatches(baseClone(source, true));
        }
        function matchesProperty(key, value) {
          return baseMatchesProperty(key + '', baseClone(value, true));
        }
        function mixin(object, source, options) {
          if (options == null) {
            var isObj = isObject(source),
                props = isObj && keys(source),
                methodNames = props && props.length && baseFunctions(source, props);
            if (!(methodNames ? methodNames.length : isObj)) {
              methodNames = false;
              options = source;
              source = object;
              object = this;
            }
          }
          if (!methodNames) {
            methodNames = baseFunctions(source, keys(source));
          }
          var chain = true,
              index = -1,
              isFunc = isFunction(object),
              length = methodNames.length;
          if (options === false) {
            chain = false;
          } else if (isObject(options) && 'chain' in options) {
            chain = options.chain;
          }
          while (++index < length) {
            var methodName = methodNames[index],
                func = source[methodName];
            object[methodName] = func;
            if (isFunc) {
              object.prototype[methodName] = (function(func) {
                return function() {
                  var chainAll = this.__chain__;
                  if (chain || chainAll) {
                    var result = object(this.__wrapped__);
                    (result.__actions__ = arrayCopy(this.__actions__)).push({
                      'func': func,
                      'args': arguments,
                      'thisArg': object
                    });
                    result.__chain__ = chainAll;
                    return result;
                  }
                  var args = [this.value()];
                  push.apply(args, arguments);
                  return func.apply(object, args);
                };
              }(func));
            }
          }
          return object;
        }
        function noConflict() {
          context._ = oldDash;
          return this;
        }
        function noop() {}
        function property(key) {
          return baseProperty(key + '');
        }
        function propertyOf(object) {
          return function(key) {
            return object == null ? undefined : object[key];
          };
        }
        function range(start, end, step) {
          if (step && isIterateeCall(start, end, step)) {
            end = step = null;
          }
          start = +start || 0;
          step = step == null ? 1 : (+step || 0);
          if (end == null) {
            end = start;
            start = 0;
          } else {
            end = +end || 0;
          }
          var index = -1,
              length = nativeMax(ceil((end - start) / (step || 1)), 0),
              result = Array(length);
          while (++index < length) {
            result[index] = start;
            start += step;
          }
          return result;
        }
        function times(n, iteratee, thisArg) {
          n = +n;
          if (n < 1 || !nativeIsFinite(n)) {
            return [];
          }
          var index = -1,
              result = Array(nativeMin(n, MAX_ARRAY_LENGTH));
          iteratee = bindCallback(iteratee, thisArg, 1);
          while (++index < n) {
            if (index < MAX_ARRAY_LENGTH) {
              result[index] = iteratee(index);
            } else {
              iteratee(index);
            }
          }
          return result;
        }
        function uniqueId(prefix) {
          var id = ++idCounter;
          return baseToString(prefix) + id;
        }
        function add(augend, addend) {
          return augend + addend;
        }
        var max = createExtremum(arrayMax);
        var min = createExtremum(arrayMin, true);
        function sum(collection) {
          if (!isArray(collection)) {
            collection = toIterable(collection);
          }
          var length = collection.length,
              result = 0;
          while (length--) {
            result += +collection[length] || 0;
          }
          return result;
        }
        lodash.prototype = baseLodash.prototype;
        LodashWrapper.prototype = baseCreate(baseLodash.prototype);
        LodashWrapper.prototype.constructor = LodashWrapper;
        LazyWrapper.prototype = baseCreate(baseLodash.prototype);
        LazyWrapper.prototype.constructor = LazyWrapper;
        MapCache.prototype['delete'] = mapDelete;
        MapCache.prototype.get = mapGet;
        MapCache.prototype.has = mapHas;
        MapCache.prototype.set = mapSet;
        SetCache.prototype.push = cachePush;
        memoize.Cache = MapCache;
        lodash.after = after;
        lodash.ary = ary;
        lodash.assign = assign;
        lodash.at = at;
        lodash.before = before;
        lodash.bind = bind;
        lodash.bindAll = bindAll;
        lodash.bindKey = bindKey;
        lodash.callback = callback;
        lodash.chain = chain;
        lodash.chunk = chunk;
        lodash.compact = compact;
        lodash.constant = constant;
        lodash.countBy = countBy;
        lodash.create = create;
        lodash.curry = curry;
        lodash.curryRight = curryRight;
        lodash.debounce = debounce;
        lodash.defaults = defaults;
        lodash.defer = defer;
        lodash.delay = delay;
        lodash.difference = difference;
        lodash.drop = drop;
        lodash.dropRight = dropRight;
        lodash.dropRightWhile = dropRightWhile;
        lodash.dropWhile = dropWhile;
        lodash.fill = fill;
        lodash.filter = filter;
        lodash.flatten = flatten;
        lodash.flattenDeep = flattenDeep;
        lodash.flow = flow;
        lodash.flowRight = flowRight;
        lodash.forEach = forEach;
        lodash.forEachRight = forEachRight;
        lodash.forIn = forIn;
        lodash.forInRight = forInRight;
        lodash.forOwn = forOwn;
        lodash.forOwnRight = forOwnRight;
        lodash.functions = functions;
        lodash.groupBy = groupBy;
        lodash.indexBy = indexBy;
        lodash.initial = initial;
        lodash.intersection = intersection;
        lodash.invert = invert;
        lodash.invoke = invoke;
        lodash.keys = keys;
        lodash.keysIn = keysIn;
        lodash.map = map;
        lodash.mapValues = mapValues;
        lodash.matches = matches;
        lodash.matchesProperty = matchesProperty;
        lodash.memoize = memoize;
        lodash.merge = merge;
        lodash.mixin = mixin;
        lodash.negate = negate;
        lodash.omit = omit;
        lodash.once = once;
        lodash.pairs = pairs;
        lodash.partial = partial;
        lodash.partialRight = partialRight;
        lodash.partition = partition;
        lodash.pick = pick;
        lodash.pluck = pluck;
        lodash.property = property;
        lodash.propertyOf = propertyOf;
        lodash.pull = pull;
        lodash.pullAt = pullAt;
        lodash.range = range;
        lodash.rearg = rearg;
        lodash.reject = reject;
        lodash.remove = remove;
        lodash.rest = rest;
        lodash.shuffle = shuffle;
        lodash.slice = slice;
        lodash.sortBy = sortBy;
        lodash.sortByAll = sortByAll;
        lodash.sortByOrder = sortByOrder;
        lodash.spread = spread;
        lodash.take = take;
        lodash.takeRight = takeRight;
        lodash.takeRightWhile = takeRightWhile;
        lodash.takeWhile = takeWhile;
        lodash.tap = tap;
        lodash.throttle = throttle;
        lodash.thru = thru;
        lodash.times = times;
        lodash.toArray = toArray;
        lodash.toPlainObject = toPlainObject;
        lodash.transform = transform;
        lodash.union = union;
        lodash.uniq = uniq;
        lodash.unzip = unzip;
        lodash.values = values;
        lodash.valuesIn = valuesIn;
        lodash.where = where;
        lodash.without = without;
        lodash.wrap = wrap;
        lodash.xor = xor;
        lodash.zip = zip;
        lodash.zipObject = zipObject;
        lodash.backflow = flowRight;
        lodash.collect = map;
        lodash.compose = flowRight;
        lodash.each = forEach;
        lodash.eachRight = forEachRight;
        lodash.extend = assign;
        lodash.iteratee = callback;
        lodash.methods = functions;
        lodash.object = zipObject;
        lodash.select = filter;
        lodash.tail = rest;
        lodash.unique = uniq;
        mixin(lodash, lodash);
        lodash.add = add;
        lodash.attempt = attempt;
        lodash.camelCase = camelCase;
        lodash.capitalize = capitalize;
        lodash.clone = clone;
        lodash.cloneDeep = cloneDeep;
        lodash.deburr = deburr;
        lodash.endsWith = endsWith;
        lodash.escape = escape;
        lodash.escapeRegExp = escapeRegExp;
        lodash.every = every;
        lodash.find = find;
        lodash.findIndex = findIndex;
        lodash.findKey = findKey;
        lodash.findLast = findLast;
        lodash.findLastIndex = findLastIndex;
        lodash.findLastKey = findLastKey;
        lodash.findWhere = findWhere;
        lodash.first = first;
        lodash.has = has;
        lodash.identity = identity;
        lodash.includes = includes;
        lodash.indexOf = indexOf;
        lodash.inRange = inRange;
        lodash.isArguments = isArguments;
        lodash.isArray = isArray;
        lodash.isBoolean = isBoolean;
        lodash.isDate = isDate;
        lodash.isElement = isElement;
        lodash.isEmpty = isEmpty;
        lodash.isEqual = isEqual;
        lodash.isError = isError;
        lodash.isFinite = isFinite;
        lodash.isFunction = isFunction;
        lodash.isMatch = isMatch;
        lodash.isNaN = isNaN;
        lodash.isNative = isNative;
        lodash.isNull = isNull;
        lodash.isNumber = isNumber;
        lodash.isObject = isObject;
        lodash.isPlainObject = isPlainObject;
        lodash.isRegExp = isRegExp;
        lodash.isString = isString;
        lodash.isTypedArray = isTypedArray;
        lodash.isUndefined = isUndefined;
        lodash.kebabCase = kebabCase;
        lodash.last = last;
        lodash.lastIndexOf = lastIndexOf;
        lodash.max = max;
        lodash.min = min;
        lodash.noConflict = noConflict;
        lodash.noop = noop;
        lodash.now = now;
        lodash.pad = pad;
        lodash.padLeft = padLeft;
        lodash.padRight = padRight;
        lodash.parseInt = parseInt;
        lodash.random = random;
        lodash.reduce = reduce;
        lodash.reduceRight = reduceRight;
        lodash.repeat = repeat;
        lodash.result = result;
        lodash.runInContext = runInContext;
        lodash.size = size;
        lodash.snakeCase = snakeCase;
        lodash.some = some;
        lodash.sortedIndex = sortedIndex;
        lodash.sortedLastIndex = sortedLastIndex;
        lodash.startCase = startCase;
        lodash.startsWith = startsWith;
        lodash.sum = sum;
        lodash.template = template;
        lodash.trim = trim;
        lodash.trimLeft = trimLeft;
        lodash.trimRight = trimRight;
        lodash.trunc = trunc;
        lodash.unescape = unescape;
        lodash.uniqueId = uniqueId;
        lodash.words = words;
        lodash.all = every;
        lodash.any = some;
        lodash.contains = includes;
        lodash.detect = find;
        lodash.foldl = reduce;
        lodash.foldr = reduceRight;
        lodash.head = first;
        lodash.include = includes;
        lodash.inject = reduce;
        mixin(lodash, (function() {
          var source = {};
          baseForOwn(lodash, function(func, methodName) {
            if (!lodash.prototype[methodName]) {
              source[methodName] = func;
            }
          });
          return source;
        }()), false);
        lodash.sample = sample;
        lodash.prototype.sample = function(n) {
          if (!this.__chain__ && n == null) {
            return sample(this.value());
          }
          return this.thru(function(value) {
            return sample(value, n);
          });
        };
        lodash.VERSION = VERSION;
        arrayEach(['bind', 'bindKey', 'curry', 'curryRight', 'partial', 'partialRight'], function(methodName) {
          lodash[methodName].placeholder = lodash;
        });
        arrayEach(['dropWhile', 'filter', 'map', 'takeWhile'], function(methodName, type) {
          var isFilter = type != LAZY_MAP_FLAG,
              isDropWhile = type == LAZY_DROP_WHILE_FLAG;
          LazyWrapper.prototype[methodName] = function(iteratee, thisArg) {
            var filtered = this.__filtered__,
                result = (filtered && isDropWhile) ? new LazyWrapper(this) : this.clone(),
                iteratees = result.__iteratees__ || (result.__iteratees__ = []);
            iteratees.push({
              'done': false,
              'count': 0,
              'index': 0,
              'iteratee': getCallback(iteratee, thisArg, 1),
              'limit': -1,
              'type': type
            });
            result.__filtered__ = filtered || isFilter;
            return result;
          };
        });
        arrayEach(['drop', 'take'], function(methodName, index) {
          var whileName = methodName + 'While';
          LazyWrapper.prototype[methodName] = function(n) {
            var filtered = this.__filtered__,
                result = (filtered && !index) ? this.dropWhile() : this.clone();
            n = n == null ? 1 : nativeMax(floor(n) || 0, 0);
            if (filtered) {
              if (index) {
                result.__takeCount__ = nativeMin(result.__takeCount__, n);
              } else {
                last(result.__iteratees__).limit = n;
              }
            } else {
              var views = result.__views__ || (result.__views__ = []);
              views.push({
                'size': n,
                'type': methodName + (result.__dir__ < 0 ? 'Right' : '')
              });
            }
            return result;
          };
          LazyWrapper.prototype[methodName + 'Right'] = function(n) {
            return this.reverse()[methodName](n).reverse();
          };
          LazyWrapper.prototype[methodName + 'RightWhile'] = function(predicate, thisArg) {
            return this.reverse()[whileName](predicate, thisArg).reverse();
          };
        });
        arrayEach(['first', 'last'], function(methodName, index) {
          var takeName = 'take' + (index ? 'Right' : '');
          LazyWrapper.prototype[methodName] = function() {
            return this[takeName](1).value()[0];
          };
        });
        arrayEach(['initial', 'rest'], function(methodName, index) {
          var dropName = 'drop' + (index ? '' : 'Right');
          LazyWrapper.prototype[methodName] = function() {
            return this[dropName](1);
          };
        });
        arrayEach(['pluck', 'where'], function(methodName, index) {
          var operationName = index ? 'filter' : 'map',
              createCallback = index ? baseMatches : baseProperty;
          LazyWrapper.prototype[methodName] = function(value) {
            return this[operationName](createCallback(value));
          };
        });
        LazyWrapper.prototype.compact = function() {
          return this.filter(identity);
        };
        LazyWrapper.prototype.reject = function(predicate, thisArg) {
          predicate = getCallback(predicate, thisArg, 1);
          return this.filter(function(value) {
            return !predicate(value);
          });
        };
        LazyWrapper.prototype.slice = function(start, end) {
          start = start == null ? 0 : (+start || 0);
          var result = start < 0 ? this.takeRight(-start) : this.drop(start);
          if (typeof end != 'undefined') {
            end = (+end || 0);
            result = end < 0 ? result.dropRight(-end) : result.take(end - start);
          }
          return result;
        };
        LazyWrapper.prototype.toArray = function() {
          return this.drop(0);
        };
        baseForOwn(LazyWrapper.prototype, function(func, methodName) {
          var lodashFunc = lodash[methodName],
              checkIteratee = /^(?:filter|map|reject)|While$/.test(methodName),
              retUnwrapped = /^(?:first|last)$/.test(methodName);
          lodash.prototype[methodName] = function() {
            var args = arguments,
                length = args.length,
                chainAll = this.__chain__,
                value = this.__wrapped__,
                isHybrid = !!this.__actions__.length,
                isLazy = value instanceof LazyWrapper,
                iteratee = args[0],
                useLazy = isLazy || isArray(value);
            if (useLazy && checkIteratee && typeof iteratee == 'function' && iteratee.length != 1) {
              isLazy = useLazy = false;
            }
            var onlyLazy = isLazy && !isHybrid;
            if (retUnwrapped && !chainAll) {
              return onlyLazy ? func.call(value) : lodashFunc.call(lodash, this.value());
            }
            var interceptor = function(value) {
              var otherArgs = [value];
              push.apply(otherArgs, args);
              return lodashFunc.apply(lodash, otherArgs);
            };
            if (useLazy) {
              var wrapper = onlyLazy ? value : new LazyWrapper(this),
                  result = func.apply(wrapper, args);
              if (!retUnwrapped && (isHybrid || result.__actions__)) {
                var actions = result.__actions__ || (result.__actions__ = []);
                actions.push({
                  'func': thru,
                  'args': [interceptor],
                  'thisArg': lodash
                });
              }
              return new LodashWrapper(result, chainAll);
            }
            return this.thru(interceptor);
          };
        });
        arrayEach(['concat', 'join', 'pop', 'push', 'replace', 'shift', 'sort', 'splice', 'split', 'unshift'], function(methodName) {
          var func = (/^(?:replace|split)$/.test(methodName) ? stringProto : arrayProto)[methodName],
              chainName = /^(?:push|sort|unshift)$/.test(methodName) ? 'tap' : 'thru',
              retUnwrapped = /^(?:join|pop|replace|shift)$/.test(methodName);
          lodash.prototype[methodName] = function() {
            var args = arguments;
            if (retUnwrapped && !this.__chain__) {
              return func.apply(this.value(), args);
            }
            return this[chainName](function(value) {
              return func.apply(value, args);
            });
          };
        });
        LazyWrapper.prototype.clone = lazyClone;
        LazyWrapper.prototype.reverse = lazyReverse;
        LazyWrapper.prototype.value = lazyValue;
        lodash.prototype.chain = wrapperChain;
        lodash.prototype.commit = wrapperCommit;
        lodash.prototype.plant = wrapperPlant;
        lodash.prototype.reverse = wrapperReverse;
        lodash.prototype.toString = wrapperToString;
        lodash.prototype.run = lodash.prototype.toJSON = lodash.prototype.valueOf = lodash.prototype.value = wrapperValue;
        lodash.prototype.collect = lodash.prototype.map;
        lodash.prototype.head = lodash.prototype.first;
        lodash.prototype.select = lodash.prototype.filter;
        lodash.prototype.tail = lodash.prototype.rest;
        return lodash;
      }
      var _ = runInContext();
      if (typeof define == 'function' && typeof define.amd == 'object' && define.amd) {
        root._ = _;
        define(function() {
          return _;
        });
      } else if (freeExports && freeModule) {
        if (moduleExports) {
          (freeModule.exports = _)._ = _;
        } else {
          freeExports._ = _;
        }
      } else {
        root._ = _;
      }
    }.call(this));
  })(require("process"));
  global.define = __define;
  return module.exports;
});

System.register("npm:lodash@3.5.0", ["npm:lodash@3.5.0/index"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  module.exports = require("npm:lodash@3.5.0/index");
  global.define = __define;
  return module.exports;
});

System.register("arbeit/main", ["lodash", "THREE", "OrbitControls", "./particleset", "./proxy", "glMatrix", "threestrap"], function($__export) {
  "use strict";
  var __moduleName = "arbeit/main";
  var _,
      THREE,
      OrbitControls,
      ParticleSet,
      Proxy,
      glMatrix,
      ts,
      SOL,
      G,
      N,
      DELTA,
      particles,
      geometry,
      proxy,
      tx;
  function run() {
    console.info('Starting the simulation...');
    var paused = false;
    var three = THREE.Bootstrap({
      plugins: ['core', 'stats', 'controls', 'fullscreen'],
      controls: {klass: THREE.OrbitControls},
      camera: {
        near: 0.1,
        far: 1e20
      },
      fullscreen: {key: 'f'}
    });
    three.camera.position.set(1300, 1300, 1300);
    var mat = new THREE.PointCloudMaterial({
      size: 1.0,
      vertexColors: THREE.VertexColors
    });
    var cloud = new THREE.PointCloud(geometry, mat);
    three.scene.add(cloud);
    var helper = new THREE.AxisHelper(250);
    three.scene.add(helper);
    console.info('Generating %d points...', N);
    for (var i = 0; i < N; i++) {
      var theta = Math.random() * 2 * Math.PI;
      var phi = Math.random() * Math.PI - (Math.PI / 2);
      var x = 1.0e5 * Math.cos(theta) * Math.cos(phi);
      var y = 1.0e2 * Math.sin(phi);
      var z = 1.0e5 * Math.sin(theta) * Math.cos(phi);
      var p = particles.at(i);
      vec3.set(p.position, x, y, z);
      p.mass = 0.005 * Math.random() * SOL;
      var dist = vec3.length(p.position);
      var dir = vec3.cross(vec3.create(), p.position, [0, 1, 0]);
      vec3.normalize(dir, dir);
      vec3.scale(p.velocity, dir, Math.sqrt(G * (SOL + p.mass) / dist));
    }
    vec3.set(particles.at(0).position, 0, 0, 0);
    particles.at(0).mass = SOL;
    vec3.set(particles.at(0).velocity, 0, 0, 0);
    tx.positions.set(particles.data.positions);
    tx.velocities.set(particles.data.velocities);
    tx.accelerations.set(particles.data.accelerations);
    tx.masses.set(particles.data.masses);
    geometry.vertices = Array.from(particles, (function(p) {
      return new THREE.Vector3(p.position[0], p.position[1], p.position[2]);
    }));
    geometry.colors = Array.from(particles, (function(p) {
      var color = new THREE.Color();
      color.setHSL(p.mass / (0.005 * SOL), 1.0, 0.6);
      return color;
    }));
    document.onkeypress = (function(evt) {
      if (evt.which == 112) {
        if (paused) {
          console.info("Simulation resumed.");
        } else {
          console.info("Simulation paused.");
        }
        paused = !paused;
      }
    });
    three.on('update', function() {
      if (paused)
        return ;
      var time = three.Time.now;
      var delta = three.Time.delta;
      for (var i = 0; i < particles.length; i++) {
        var p = particles.at(i);
        vec3.scaleAndAdd(p.velocity, p.velocity, p.acceleration, delta);
        vec3.scaleAndAdd(p.position, p.position, p.velocity, delta);
        geometry.vertices[i].fromArray(p.position);
      }
      helper.position.fromArray(particles.at(0).position);
      geometry.verticesNeedUpdate = true;
    });
    proxy.run().then(function(worker) {
      worker.onmessage = receive;
      send();
    });
  }
  function receive(evt) {
    tx.positions = evt.data.positions;
    tx.velocities = evt.data.velocities;
    tx.accelerations = evt.data.accelerations;
    tx.masses = evt.data.masses;
    particles.data.accelerations.set(tx.accelerations);
    var delay = Math.max(DELTA * 1000 - (Date.now() - tx.sent), 0);
    setTimeout(send, delay);
  }
  function send() {
    tx.positions.set(particles.data.positions);
    tx.velocities.set(particles.data.velocities);
    tx.accelerations.set(particles.data.accelerations);
    tx.masses.set(particles.data.masses);
    tx.sent = Date.now();
    proxy.send({
      count: N,
      delta: DELTA,
      positions: tx.positions,
      velocities: tx.velocities,
      accelerations: tx.accelerations,
      masses: tx.masses
    }, [tx.positions.buffer, tx.velocities.buffer, tx.accelerations.buffer, tx.masses.buffer]);
  }
  $__export("run", run);
  return {
    setters: [function($__m) {
      _ = $__m.default;
    }, function($__m) {
      THREE = $__m.default;
    }, function($__m) {
      OrbitControls = $__m.default;
    }, function($__m) {
      ParticleSet = $__m.ParticleSet;
    }, function($__m) {
      Proxy = $__m.Proxy;
    }, function($__m) {
      glMatrix = $__m.default;
    }, function($__m) {
      ts = $__m;
    }],
    execute: function() {
      SOL = 1.98892e15;
      G = 6.67384e-8;
      N = 5000;
      DELTA = 1 / 60;
      particles = new ParticleSet(N);
      geometry = new THREE.Geometry();
      proxy = new Proxy('worker.js');
      tx = {
        sent: null,
        positions: new Float64Array(N * 3),
        velocities: new Float64Array(N * 3),
        accelerations: new Float64Array(N * 3),
        masses: new Float64Array(N)
      };
    }
  };
});
